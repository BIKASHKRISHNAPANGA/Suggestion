export const data = [
  {
    title: 'Find Two Sum Indices',
    slug: 'find-two-sum-indices',
    description:
      'Find two distinct indices in an array such that their values sum up to a given target.',
    problemStatement:
      '<p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return the indices of the two numbers such that they add up to the target. Each input will have exactly one solution, and you may not use the same element twice.</p><p>Return the answer as an array of the two indices in any order.</p><p><strong>Examples:</strong></p><pre><code>Input: 4\n2 7 11 15\n9\nOutput: 0 1</code></pre><p>Explanation: nums[0] + nums[1] = 2 + 7 = 9</p><pre><code>Input: 3\n3 2 4\n6\nOutput: 1 2</code></pre><p>Explanation: nums[1] + nums[2] = 2 + 4 = 6</p><pre><code>Input: 2\n3 3\n6\nOutput: 0 1</code></pre><p>Explanation: nums[0] + nums[1] = 3 + 3 = 6</p><p><strong>Constraints:</strong></p><ul><li>2 ≤ nums.length ≤ 10<sup>4</sup></li><li>-10<sup>9</sup> ≤ nums[i] ≤ 10<sup>9</sup></li><li>-10<sup>9</sup> ≤ target ≤ 10<sup>9</sup></li><li>Exactly one valid answer exists</li></ul><p><strong>Pro Tip:</strong> Use a hash map to keep track of seen values and their indices while iterating through the array.</p>',
    sampleTestCases: [
      {
        input: '4\n2 7 11 15\n9',
        expected: '0 1',
      },
      {
        input: '3\n3 2 4\n6',
        expected: '1 2',
      },
      {
        input: '2\n3 3\n6',
        expected: '0 1',
      },
    ],
    testCases: [
      {
        input: '5\n1 5 3 7 9\n10',
        expected: '1 3',
      },
      {
        input: '4\n1 2 3 4\n5',
        expected: '0 3',
      },
      {
        input: '6\n10 15 3 7 11 4\n14',
        expected: '2 3',
      },
      {
        input: '3\n1 4 5\n9',
        expected: '1 2',
      },
      {
        input: '4\n-1 -2 -3 -4\n-6',
        expected: '1 3',
      },
      {
        input: '4\n1000000000 3 4 -999999997\n3',
        expected: '0 3',
      },
      {
        input: '2\n0 0\n0',
        expected: '0 1',
      },
      {
        input: '3\n-1 0 1\n0',
        expected: '0 2',
      },
      {
        input: '5\n5 75 25 45 30\n100',
        expected: '1 2',
      },
      {
        input: '3\n8 3 7\n10',
        expected: '1 2',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "So, imagine you're at a supermarket with a limited budget. You want to pick two items from the list whose prices add up exactly to the money you have. Can you help the cashier figure out which two items those are, using their price list?",
    difficulty: 'easy',
    frequency: 92,
    tags: ['hashmap', 'array', 'brute force', 'two pointer'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Use a dictionary to store the index of each visited number.',
      'Check if the complement (target - current) exists before adding current to the map.',
      'You only need one pass through the array.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const target = parseInt(input[2]);\n  const result = twoSum(nums, target);\n  console.log(result.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    target = int(input_lines[2])\n    result = twoSum(nums, target)\n    print(" ".join(map(str, result)))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.nextLine());\n        int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n        int target = Integer.parseInt(sc.nextLine());\n        int[] result = twoSum(nums, target);\n        System.out.println(result[0] + " " + result[1]);\n    }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\nint main() {\n    int n, target;\n    cin >> n;\n    vector<int> nums(n);\n    for (int i = 0; i < n; ++i) cin >> nums[i];\n    cin >> target;\n    vector<int> res = twoSum(nums, target);\n    cout << res[0] << " " << res[1] << endl;\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function twoSum(nums, target) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def twoSum(nums, target):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int[] twoSum(int[] nums, int target) {\n    // write code here\n    return new int[2];\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> twoSum(vector<int>& nums, int target) {\n    // write code here\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Max Profit from Stock Prices',
    slug: 'max-profit-from-stock-prices',
    description:
      'Find the maximum profit achievable from a single buy-sell stock transaction.',
    problemStatement:
      '<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.</p><p>Return the maximum profit you can achieve from this transaction. If no profit is possible, return <code>0</code>.</p><p><strong>Examples:</strong></p><pre><code>Input: 6\n7 1 5 3 6 4\nOutput: 5</code></pre><p>Explanation: Buy on day 1 (price = 1) and sell on day 4 (price = 6), profit = 6 - 1 = 5.</p><pre><code>Input: 5\n7 6 4 3 1\nOutput: 0</code></pre><p>Explanation: No transaction is done, i.e., max profit = 0.</p><pre><code>Input: 5\n2 4 1 7 3\nOutput: 6</code></pre><p>Explanation: Buy at 1 and sell at 7 for max profit.</p><p><strong>Constraints:</strong></p><ul><li>1 ≤ prices.length ≤ 10<sup>5</sup></li><li>0 ≤ prices[i] ≤ 10<sup>4</sup></li></ul><p><strong>Pro Tip:</strong> Track the minimum price so far and compare it with the current price to find max profit in one pass.</p>',
    sampleTestCases: [
      {
        input: '6\n7 1 5 3 6 4',
        expected: '5',
      },
      {
        input: '5\n7 6 4 3 1',
        expected: '0',
      },
      {
        input: '5\n2 4 1 7 3',
        expected: '6',
      },
    ],
    testCases: [
      {
        input: '2\n1 5',
        expected: '4',
      },
      {
        input: '2\n5 1',
        expected: '0',
      },
      {
        input: '7\n3 2 6 1 3 4 8',
        expected: '7',
      },
      {
        input: '6\n2 1 2 1 0 1',
        expected: '1',
      },
      {
        input: '1\n5',
        expected: '0',
      },
      {
        input: '4\n2 4 1 5',
        expected: '4',
      },
      {
        input: '5\n3 3 3 3 3',
        expected: '0',
      },
      {
        input: '6\n10 2 5 1 8 7',
        expected: '7',
      },
      {
        input: '6\n1 10000 2 10000 3 10000',
        expected: '9999',
      },
      {
        input: '3\n9 1 10',
        expected: '9',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're monitoring the daily prices of a particular stock and you're only allowed to buy once and sell once. When would you buy and when would you sell to get the highest profit?",
    difficulty: 'easy',
    frequency: 87,
    tags: ['greedy', 'array', 'one pass'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Bloomberg', logoUrl: '' },
    ],
    hints: [
      'Track the minimum price while iterating.',
      'Calculate the profit with the current price minus minimum seen so far.',
      'Keep updating max profit accordingly.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const prices = input[1].split(" ").map(Number);\n  const res = maxProfit(prices);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    prices = list(map(int, input_lines[1].split()))\n    result = maxProfit(prices)\n    print(result)',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] prices = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int result = maxProfit(prices);\n    System.out.println(result);\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  vector<int> prices(n);\n  for (int i = 0; i < n; ++i) cin >> prices[i];\n  int res = maxProfit(prices);\n  cout << res << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function maxProfit(prices) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def maxProfit(prices):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int maxProfit(int[] prices) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'int maxProfit(vector<int>& prices) {\n    // write code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Maximum Subarray Sum',
    slug: 'maximum-subarray-sum',
    description:
      'Find the contiguous subarray within a one-dimensional array which has the largest sum.',
    problemStatement:
      "<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>You must implement an efficient solution using Kadane's Algorithm.</p><p><strong>Examples:</strong></p><pre><code>Input: 9\n-2 1 -3 4 -1 2 1 -5 4\nOutput: 6</code></pre><p>Explanation: [4, -1, 2, 1] has the largest sum = 6.</p><pre><code>Input: 5\n1 2 3 4 5\nOutput: 15</code></pre><p>Explanation: Whole array gives the max sum.</p><pre><code>Input: 4\n-1 -2 -3 -4\nOutput: -1</code></pre><p>Explanation: Largest sum is the single least negative number.</p><p><strong>Constraints:</strong></p><ul><li>1 ≤ nums.length ≤ 10<sup>5</sup></li><li>-10<sup>4</sup> ≤ nums[i] ≤ 10<sup>4</sup></li></ul><p><strong>Pro Tip:</strong> Track current sum and reset it to current number if it drops below it. Keep track of global max.</p>",
    sampleTestCases: [
      {
        input: '9\n-2 1 -3 4 -1 2 1 -5 4',
        expected: '6',
      },
      {
        input: '5\n1 2 3 4 5',
        expected: '15',
      },
      {
        input: '4\n-1 -2 -3 -4',
        expected: '-1',
      },
    ],
    testCases: [
      {
        input: '3\n-2 -1 -3',
        expected: '-1',
      },
      {
        input: '6\n5 4 -1 7 8 -3',
        expected: '23',
      },
      {
        input: '2\n1 -2',
        expected: '1',
      },
      {
        input: '2\n-2 1',
        expected: '1',
      },
      {
        input: '5\n-2 -3 4 -1 -2',
        expected: '4',
      },
      {
        input: '8\n8 -19 5 -4 20 0 -2 3',
        expected: '24',
      },
      {
        input: '7\n-1 -2 -3 -4 -5 -6 -7',
        expected: '-1',
      },
      {
        input: '6\n3 -2 5 -1 2 -3',
        expected: '7',
      },
      {
        input: '4\n0 0 0 0',
        expected: '0',
      },
      {
        input: '5\n-1 2 3 -5 4',
        expected: '5',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You've been asked to analyze the mood of users in a social app. Each post has a score. Find the most positive streak — the consecutive posts with the highest total score.",
    difficulty: 'medium',
    frequency: 95,
    tags: ['dynamic programming', 'array', "kadane's algorithm"],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Use a variable to track the max sum ending at current index.',
      'Reset current sum if it becomes less than the current element.',
      'Keep track of the global max at each step.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const res = maxSubArray(nums);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    result = maxSubArray(nums)\n    print(result)',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int result = maxSubArray(nums);\n    System.out.println(result);\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) cin >> nums[i];\n  int res = maxSubArray(nums);\n  cout << res << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function maxSubArray(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def maxSubArray(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int maxSubArray(int[] nums) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'int maxSubArray(vector<int>& nums) {\n    // write code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Move Zeroes to End',
    slug: 'move-zeroes-to-end',
    description:
      'Move all zeroes in the array to the end while maintaining the order of non-zero elements.',
    problemStatement:
      "<p>Given an integer array <code>nums</code>, move all <code>0</code>'s to the end of it while maintaining the relative order of the non-zero elements. You must do this in-place without making a copy of the array.</p><p>Modify the array in-place and return it.</p><p><strong>Examples:</strong></p><pre><code>Input: 5\n0 1 0 3 12\nOutput: 1 3 12 0 0</code></pre><p>Explanation: All non-zero elements stay in order, and zeroes are pushed to the end.</p><pre><code>Input: 3\n0 0 1\nOutput: 1 0 0</code></pre><p><strong>Constraints:</strong></p><ul><li>1 ≤ nums.length ≤ 10<sup>4</sup></li><li>-2<sup>31</sup> ≤ nums[i] ≤ 2<sup>31</sup> - 1</li></ul><p><strong>Pro Tip:</strong> Use a pointer to track the position to place the next non-zero number.</p>",
    sampleTestCases: [
      {
        input: '5\n0 1 0 3 12',
        expected: '1 3 12 0 0',
      },
      {
        input: '3\n0 0 1',
        expected: '1 0 0',
      },
      {
        input: '4\n1 0 2 0',
        expected: '1 2 0 0',
      },
    ],
    testCases: [
      {
        input: '5\n0 0 0 0 0',
        expected: '0 0 0 0 0',
      },
      {
        input: '5\n1 2 3 4 5',
        expected: '1 2 3 4 5',
      },
      {
        input: '6\n1 0 0 2 3 0',
        expected: '1 2 3 0 0 0',
      },
      {
        input: '2\n0 1',
        expected: '1 0',
      },
      {
        input: '2\n1 0',
        expected: '1 0',
      },
      {
        input: '1\n0',
        expected: '0',
      },
      {
        input: '3\n4 0 5',
        expected: '4 5 0',
      },
      {
        input: '4\n0 2 0 1',
        expected: '2 1 0 0',
      },
      {
        input: '6\n0 1 0 0 2 3',
        expected: '1 2 3 0 0 0',
      },
      {
        input: '7\n0 0 1 2 0 3 4',
        expected: '1 2 3 4 0 0 0',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Imagine your team is filtering out error logs (represented by 0) but wants to preserve all the valid entries in their original order. Can you write a routine that moves all the errors to the end efficiently?',
    difficulty: 'easy',
    frequency: 89,
    tags: ['array', 'two pointer', 'in-place'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use a pointer to overwrite zeroes with non-zero elements.',
      'Once done, fill the rest with zeroes.',
      'Do it in a single pass or minimal passes for efficiency.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  moveZeroes(nums);\n  console.log(nums.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    moveZeroes(nums)\n    print(" ".join(map(str, nums)))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    moveZeroes(nums);\n    for (int num : nums) System.out.print(num + " ");\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) cin >> nums[i];\n  moveZeroes(nums);\n  for (int x : nums) cout << x << " ";\n  cout << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function moveZeroes(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def moveZeroes(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static void moveZeroes(int[] nums) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'void moveZeroes(vector<int>& nums) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Rotate Array to the Right',
    slug: 'rotate-array-to-the-right',
    description:
      'Rotate the elements of an array to the right by k steps in-place.',
    problemStatement:
      '<p>Given an integer array <code>nums</code> and an integer <code>k</code>, rotate the array to the right by <code>k</code> steps, where <code>k</code> is non-negative. The rotation should be done in-place with <code>O(1)</code> extra space.</p><p><strong>Examples:</strong></p><pre><code>Input: 7\n1 2 3 4 5 6 7\n3\nOutput: 5 6 7 1 2 3 4</code></pre><p>Explanation: Rotate the array to the right by 3 steps.</p><pre><code>Input: 4\n-1 -100 3 99\n2\nOutput: 3 99 -1 -100</code></pre><p><strong>Constraints:</strong></p><ul><li>1 ≤ nums.length ≤ 10<sup>5</sup></li><li>-2<sup>31</sup> ≤ nums[i] ≤ 2<sup>31</sup> - 1</li><li>0 ≤ k ≤ 10<sup>5</sup></li></ul><p><strong>Pro Tip:</strong> Reverse the entire array, then reverse the first <code>k</code> elements and the rest separately for in-place rotation.</p>',
    sampleTestCases: [
      {
        input: '7\n1 2 3 4 5 6 7\n3',
        expected: '5 6 7 1 2 3 4',
      },
      {
        input: '4\n-1 -100 3 99\n2',
        expected: '3 99 -1 -100',
      },
      {
        input: '5\n1 2 3 4 5\n0',
        expected: '1 2 3 4 5',
      },
    ],
    testCases: [
      {
        input: '1\n10\n0',
        expected: '10',
      },
      {
        input: '6\n1 2 3 4 5 6\n6',
        expected: '1 2 3 4 5 6',
      },
      {
        input: '6\n1 2 3 4 5 6\n7',
        expected: '6 1 2 3 4 5',
      },
      {
        input: '5\n10 20 30 40 50\n3',
        expected: '30 40 50 10 20',
      },
      {
        input: '8\n5 10 15 20 25 30 35 40\n4',
        expected: '25 30 35 40 5 10 15 20',
      },
      {
        input: '3\n1 2 3\n1',
        expected: '3 1 2',
      },
      {
        input: '2\n7 8\n3',
        expected: '8 7',
      },
      {
        input: '4\n1 1 1 1\n2',
        expected: '1 1 1 1',
      },
      {
        input: '9\n1 2 3 4 5 6 7 8 9\n5',
        expected: '5 6 7 8 9 1 2 3 4',
      },
      {
        input: '6\n-1 -2 -3 -4 -5 -6\n2',
        expected: '-5 -6 -1 -2 -3 -4',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're working with a time-series buffer that rotates every few seconds. Your task is to simulate this rotation operation efficiently on the buffer data.",
    difficulty: 'medium',
    frequency: 84,
    tags: ['array', 'in-place', 'two pointer'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Uber', logoUrl: '' },
    ],
    hints: [
      'Use array reversal technique for in-place rotation.',
      'Reverse the entire array, then reverse first k and last n-k parts.',
      'Be careful with k > n cases.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const k = parseInt(input[2]);\n  rotate(nums, k);\n  console.log(nums.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    k = int(input_lines[2])\n    rotate(nums, k)\n    print(" ".join(map(str, nums)))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int k = Integer.parseInt(sc.nextLine());\n    rotate(nums, k);\n    for (int num : nums) System.out.print(num + " ");\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\n  int n, k;\n  cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) cin >> nums[i];\n  cin >> k;\n  rotate(nums, k);\n  for (int x : nums) cout << x << " ";\n  cout << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function rotate(nums, k) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def rotate(nums, k):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static void rotate(int[] nums, int k) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'void rotate(vector<int>& nums, int k) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Remove Duplicates from Sorted Array',
    slug: 'remove-duplicates-from-sorted-array',
    description:
      'Remove duplicates in-place from a sorted array and return the new length.',
    problemStatement:
      '<p>Given a sorted integer array <code>nums</code>, remove the duplicates in-place such that each element appears only once and return the new length. The relative order of the elements should be kept the same.</p><p>Do not allocate extra space for another array; you must do this by modifying the input array in-place with <code>O(1)</code> extra memory.</p><p>After removing duplicates, the first <code>k</code> elements of <code>nums</code> should hold the final result. It does not matter what you leave beyond the first <code>k</code> elements.</p><p><strong>Examples:</strong></p><pre><code>Input: 6\n0 0 1 1 2 2\nOutput: 3\nArray after removal: 0 1 2</code></pre><pre><code>Input: 5\n1 1 2 3 3\nOutput: 3\nArray after removal: 1 2 3</code></pre><p><strong>Constraints:</strong></p><ul><li>1 ≤ nums.length ≤ 3 × 10<sup>4</sup></li><li>-100 ≤ nums[i] ≤ 100</li><li><code>nums</code> is sorted in non-decreasing order</li></ul><p><strong>Pro Tip:</strong> Use a two-pointer approach—one to scan and one to place unique values.</p>',
    sampleTestCases: [
      {
        input: '6\n0 0 1 1 2 2',
        expected: '3\n0 1 2',
      },
      {
        input: '5\n1 1 2 3 3',
        expected: '3\n1 2 3',
      },
      {
        input: '1\n1',
        expected: '1\n1',
      },
    ],
    testCases: [
      {
        input: '4\n1 1 1 1',
        expected: '1\n1',
      },
      {
        input: '5\n1 2 3 4 5',
        expected: '5\n1 2 3 4 5',
      },
      {
        input: '7\n1 1 2 2 3 3 4',
        expected: '4\n1 2 3 4',
      },
      {
        input: '6\n0 0 0 1 1 1',
        expected: '2\n0 1',
      },
      {
        input: '10\n1 1 1 2 2 3 4 4 5 6',
        expected: '6\n1 2 3 4 5 6',
      },
      {
        input: '3\n1 1 2',
        expected: '2\n1 2',
      },
      {
        input: '2\n1 2',
        expected: '2\n1 2',
      },
      {
        input: '8\n-1 -1 0 0 1 1 2 2',
        expected: '4\n-1 0 1 2',
      },
      {
        input: '4\n-2 -2 -1 -1',
        expected: '2\n-2 -1',
      },
      {
        input: '5\n100 100 100 100 100',
        expected: '1\n100',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'A common task in data cleaning is to remove duplicates from sorted entries. Can you process this list efficiently without using extra space?',
    difficulty: 'easy',
    frequency: 90,
    tags: ['two pointer', 'array', 'in-place'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Apple', logoUrl: '' },
    ],
    hints: [
      'Use two pointers to compare and overwrite duplicates.',
      'Start from the second element and move unique values forward.',
      'Return the position of the last unique index + 1.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const k = removeDuplicates(nums);\n  console.log(k);\n  console.log(nums.slice(0, k).join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    k = removeDuplicates(nums)\n    print(k)\n    print(" ".join(map(str, nums[:k])))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int k = removeDuplicates(nums);\n    System.out.println(k);\n    for (int i = 0; i < k; ++i) System.out.print(nums[i] + " ");\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) cin >> nums[i];\n  int k = removeDuplicates(nums);\n  cout << k << endl;\n  for (int i = 0; i < k; ++i) cout << nums[i] << " ";\n  cout << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function removeDuplicates(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def removeDuplicates(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int removeDuplicates(int[] nums) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'int removeDuplicates(vector<int>& nums) {\n    // write code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Check If Array is Sorted and Rotated',
    slug: 'check-if-array-is-sorted-and-rotated',
    description:
      'Determine if a given array was originally sorted in non-decreasing order and then rotated.',
    problemStatement:
      '<p>Given an array of distinct integers <code>nums</code>, check if it is a sorted array that has been rotated. A sorted array is considered rotated if it has been shifted at least one position, with wrap-around at the ends.</p><p>Return <code>true</code> if the array was sorted in non-decreasing order and then rotated, otherwise return <code>false</code>.</p><p><strong>Examples:</strong></p><pre><code>Input: 5\n3 4 5 1 2\nOutput: true</code></pre><p>Explanation: Original sorted array was [1, 2, 3, 4, 5], rotated to [3, 4, 5, 1, 2].</p><pre><code>Input: 4\n2 1 3 4\nOutput: false</code></pre><p>Explanation: The array is not a rotated version of a sorted array.</p><pre><code>Input: 5\n1 2 3 4 5\nOutput: true</code></pre><p>Explanation: The array is already sorted and can be considered as rotated 0 times.</p><p><strong>Constraints:</strong></p><ul><li>1 ≤ nums.length ≤ 10<sup>5</sup></li><li>All elements in <code>nums</code> are distinct.</li></ul><p><strong>Pro Tip:</strong> Count the number of times a descending pair occurs. It should not be more than once for a valid rotated sorted array.</p>',
    sampleTestCases: [
      {
        input: '5\n3 4 5 1 2',
        expected: 'true',
      },
      {
        input: '4\n2 1 3 4',
        expected: 'false',
      },
      {
        input: '5\n1 2 3 4 5',
        expected: 'true',
      },
    ],
    testCases: [
      {
        input: '6\n6 1 2 3 4 5',
        expected: 'true',
      },
      {
        input: '3\n2 3 1',
        expected: 'true',
      },
      {
        input: '4\n4 1 2 3',
        expected: 'true',
      },
      {
        input: '4\n3 2 1 4',
        expected: 'false',
      },
      {
        input: '4\n1 3 2 4',
        expected: 'false',
      },
      {
        input: '2\n2 1',
        expected: 'true',
      },
      {
        input: '1\n7',
        expected: 'true',
      },
      {
        input: '6\n1 2 3 4 5 6',
        expected: 'true',
      },
      {
        input: '5\n5 1 2 3 4',
        expected: 'true',
      },
      {
        input: '3\n3 1 2',
        expected: 'true',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Suppose you're inspecting log files that were time-sorted and then rotated daily. Can you detect whether a given sequence of timestamps represents a rotated version of a sorted log?",
    difficulty: 'easy',
    frequency: 73,
    tags: ['array', 'rotation', 'observation'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Traverse the array and count how many times nums[i] > nums[i+1].',
      "If count > 1, it can't be a rotated sorted array.",
      'Make sure to also compare the last and first element.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const result = check(nums);\n  console.log(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    result = check(nums)\n    print(result)',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    boolean result = check(nums);\n    System.out.println(result);\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nbool check(vector<int>& nums);\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) cin >> nums[i];\n  cout << (check(nums) ? "true" : "false") << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function check(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def check(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static boolean check(int[] nums) {\n    // write code here\n    return false;\n}',
      },
      {
        language: 'cpp',
        code: 'bool check(vector<int>& nums) {\n    // write code here\n    return false;\n}',
      },
    ],
  },
  {
    title: 'Left Rotate Array by D Places',
    slug: 'left-rotate-array-by-d-places',
    description:
      'Rotate an array to the left by a given number of positions in-place.',
    problemStatement:
      '<p>Given an integer array <code>nums</code> and an integer <code>d</code>, rotate the array to the left by <code>d</code> positions. The operation should be performed in-place with <code>O(1)</code> extra space.</p><p><strong>Examples:</strong></p><pre><code>Input: 6\n1 2 3 4 5 6\n2\nOutput: 3 4 5 6 1 2</code></pre><p>Explanation: Array is rotated left by 2 positions.</p><pre><code>Input: 5\n10 20 30 40 50\n3\nOutput: 40 50 10 20 30</code></pre><p><strong>Constraints:</strong></p><ul><li>1 ≤ nums.length ≤ 10<sup>5</sup></li><li>0 ≤ d ≤ 10<sup>5</sup></li><li>-10<sup>9</sup> ≤ nums[i] ≤ 10<sup>9</sup></li></ul><p><strong>Pro Tip:</strong> Use reverse operations: reverse the first <code>d</code> elements, reverse the rest, and then reverse the entire array.</p>',
    sampleTestCases: [
      {
        input: '6\n1 2 3 4 5 6\n2',
        expected: '3 4 5 6 1 2',
      },
      {
        input: '5\n10 20 30 40 50\n3',
        expected: '40 50 10 20 30',
      },
      {
        input: '4\n7 8 9 10\n0',
        expected: '7 8 9 10',
      },
    ],
    testCases: [
      {
        input: '3\n1 2 3\n1',
        expected: '2 3 1',
      },
      {
        input: '5\n5 6 7 8 9\n5',
        expected: '5 6 7 8 9',
      },
      {
        input: '4\n-1 -2 -3 -4\n2',
        expected: '-3 -4 -1 -2',
      },
      {
        input: '6\n1 2 3 4 5 6\n6',
        expected: '1 2 3 4 5 6',
      },
      {
        input: '6\n1 2 3 4 5 6\n7',
        expected: '2 3 4 5 6 1',
      },
      {
        input: '1\n100\n3',
        expected: '100',
      },
      {
        input: '3\n100 200 300\n0',
        expected: '100 200 300',
      },
      {
        input: '3\n100 200 300\n3',
        expected: '100 200 300',
      },
      {
        input: '6\n9 8 7 6 5 4\n3',
        expected: '6 5 4 9 8 7',
      },
      {
        input: '7\n0 1 2 3 4 5 6\n4',
        expected: '4 5 6 0 1 2 3',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re building a circular queue system. Sometimes you need to rotate elements to the left to simulate queue advancement. Can you implement a left rotation efficiently?',
    difficulty: 'medium',
    frequency: 78,
    tags: ['array', 'rotation', 'in-place', 'reverse'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Samsung', logoUrl: '' },
    ],
    hints: [
      'Reverse the first d elements.',
      'Reverse the remaining n-d elements.',
      'Reverse the whole array for final rotation.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const d = parseInt(input[2]);\n  rotateLeft(nums, d);\n  console.log(nums.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    d = int(input_lines[2])\n    rotateLeft(nums, d)\n    print(" ".join(map(str, nums)))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int d = Integer.parseInt(sc.nextLine());\n    rotateLeft(nums, d);\n    for (int num : nums) System.out.print(num + " ");\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nvoid rotateLeft(vector<int>& nums, int d);\nint main() {\n  int n, d;\n  cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) cin >> nums[i];\n  cin >> d;\n  rotateLeft(nums, d);\n  for (int x : nums) cout << x << " ";\n  cout << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function rotateLeft(nums, d) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def rotateLeft(nums, d):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static void rotateLeft(int[] nums, int d) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'void rotateLeft(vector<int>& nums, int d) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Find Second Largest Element',
    slug: 'find-second-largest-element',
    description:
      'Return the second largest distinct element from an unsorted array.',
    problemStatement:
      '<p>Given an array of integers <code>nums</code>, your task is to return the second largest distinct element in the array. If there is no such element (i.e., all elements are the same), return <code>-1</code>.</p><p><strong>Examples:</strong></p><pre><code>Input: 5\n12 35 1 10 34\nOutput: 34</code></pre><p>Explanation: The largest is 35, and second largest is 34.</p><pre><code>Input: 4\n10 10 10 10\nOutput: -1</code></pre><p>Explanation: All elements are the same, so no second largest exists.</p><pre><code>Input: 3\n2 3 1\nOutput: 2</code></pre><p><strong>Constraints:</strong></p><ul><li>2 ≤ nums.length ≤ 10<sup>5</sup></li><li>-10<sup>9</sup> ≤ nums[i] ≤ 10<sup>9</sup></li></ul><p><strong>Pro Tip:</strong> Track the largest and second largest values in one pass. Skip duplicates of the largest.</p>',
    sampleTestCases: [
      {
        input: '5\n12 35 1 10 34',
        expected: '34',
      },
      {
        input: '4\n10 10 10 10',
        expected: '-1',
      },
      {
        input: '3\n2 3 1',
        expected: '2',
      },
    ],
    testCases: [
      {
        input: '6\n5 7 7 8 8 9',
        expected: '8',
      },
      {
        input: '2\n100 200',
        expected: '100',
      },
      {
        input: '5\n3 3 3 2 2',
        expected: '2',
      },
      {
        input: '3\n1 1 2',
        expected: '1',
      },
      {
        input: '5\n10 20 30 40 50',
        expected: '40',
      },
      {
        input: '5\n50 40 30 20 10',
        expected: '40',
      },
      {
        input: '4\n-1 -2 -3 -4',
        expected: '-2',
      },
      {
        input: '4\n1 1 2 2',
        expected: '1',
      },
      {
        input: '3\n1000000000 999999999 999999998',
        expected: '999999999',
      },
      {
        input: '2\n-5 -5',
        expected: '-1',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Let's say you have a leaderboard of scores. Can you quickly identify the second best performer without sorting the entire list?",
    difficulty: 'easy',
    frequency: 75,
    tags: ['array', 'greedy', 'sorting'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'TCS', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Track the maximum and update second max when needed.',
      'Skip values equal to current max.',
      'Careful when all values are the same.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const result = secondLargest(nums);\n  console.log(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    result = secondLargest(nums)\n    print(result)',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int result = secondLargest(nums);\n    System.out.println(result);\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint secondLargest(vector<int>& nums);\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) cin >> nums[i];\n  cout << secondLargest(nums) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function secondLargest(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def secondLargest(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int secondLargest(int[] nums) {\n    // write code here\n    return -1;\n}',
      },
      {
        language: 'cpp',
        code: 'int secondLargest(vector<int>& nums) {\n    // write code here\n    return -1;\n}',
      },
    ],
  },
  {
    title: 'Leaders in an Array',
    slug: 'leaders-in-an-array',
    description:
      'Find all leaders in an array where a leader is greater than all elements to its right.',
    problemStatement:
      '<p>Given an array of integers <code>nums</code>, a leader is an element that is strictly greater than all elements to its right. The rightmost element is always a leader.</p><p>Return all leaders in the array in the same order as they appear in the original array.</p><p><strong>Examples:</strong></p><pre><code>Input: 6\n16 17 4 3 5 2\nOutput: 17 5 2</code></pre><p>Explanation: From right to left, leaders are 2, 5, and 17 (in original order).</p><pre><code>Input: 5\n1 2 3 4 0\nOutput: 4 0</code></pre><p><strong>Constraints:</strong></p><ul><li>1 ≤ nums.length ≤ 10<sup>5</sup></li><li>-10<sup>9</sup> ≤ nums[i] ≤ 10<sup>9</sup></li></ul><p><strong>Pro Tip:</strong> Traverse the array from right to left, keeping track of the maximum seen so far.</p>',
    sampleTestCases: [
      {
        input: '6\n16 17 4 3 5 2',
        expected: '17 5 2',
      },
      {
        input: '5\n1 2 3 4 0',
        expected: '4 0',
      },
      {
        input: '1\n10',
        expected: '10',
      },
    ],
    testCases: [
      {
        input: '5\n7 10 4 10 6',
        expected: '10 10 6',
      },
      {
        input: '6\n1 2 3 4 5 6',
        expected: '6',
      },
      {
        input: '6\n6 5 4 3 2 1',
        expected: '6 5 4 3 2 1',
      },
      {
        input: '4\n5 5 5 5',
        expected: '5',
      },
      {
        input: '7\n10 20 30 5 4 3 2',
        expected: '30 5 4 3 2',
      },
      {
        input: '3\n0 -1 -2',
        expected: '0 -1 -2',
      },
      {
        input: '5\n9 8 1 7 0',
        expected: '9 8 7 0',
      },
      {
        input: '4\n3 2 1 0',
        expected: '3 2 1 0',
      },
      {
        input: '5\n100 99 98 97 96',
        expected: '100 99 98 97 96',
      },
      {
        input: '6\n3 4 2 5 1 0',
        expected: '5 1 0',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re scanning a list of competitor product prices. A price is a leader if no cheaper product follows it. Can you find all such leaders efficiently?',
    difficulty: 'easy',
    frequency: 76,
    tags: ['array', 'traversal', 'greedy'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Accenture', logoUrl: '' },
      { name: 'Wipro', logoUrl: '' },
    ],
    hints: [
      'Traverse from right to left and track current max.',
      "Every time a new number is greater than the max, it's a leader.",
      "Don't forget to reverse your result if needed to preserve order.",
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const res = findLeaders(nums);\n  console.log(res.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    result = findLeaders(nums)\n    print(" ".join(map(str, result)))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    List<Integer> res = findLeaders(nums);\n    for (int num : res) System.out.print(num + " ");\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> findLeaders(vector<int>& nums);\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) cin >> nums[i];\n  vector<int> res = findLeaders(nums);\n  for (int x : res) cout << x << " ";\n  cout << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function findLeaders(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def findLeaders(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static List<Integer> findLeaders(int[] nums) {\n    // write code here\n    return new ArrayList<>();\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> findLeaders(vector<int>& nums) {\n    // write code here\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Product of Array Except Self',
    slug: 'product-of-array-except-self',
    description:
      'Return an array where each element is the product of all other elements except itself.',
    problemStatement:
      '<p>Given an array <code>nums</code> of <code>n</code> integers, return an array <code>output</code> such that <code>output[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code>.</p><p><strong>Note:</strong> Solve it without using division and in <code>O(n)</code> time.</p><p><strong>Examples:</strong></p><pre><code>Input: 4\n1 2 3 4\nOutput: 24 12 8 6</code></pre><p>Explanation: output[i] = product of all elements except nums[i].</p><pre><code>Input: 5\n2 3 4 5 6\nOutput: 360 240 180 144 120</code></pre><p><strong>Constraints:</strong></p><ul><li>2 ≤ nums.length ≤ 10<sup>5</sup></li><li>0 ≤ nums[i] ≤ 100</li><li>The product of any prefix or suffix of <code>nums</code> is guaranteed to fit in a 32-bit integer.</li></ul><p><strong>Pro Tip:</strong> First create a prefix product array, then a suffix product pass to compute final result in-place.</p>',
    sampleTestCases: [
      {
        input: '4\n1 2 3 4',
        expected: '24 12 8 6',
      },
      {
        input: '5\n2 3 4 5 6',
        expected: '360 240 180 144 120',
      },
      {
        input: '3\n1 0 3',
        expected: '0 3 0',
      },
    ],
    testCases: [
      {
        input: '2\n5 6',
        expected: '6 5',
      },
      {
        input: '3\n0 0 2',
        expected: '0 0 0',
      },
      {
        input: '3\n1 2 0',
        expected: '0 0 2',
      },
      {
        input: '4\n1 1 1 1',
        expected: '1 1 1 1',
      },
      {
        input: '5\n10 20 30 40 50',
        expected: '1200000 600000 400000 300000 240000',
      },
      {
        input: '6\n1 2 3 4 5 6',
        expected: '720 360 240 180 144 120',
      },
      {
        input: '3\n1 2 3',
        expected: '6 3 2',
      },
      {
        input: '4\n9 0 1 0',
        expected: '0 0 0 0',
      },
      {
        input: '5\n0 1 2 3 4',
        expected: '24 0 0 0 0',
      },
      {
        input: '3\n100 200 300',
        expected: '60000 30000 20000',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re developing a performance score system where each user’s final score is a product of all other users’ scores except theirs. Can you compute that efficiently?',
    difficulty: 'medium',
    frequency: 91,
    tags: ['array', 'prefix sum', 'space optimization'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'First compute prefix products for each index.',
      'Then compute suffix products in reverse and multiply.',
      'Avoid using division to handle zero elements properly.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1) extra (excluding result array)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const res = productExceptSelf(nums);\n  console.log(res.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    result = productExceptSelf(nums)\n    print(" ".join(map(str, result)))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int[] res = productExceptSelf(nums);\n    for (int num : res) System.out.print(num + " ");\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> productExceptSelf(vector<int>& nums);\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) cin >> nums[i];\n  vector<int> res = productExceptSelf(nums);\n  for (int x : res) cout << x << " ";\n  cout << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function productExceptSelf(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def productExceptSelf(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int[] productExceptSelf(int[] nums) {\n    // write code here\n    return new int[nums.length];\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> productExceptSelf(vector<int>& nums) {\n    // write code here\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Prefix Sum Array',
    slug: 'prefix-sum-array',
    description: 'Compute the prefix sum of a given array.',
    problemStatement:
      '<p>Given an integer array <code>nums</code> of length <code>n</code>, return the prefix sum array <code>prefix</code> where <code>prefix[i]</code> is the sum of elements from index <code>0</code> to <code>i</code> in <code>nums</code>.</p><p><strong>Examples:</strong></p><pre><code>Input: 5\n1 2 3 4 5\nOutput: 1 3 6 10 15</code></pre><p><pre><code>Input: 4\n2 0 -1 3\nOutput: 2 2 1 4</code></pre><p><strong>Constraints:</strong></p><ul><li>1 ≤ nums.length ≤ 10<sup>5</sup></li><li>-10<sup>9</sup> ≤ nums[i] ≤ 10<sup>9</sup></li></ul><p><strong>Pro Tip:</strong> Use a single loop and a cumulative sum variable to build the prefix array.</p>',
    sampleTestCases: [
      {
        input: '5\n1 2 3 4 5',
        expected: '1 3 6 10 15',
      },
      {
        input: '4\n2 0 -1 3',
        expected: '2 2 1 4',
      },
      {
        input: '3\n5 -2 7',
        expected: '5 3 10',
      },
    ],
    testCases: [
      {
        input: '1\n10',
        expected: '10',
      },
      {
        input: '3\n0 0 0',
        expected: '0 0 0',
      },
      {
        input: '4\n-1 -2 -3 -4',
        expected: '-1 -3 -6 -10',
      },
      {
        input: '4\n10 -5 15 -5',
        expected: '10 5 20 15',
      },
      {
        input: '5\n1 1 1 1 1',
        expected: '1 2 3 4 5',
      },
      {
        input: '6\n2 4 6 8 10 12',
        expected: '2 6 12 20 30 42',
      },
      {
        input: '3\n1000000000 1000000000 1000000000',
        expected: '1000000000 2000000000 3000000000',
      },
      {
        input: '2\n5 -5',
        expected: '5 0',
      },
      {
        input: '4\n-10 10 -10 10',
        expected: '-10 0 -10 0',
      },
      {
        input: '5\n3 1 4 1 5',
        expected: '3 4 8 9 14',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "In many analytics scenarios, you're asked to quickly calculate range sums. Can you prepare the data using a prefix sum array efficiently?",
    difficulty: 'easy',
    frequency: 80,
    tags: ['array', 'prefix sum', 'cumulative'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Meta', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Start with prefix[0] = nums[0].',
      'For each index i > 0, compute prefix[i] = prefix[i-1] + nums[i].',
      'Only one pass is needed.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const res = prefixSum(nums);\n  console.log(res.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    result = prefixSum(nums)\n    print(" ".join(map(str, result)))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int[] res = prefixSum(nums);\n    for (int num : res) System.out.print(num + " ");\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nvector<long long> prefixSum(vector<int>& nums);\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) cin >> nums[i];\n  vector<long long> res = prefixSum(nums);\n  for (auto x : res) cout << x << " ";\n  cout << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function prefixSum(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def prefixSum(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int[] prefixSum(int[] nums) {\n    // write code here\n    return new int[nums.length];\n}',
      },
      {
        language: 'cpp',
        code: 'vector<long long> prefixSum(vector<int>& nums) {\n    // write code here\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Find Pivot Index',
    slug: 'find-pivot-index',
    description:
      'Find the index where the sum of numbers to the left is equal to the sum to the right.',
    problemStatement:
      '<p>Given an array of integers <code>nums</code>, return the <strong>pivot index</strong> of this array. The pivot index is the index where the sum of all the numbers strictly to the left is equal to the sum of all the numbers strictly to the right.</p><p>If no such index exists, return <code>-1</code>. If there are multiple pivot indexes, return the left-most one.</p><p><strong>Examples:</strong></p><pre><code>Input: 6\n1 7 3 6 5 6\nOutput: 3</code></pre><p>Explanation: Left sum = 1 + 7 + 3 = 11, Right sum = 5 + 6 = 11.</p><pre><code>Input: 4\n1 2 3 4\nOutput: -1</code></pre><p><strong>Constraints:</strong></p><ul><li>1 ≤ nums.length ≤ 10<sup>4</sup></li><li>-1000 ≤ nums[i] ≤ 1000</li></ul><p><strong>Pro Tip:</strong> Use the total sum and subtract left sum as you iterate to avoid repeated summation.</p>',
    sampleTestCases: [
      {
        input: '6\n1 7 3 6 5 6',
        expected: '3',
      },
      {
        input: '4\n1 2 3 4',
        expected: '-1',
      },
      {
        input: '3\n2 1 -1',
        expected: '0',
      },
    ],
    testCases: [
      {
        input: '5\n2 3 -1 8 4',
        expected: '3',
      },
      {
        input: '4\n1 2 3 -1',
        expected: '-1',
      },
      {
        input: '6\n0 0 0 0 0 0',
        expected: '0',
      },
      {
        input: '5\n1 -1 0 1 -1',
        expected: '2',
      },
      {
        input: '3\n-1 -1 -1',
        expected: '-1',
      },
      {
        input: '4\n1 -1 0 0',
        expected: '2',
      },
      {
        input: '3\n-2 5 -3',
        expected: '1',
      },
      {
        input: '1\n7',
        expected: '0',
      },
      {
        input: '2\n1 -1',
        expected: '-1',
      },
      {
        input: '6\n20 10 -80 10 10 15 35',
        expected: '6',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'A finance app needs to find the moment where deposits equal future withdrawals. Can you spot that balance point in the data stream?',
    difficulty: 'easy',
    frequency: 85,
    tags: ['array', 'prefix sum'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use a variable to keep track of the total sum.',
      'Track left sum as you iterate; right sum becomes total - left - current.',
      'Return the first index where left == right.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const res = pivotIndex(nums);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    print(pivotIndex(nums))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    System.out.println(pivotIndex(nums));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint pivotIndex(vector<int>& nums);\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) cin >> nums[i];\n  cout << pivotIndex(nums) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function pivotIndex(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def pivotIndex(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int pivotIndex(int[] nums) {\n    // write code here\n    return -1;\n}',
      },
      {
        language: 'cpp',
        code: 'int pivotIndex(vector<int>& nums) {\n    // write code here\n    return -1;\n}',
      },
    ],
  },
  {
    title: 'Equilibrium Point in Array',
    slug: 'equilibrium-point-in-array',
    description:
      'Find the index in an array where the sum of elements on both sides is equal.',
    problemStatement:
      '<p>Given an array of integers <code>nums</code>, find the <strong>equilibrium point</strong> — an index such that the sum of elements to the left is equal to the sum of elements to the right. Return the <strong>1-based index</strong> of the equilibrium point. If no such index exists, return <code>-1</code>.</p><p><strong>Examples:</strong></p><pre><code>Input: 5\n1 3 5 2 2\nOutput: 3</code></pre><p>Explanation: 1 + 3 = 4, 2 + 2 = 4</p><pre><code>Input: 1\n1\nOutput: 1</code></pre><p>Explanation: Only one element; sum on both sides is zero.</p><p><strong>Constraints:</strong></p><ul><li>1 ≤ nums.length ≤ 10<sup>5</sup></li><li>-10<sup>9</sup> ≤ nums[i] ≤ 10<sup>9</sup></li></ul><p><strong>Pro Tip:</strong> Track total sum and left sum during iteration. Subtract left and current from total to get right sum.</p>',
    sampleTestCases: [
      {
        input: '5\n1 3 5 2 2',
        expected: '3',
      },
      {
        input: '1\n1',
        expected: '1',
      },
      {
        input: '4\n2 4 6 2',
        expected: '-1',
      },
    ],
    testCases: [
      {
        input: '3\n2 3 5',
        expected: '-1',
      },
      {
        input: '6\n1 2 3 3 2 1',
        expected: '3',
      },
      {
        input: '5\n-1 3 -4 5 2',
        expected: '2',
      },
      {
        input: '6\n0 0 0 0 0 0',
        expected: '1',
      },
      {
        input: '4\n1 -1 1 -1',
        expected: '-1',
      },
      {
        input: '5\n10 5 5 5 10',
        expected: '3',
      },
      {
        input: '2\n1 2',
        expected: '-1',
      },
      {
        input: '3\n0 1 0',
        expected: '2',
      },
      {
        input: '4\n1 2 1 1',
        expected: '-1',
      },
      {
        input: '7\n1 3 5 7 9 2 1',
        expected: '-1',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re monitoring load across servers. An equilibrium point is a server where the load on both sides is perfectly balanced. Can you find it efficiently?',
    difficulty: 'easy',
    frequency: 74,
    tags: ['array', 'prefix sum'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'TCS', logoUrl: '' },
      { name: 'Capgemini', logoUrl: '' },
    ],
    hints: [
      'Calculate total sum of the array first.',
      'As you iterate, keep track of left sum.',
      'If left sum equals total - left - current, you found it.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const res = equilibriumPoint(nums);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    print(equilibriumPoint(nums))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    System.out.println(equilibriumPoint(nums));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint equilibriumPoint(vector<int>& nums);\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) cin >> nums[i];\n  cout << equilibriumPoint(nums) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function equilibriumPoint(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def equilibriumPoint(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int equilibriumPoint(int[] nums) {\n    // write code here\n    return -1;\n}',
      },
      {
        language: 'cpp',
        code: 'int equilibriumPoint(vector<int>& nums) {\n    // write code here\n    return -1;\n}',
      },
    ],
  },
  {
    title: 'Maximum Sum Subarray of Size K',
    slug: 'maximum-sum-subarray-of-size-k',
    description: 'Find the maximum sum of a contiguous subarray of size k.',
    problemStatement:
      '<p>Given an array of integers <code>nums</code> and an integer <code>k</code>, find the maximum sum of any contiguous subarray of size <code>k</code>.</p><p><strong>Examples:</strong></p><pre><code>Input: 5\n2 1 5 1 3\n3\nOutput: 9</code></pre><p>Explanation: Subarray [2, 1, 5] has maximum sum = 8, subarray [1, 5, 1] = 7, [5, 1, 3] = 9</p><pre><code>Input: 4\n4 2 1 7\n2\nOutput: 8</code></pre><p><strong>Constraints:</strong></p><ul><li>1 ≤ nums.length ≤ 10<sup>5</sup></li><li>1 ≤ k ≤ nums.length</li><li>-10<sup>4</sup> ≤ nums[i] ≤ 10<sup>4</sup></li></ul><p><strong>Pro Tip:</strong> Use a sliding window of size k to update the sum efficiently in O(n) time.</p>',
    sampleTestCases: [
      {
        input: '5\n2 1 5 1 3\n3',
        expected: '9',
      },
      {
        input: '4\n4 2 1 7\n2',
        expected: '8',
      },
      {
        input: '3\n1 1 1\n1',
        expected: '1',
      },
    ],
    testCases: [
      {
        input: '6\n1 2 3 4 5 6\n2',
        expected: '11',
      },
      {
        input: '5\n-1 -2 -3 -4 -5\n2',
        expected: '-3',
      },
      {
        input: '3\n10 20 30\n3',
        expected: '60',
      },
      {
        input: '4\n5 5 5 5\n2',
        expected: '10',
      },
      {
        input: '5\n3 -1 4 -1 5\n3',
        expected: '8',
      },
      {
        input: '6\n0 -1 -2 3 4 5\n2',
        expected: '9',
      },
      {
        input: '2\n100 -50\n1',
        expected: '100',
      },
      {
        input: '4\n1 2 3 4\n4',
        expected: '10',
      },
      {
        input: '5\n-2 -1 0 1 2\n3',
        expected: '3',
      },
      {
        input: '7\n1 3 2 6 -1 4 1\n3',
        expected: '9',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re optimizing a marketing strategy by choosing the most impactful k-day window. Can you efficiently determine when performance peaked?',
    difficulty: 'easy',
    frequency: 82,
    tags: ['sliding window', 'array', 'greedy'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use a sliding window approach.',
      'Keep track of the sum of the current window of size k.',
      'Update the max when sliding forward by adding next and subtracting previous.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const k = parseInt(input[2]);\n  const res = maxSumSubarray(nums, k);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    k = int(input_lines[2])\n    print(maxSumSubarray(nums, k))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int k = Integer.parseInt(sc.nextLine());\n    System.out.println(maxSumSubarray(nums, k));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint maxSumSubarray(vector<int>& nums, int k);\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) cin >> nums[i];\n  int k; cin >> k;\n  cout << maxSumSubarray(nums, k) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function maxSumSubarray(nums, k) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def maxSumSubarray(nums, k):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int maxSumSubarray(int[] nums, int k) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'int maxSumSubarray(vector<int>& nums, int k) {\n    // write code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Maximum of All Subarrays of Size K',
    slug: 'maximum-of-all-subarrays-of-size-k',
    description: 'Find the maximum in every contiguous subarray of size k.',
    problemStatement:
      '<p>Given an array of integers <code>nums</code> and an integer <code>k</code>, find the maximum element in every contiguous subarray of size <code>k</code>.</p><p>Return an array of these maximums in the order they appear.</p><p><strong>Examples:</strong></p><pre><code>Input: 9\n1 3 -1 -3 5 3 6 7 2\n3\nOutput: 3 3 5 5 6 7 7</code></pre><p>Explanation: Maximums of each window: [1 3 -1]=3, [3 -1 -3]=3, [-1 -3 5]=5, [-3 5 3]=5, [5 3 6]=6, [3 6 7]=7, [6 7 2]=7</p><pre><code>Input: 5\n2 4 6 8 10\n2\nOutput: 4 6 8 10</code></pre><p><strong>Constraints:</strong></p><ul><li>1 ≤ nums.length ≤ 10<sup>5</sup></li><li>1 ≤ k ≤ nums.length</li><li>-10<sup>9</sup> ≤ nums[i] ≤ 10<sup>9</sup></li></ul><p><strong>Pro Tip:</strong> Use a deque to store indices and maintain a sliding window for an optimal O(n) solution.</p>',
    sampleTestCases: [
      {
        input: '9\n1 3 -1 -3 5 3 6 7 2\n3',
        expected: '3 3 5 5 6 7 7',
      },
      {
        input: '5\n2 4 6 8 10\n2',
        expected: '4 6 8 10',
      },
      {
        input: '4\n1 2 3 4\n1',
        expected: '1 2 3 4',
      },
    ],
    testCases: [
      {
        input: '3\n1 2 3\n2',
        expected: '2 3',
      },
      {
        input: '6\n10 9 8 7 6 5\n3',
        expected: '10 9 8 7',
      },
      {
        input: '5\n1 3 1 2 0\n3',
        expected: '3 3 2',
      },
      {
        input: '5\n4 3 5 4 3\n2',
        expected: '4 5 5 4',
      },
      {
        input: '5\n5 5 5 5 5\n2',
        expected: '5 5 5 5',
      },
      {
        input: '7\n1 3 1 2 0 5 6\n4',
        expected: '3 3 2 5',
      },
      {
        input: '6\n2 1 3 4 6 3\n3',
        expected: '3 4 6 6',
      },
      {
        input: '1\n10\n1',
        expected: '10',
      },
      {
        input: '4\n9 8 7 6\n2',
        expected: '9 8 7',
      },
      {
        input: '5\n3 -1 -3 -2 5\n3',
        expected: '3 -1 5',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re monitoring server usage in a moving time window. Can you detect the highest load in each window efficiently without reprocessing every element?',
    difficulty: 'medium',
    frequency: 88,
    tags: ['sliding window', 'deque', 'array', 'monotonic queue'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Use a deque to store indices of useful elements for each window.',
      'Remove elements from back if they are smaller than the current one.',
      'Remove elements from front if they go out of window range.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(k)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const k = parseInt(input[2]);\n  const res = maxInSubarrays(nums, k);\n  console.log(res.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    k = int(input_lines[2])\n    print(\" \".join(map(str, maxInSubarrays(nums, k))))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int k = Integer.parseInt(sc.nextLine());\n    List<Integer> res = maxInSubarrays(nums, k);\n    for (int num : res) System.out.print(num + " ");\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> maxInSubarrays(vector<int>& nums, int k);\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) cin >> nums[i];\n  int k; cin >> k;\n  vector<int> res = maxInSubarrays(nums, k);\n  for (int x : res) cout << x << " ";\n  cout << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function maxInSubarrays(nums, k) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def maxInSubarrays(nums, k):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static List<Integer> maxInSubarrays(int[] nums, int k) {\n    // write code here\n    return new ArrayList<>();\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> maxInSubarrays(vector<int>& nums, int k) {\n    // write code here\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Longest Substring with Exactly K Unique Characters',
    slug: 'longest-substring-with-exactly-k-unique-characters',
    description:
      'Find the length of the longest substring containing exactly k distinct characters.',
    problemStatement:
      '<p>Given a string <code>s</code> and an integer <code>k</code>, return the length of the longest substring of <code>s</code> that contains exactly <code>k</code> distinct characters. If no such substring exists, return <code>-1</code>.</p><p><strong>Examples:</strong></p><pre><code>Input: s = "aabacbebebe", k = 3\nOutput: 7</code></pre><p>Explanation: The longest substring with exactly 3 distinct characters is "cbebebe".</p><pre><code>Input: s = "aaaa", k = 2\nOutput: -1</code></pre><p>Explanation: Only one distinct character exists.</p><pre><code>Input: s = "aabaaab", k = 2\nOutput: 7</code></pre><p>Explanation: The entire string contains exactly 2 distinct characters.</p><p><strong>Constraints:</strong></p><ul><li>1 ≤ s.length ≤ 10<sup>5</sup></li><li>1 ≤ k ≤ 26 (assuming lowercase English letters)</li></ul><p><strong>Pro Tip:</strong> Use a sliding window with a frequency map. Expand the window until you exceed k unique characters, then shrink it until you\'re back to exactly k, updating the maximum length along the way.</p>',
    sampleTestCases: [
      {
        input: 's = "aabacbebebe", k = 3',
        expected: '7',
      },
      {
        input: 's = "aaaa", k = 2',
        expected: '-1',
      },
      {
        input: 's = "aabaaab", k = 2',
        expected: '7',
      },
    ],
    testCases: [
      {
        input: 's = "abcba", k = 2',
        expected: '3',
      },
      {
        input: 's = "eceba", k = 2',
        expected: '3',
      },
      {
        input: 's = "abc", k = 4',
        expected: '-1',
      },
      {
        input: 's = "aaabbcc", k = 2',
        expected: '5',
      },
      {
        input: 's = "123321", k = 2',
        expected: '4',
      },
      {
        input: 's = "abaccc", k = 2',
        expected: '4',
      },
      {
        input: 's = "a", k = 1',
        expected: '1',
      },
      {
        input: 's = "", k = 1',
        expected: '-1',
      },
      {
        input: 's = "abacaba", k = 3',
        expected: '7',
      },
      {
        input: 's = "abababab", k = 2',
        expected: '8',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Think of a text editor where you can highlight live a substring containing exactly k different characters—your task is to make that highlight as long as possible.',
    difficulty: 'medium',
    frequency: 80,
    tags: ['sliding window', 'string', 'hash map'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Maintain a count map of characters in the current window.',
      'Expand the window by adding characters on the right.',
      'If unique count exceeds k, shrink from the left until unique count ≤ k.',
      'Whenever unique count == k, update maximum window length.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(k)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = JSON.parse(fs.readFileSync(0, "utf-8"));\n  const { s, k } = input;\n  console.log(longestKUnique(s, k));\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == \"__main__\":\n    import sys, json\n    data = json.loads(sys.stdin.read())\n    print(longest_k_unique(data['s'], data['k']))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    // assume JSON input parsed to s and k\n    System.out.println(Solution.longestKUnique(s, k));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n  string s; int k;\n  // assume input parsed appropriately\n  cout << longestKUnique(s, k);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function longestKUnique(s, k) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def longest_k_unique(s, k):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int longestKUnique(String s, int k) {\n    // write code here\n    return -1;\n}',
      },
      {
        language: 'cpp',
        code: 'int longestKUnique(const string& s, int k) {\n    // write code here\n    return -1;\n}',
      },
    ],
  },
  {
    title: 'Longest Subarray of Sum K (Positive Integers)',
    slug: 'longest-subarray-of-sum-k-positive',
    description:
      'Find the length of the longest subarray with a given sum K, assuming all elements are positive.',
    problemStatement:
      '<p>Given an array of <strong>positive integers</strong> <code>nums</code> and an integer <code>k</code>, return the length of the longest contiguous subarray that adds up to <code>k</code>. If no such subarray exists, return <code>0</code>.</p><p><strong>Examples:</strong></p><pre><code>Input: 7\n1 2 1 1 1 1 1\n3\nOutput: 3</code></pre><p>Explanation: The subarray [1,1,1] has a sum of 3.</p><pre><code>Input: 5\n1 2 3 1 1\n4\nOutput: 2</code></pre><p><strong>Constraints:</strong></p><ul><li>1 ≤ nums.length ≤ 10<sup>5</sup></li><li>1 ≤ nums[i] ≤ 10<sup>4</sup></li><li>1 ≤ k ≤ 10<sup>9</sup></li></ul><p><strong>Pro Tip:</strong> Use the sliding window approach. Since all numbers are positive, you can shrink or expand the window based on the current sum to reach exactly <code>k</code>.</p>',
    sampleTestCases: [
      {
        input: '7\n1 2 1 1 1 1 1\n3',
        expected: '3',
      },
      {
        input: '5\n1 2 3 1 1\n4',
        expected: '2',
      },
      {
        input: '4\n1 1 1 1\n10',
        expected: '0',
      },
    ],
    testCases: [
      {
        input: '5\n1 1 1 1 1\n2',
        expected: '2',
      },
      {
        input: '6\n2 2 2 2 2 2\n6',
        expected: '3',
      },
      {
        input: '3\n3 1 2\n3',
        expected: '1',
      },
      {
        input: '3\n1 2 3\n6',
        expected: '3',
      },
      {
        input: '7\n1 2 1 3 1 1 1\n4',
        expected: '3',
      },
      {
        input: '5\n1 1 1 1 5\n5',
        expected: '1',
      },
      {
        input: '6\n1 2 3 4 1 2\n5',
        expected: '2',
      },
      {
        input: '8\n1 2 3 4 5 6 7 8\n15',
        expected: '5',
      },
      {
        input: '1\n5\n5',
        expected: '1',
      },
      {
        input: '3\n1 1 1\n3',
        expected: '3',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re building a fitness app that wants to find the longest continuous stretch of workouts totaling exactly k minutes. Can you do it efficiently when all sessions are positive?',
    difficulty: 'easy',
    frequency: 84,
    tags: ['sliding window', 'array', 'two pointer'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'PayPal', logoUrl: '' },
      { name: 'Flipkart', logoUrl: '' },
    ],
    hints: [
      'Use two pointers (start and end) to create a sliding window.',
      'If current sum < k, expand window to the right.',
      'If current sum > k, shrink window from the left.',
      'Track and update max length when current sum == k.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const k = parseInt(input[2]);\n  const res = longestSubarraySumK(nums, k);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    k = int(input_lines[2])\n    print(longest_subarray_sum_k(nums, k))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int k = Integer.parseInt(sc.nextLine());\n    System.out.println(longestSubarraySumK(nums, k));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint longestSubarraySumK(vector<int>& nums, int k);\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; ++i) cin >> nums[i];\n  int k; cin >> k;\n  cout << longestSubarraySumK(nums, k) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function longestSubarraySumK(nums, k) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def longest_subarray_sum_k(nums, k):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int longestSubarraySumK(int[] nums, int k) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'int longestSubarraySumK(vector<int>& nums, int k) {\n    // write code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Longest Subarray with Sum Zero',
    slug: 'longest-subarray-with-sum-zero',
    description:
      'Find the length of the longest contiguous subarray whose elements sum to zero.',
    problemStatement:
      '<p>Given an integer array <code>nums</code> (which may contain positive, negative, and zero values), find the length of the longest contiguous subarray whose sum is exactly zero.</p><p>If no such subarray exists, return <code>0</code>.</p><p><strong>Examples:</strong></p><pre><code>Input: nums = [15, -2, 2, -8, 1, 7, 10]\nOutput: 5</code></pre><p>Explanation: The longest zero-sum subarray is [-2, 2, -8, 1, 7].</p><pre><code>Input: nums = [1, 2, 3]\nOutput: 0</code></pre><p><strong>Constraints:</strong></p><ul><li>1 ≤ nums.length ≤ 10<sup>5</sup></li><li>-10<sup>6</sup> ≤ nums[i] ≤ 10<sup>6</sup></li></ul><p><strong>Pro Tip:</strong> Use prefix sums and a hash map to record the first occurrence of each sum—when a prefix sum reappears, the subarray in between sums to zero.</p>',
    sampleTestCases: [
      {
        input: 'nums = [15, -2, 2, -8, 1, 7, 10]',
        expected: '5',
      },
      {
        input: 'nums = [1, 2, 3]',
        expected: '0',
      },
      {
        input: 'nums = [1, 0, -1, 0, 1]',
        expected: '4',
      },
    ],
    testCases: [
      {
        input: 'nums = [4, -3, -6, 5, 1, 6, 8]',
        expected: '4',
      },
      {
        input: 'nums = [1, 0, 3]',
        expected: '1',
      },
      {
        input: 'nums = [-1, 1, -1, 1]',
        expected: '4',
      },
      {
        input: 'nums = [0, 0, 0, 0]',
        expected: '4',
      },
      {
        input: 'nums = [5, -5, 5, -5, 5]',
        expected: '4',
      },
      {
        input: 'nums = [2, -2, 2, -2, 2, -2]',
        expected: '6',
      },
      {
        input: 'nums = [3, 1, -4, 2, 2]',
        expected: '5',
      },
      {
        input: 'nums = [1, -1, 2, -2, 3, -3, 4]',
        expected: '6',
      },
      {
        input: 'nums = [1000000, -1000000]',
        expected: '2',
      },
      {
        input: 'nums = [7]',
        expected: '0',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Consider an expense tracker: you're looking for a period where income and expenditures cancel out completely. Can you efficiently identify the longest such streak in transaction history?",
    difficulty: 'medium',
    frequency: 78,
    tags: ['array', 'hash map', 'prefix sum'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Track cumulative prefix sums as you iterate.',
      'Store the earliest index each prefix sum appears.',
      'When you see a prefix sum again, the subarray between the previous index + 1 and current index sums to zero.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const nums = input[0].split(' ').map(Number);\n  const res = longestZeroSumSubarray(nums);\n  console.log(res);\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    nums = list(map(int, sys.stdin.read().strip().split()))\n    print(longest_zero_sum_subarray(nums))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    List<Integer> nums = new ArrayList<>();\n    while (sc.hasNextInt()) nums.add(sc.nextInt());\n    System.out.println(longestZeroSumSubarray(nums));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  vector<int> nums;\n  int x;\n  while (cin >> x) nums.push_back(x);\n  cout << longestZeroSumSubarray(nums) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function longestZeroSumSubarray(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def longest_zero_sum_subarray(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int longestZeroSumSubarray(List<Integer> nums) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'int longestZeroSumSubarray(const vector<int>& nums) {\n    // write code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Container With Most Water',
    slug: 'container-with-most-water',
    description:
      'Given an array of heights, find two vertical lines that, along with the x-axis, form the container that holds the most water.',
    problemStatement:
      '<p>You’re given an array <code>height</code> of non-negative integers. Each element represents the height of a vertical line at that position. Select two lines so that they, together with the x-axis, form a container holding the maximum possible amount of water.</p><p>Calculate the maximum area such a container can contain. Area is determined by the distance between the lines (width) multiplied by the height of the shorter line.</p><p><strong>Examples:</strong></p><pre><code>Input: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49</code></pre><p>Explanation: Lines at indices 1 (height 8) and 8 (height 7) form the widest possible base (width = 7), min height = 7, area = 49.</p><pre><code>Input: height = [1, 5, 4, 3]\nOutput: 6</code></pre><p><strong>Constraints:</strong></p><ul><li>2 ≤ height.length ≤ 10<sup>5</sup></li><li>0 ≤ height[i] ≤ 10<sup>4</sup></li></ul><p><strong>Pro Tip:</strong> Use the two-pointer approach. Start with pointers at both ends and move the one at the shorter line inward to potentially find a taller line and maximize area.</p>',
    sampleTestCases: [
      {
        input: 'height = [1,8,6,2,5,4,8,3,7]',
        expected: '49',
      },
      {
        input: 'height = [1,5,4,3]',
        expected: '6',
      },
      {
        input: 'height = [1,1]',
        expected: '1',
      },
    ],
    testCases: [
      {
        input: 'height = [2,3,10,5,7,8,9]',
        expected: '36', // indices 2 (10) and 6 (9), width=4, area=36
      },
      {
        input: 'height = [4,3,2,1,4]',
        expected: '16',
      },
      {
        input: 'height = [1,2,1]',
        expected: '2',
      },
      {
        input: 'height = [0,2,0]',
        expected: '0',
      },
      {
        input: 'height = [5,6,7,8,2,1,9]',
        expected: '35',
      },
      {
        input: 'height = [10000,1,10000]',
        expected: '20000',
      },
      {
        input: 'height = [3,9,4,8,2,6,1]',
        expected: '24',
      },
      {
        input: 'height = [1,2,3,4,5,6]',
        expected: '15',
      },
      {
        input: 'height = [6,5,4,3,2,1]',
        expected: '9',
      },
      {
        input: 'height = [5,5,5,5]',
        expected: '15',
      },
    ],
    topics: ['two-pointer', 'greedy', 'array'],
    interviewExcerpt:
      'Imagine you have vertical boards and need to build the largest water container using any two boards and the ground. Can you do it in linear time by cleverly choosing which boards to consider?',
    difficulty: 'medium',
    frequency: 90,
    tags: ['sliding window', 'two pointer', 'greedy', 'array'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Use two pointers at both ends to maximize width and area.',
      'Calculate area = min(height[left], height[right]) * (right - left).',
      'Move the pointer at the shorter height inward to find potential taller lines.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = JSON.parse(fs.readFileSync(0, "utf-8"));\n  const height = input;\n  console.log(maxArea(height));\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys, json\n    heights = json.loads(sys.stdin.read())\n    print(max_area(heights))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    // input parsing omitted\n    System.out.println(Solution.maxArea(height));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  vector<int> heights;\n  // input parsing omitted\n  cout << maxArea(heights) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function maxArea(height) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def max_area(height):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int maxArea(int[] height) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'int maxArea(const vector<int>& height) {\n    // write code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Pair with Target Sum in Sorted Array',
    slug: 'pair-with-target-sum-in-sorted-array',
    description:
      'Find a pair of numbers in a sorted array that sums to a given target, using constant extra space.',
    problemStatement:
      '<p>Given a 1‑based indexed sorted array <code>arr</code> of length <code>n</code> and an integer <code>target</code>, find two elements in the array such that their sum equals <code>target</code>. Return the indices (1‑based) of the two elements in ascending order. If no such pair exists, return <code>[-1, -1]</code>.</p><p><strong>Examples:</strong></p><pre><code>Input: arr = [2, 7, 11, 15], target = 9\nOutput: [1, 2]</code></pre><p>Explanation: arr[1] + arr[2] = 2 + 7 = 9.</p><pre><code>Input: arr = [1, 3, 4, 6, 8, 11], target = 10\nOutput: [3, 4]</code></pre><p>Explanation: arr[3] + arr[4] = 4 + 6 = 10.</p><p><strong>Constraints:</strong></p><ul><li>2 ≤ n ≤ 10⁵</li><li>−10⁹ ≤ arr[i], target ≤ 10⁹</li><li>Array is sorted in non-decreasing order</li></ul><p><strong>Pro Tip:</strong> Use the two-pointer technique for an efficient O(n) time and O(1) space solution—start pointers at both ends and adjust based on current sum.</p>',
    sampleTestCases: [
      {
        input: 'arr = [2,7,11,15], target = 9',
        expected: '[1, 2]',
      },
      {
        input: 'arr = [1,3,4,6,8,11], target = 10',
        expected: '[3, 4]',
      },
      {
        input: 'arr = [1,2,3,4], target = 8',
        expected: '[-1, -1]',
      },
    ],
    testCases: [
      {
        input: 'arr = [1,5,5,6,7], target = 10',
        expected: '[2, 3]',
      },
      {
        input: 'arr = [0,1,2,3,4], target = 5',
        expected: '[2, 5]',
      },
      {
        input: 'arr = [−3,−1,0,2,4,5], target = 1',
        expected: '[2, 4]',
      },
      {
        input: 'arr = [1,1,1,1], target = 2',
        expected: '[1, 2]',
      },
      {
        input: 'arr = [1,2,3], target = 7',
        expected: '[-1, -1]',
      },
      {
        input: 'arr = [10,20,30,40], target = 50',
        expected: '[1, 4]',
      },
      {
        input: 'arr = [5,5,5,5,5], target = 10',
        expected: '[1, 2]',
      },
      {
        input: 'arr = [2,3,4,5,9], target = 7',
        expected: '[2, 4]',
      },
      {
        input: 'arr = [−5,−4,−3,−2,−1], target = −8',
        expected: '[2, 5]',
      },
      {
        input: 'arr = [1,2], target = 3',
        expected: '[1, 2]',
      },
    ],
    topics: ['two-pointer', 'array', 'searching'],
    interviewExcerpt:
      'Given two sorted lists of numbers, can you identify a pair across them that sums to a specific value? Do it in one pass and constant space without extra data structures.',
    difficulty: 'easy',
    frequency: 80,
    tags: ['two pointer', 'array', 'greedy', 'sorted'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Bloomberg', logoUrl: '' },
    ],
    hints: [
      'Initialize pointers at both ends.',
      'If sum is too small, move left pointer right; if too large, move right pointer left.',
      'Stop when left ≥ right or when sum matches target.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'function twoSumSorted(arr, target) {\n  let left = 0, right = arr.length - 1;\n  while (left < right) {\n    const sum = arr[left] + arr[right];\n    if (sum === target) {\n      return [left + 1, right + 1]; // 1-based\n    } else if (sum < target) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n  return [-1, -1];\n}',
      },
      {
        language: 'python',
        code: 'def two_sum_sorted(arr, target):\n    left, right = 0, len(arr) - 1\n    while left < right:\n        s = arr[left] + arr[right]\n        if s == target:\n            return [left+1, right+1]\n        elif s < target:\n            left += 1\n        else:\n            right -= 1\n    return [-1, -1]',
      },
      {
        language: 'java',
        code: 'public int[] twoSumSorted(int[] arr, int target) {\n    int left = 0, right = arr.length - 1;\n    while (left < right) {\n        int sum = arr[left] + arr[right];\n        if (sum == target) return new int[]{left+1, right+1};\n        else if (sum < target) left++;\n        else right--;\n    }\n    return new int[]{-1, -1};\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> twoSumSorted(vector<int>& arr, int target) {\n    int left = 0, right = arr.size() - 1;\n    while (left < right) {\n        int s = arr[left] + arr[right];\n        if (s == target) return {left + 1, right + 1};\n        else if (s < target) left++;\n        else right--;\n    }\n    return {-1, -1};\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function twoSumSorted(arr, target) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def two_sum_sorted(arr, target):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int[] twoSumSorted(int[] arr, int target) {\n    // write code here\n    return new int[]{-1, -1};\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> twoSumSorted(vector<int>& arr, int target) {\n    // write code here\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Remove Duplicates from Sorted Array II',
    slug: 'remove-duplicates-from-sorted-array-ii',
    description:
      'Remove duplicates in-place from a sorted array so that each unique element appears at most twice.',
    problemStatement:
      '<p>Given a sorted array <code>nums</code>, remove some duplicates in‑place such that each unique element appears at most twice. Return the new length of the array, and ensure the first <code>k</code> elements contain the final result in sorted order.</p><p>Do not allocate extra space—modify the input array in-place with <code>O(1)</code> extra memory.</p><p><strong>Examples:</strong></p><pre><code>Input: nums = [1,1,1,2,2,3]\nOutput: 5\nExplanation: The first five elements become [1,1,2,2,3]. The extra [1] at the end is ignored.</code></pre><pre><code>Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7\nExplanation: After modification, the first seven elements are [0,0,1,1,2,3,3].</code></pre><p><strong>Constraints:</strong></p><ul><li><code>1 ≤ nums.length ≤ 10⁵</code></li><li>Sorted in non-decreasing order</li></ul><p><strong>Pro Tip:</strong> Use an index pointer to build the valid portion of the array and limit duplicates by comparing with the element two positions back.</p>',
    sampleTestCases: [
      {
        input: 'nums = [1,1,1,2,2,3]',
        expected: '5',
      },
      {
        input: 'nums = [0,0,1,1,1,1,2,3,3]',
        expected: '7',
      },
      {
        input: 'nums = [1,2,3]',
        expected: '3',
      },
    ],
    testCases: [
      {
        input: 'nums = [1,1,2,2,2,3]',
        expected: '5', // [1,1,2,2,3]
      },
      {
        input: 'nums = [1,1,1,1,1]',
        expected: '2',
      },
      {
        input: 'nums = [1,1,2,3,3,3,3,4,4]',
        expected: '7',
      },
      {
        input: 'nums = [0]',
        expected: '1',
      },
      {
        input: 'nums = [1,1]',
        expected: '2',
      },
      {
        input: 'nums = [1,2,2,3,3,3]',
        expected: '5',
      },
      {
        input: 'nums = [2,2,2,3,3,3,4,4,4,4]',
        expected: '6',
      },
      {
        input: 'nums = [-1,-1,-1,-1,0,0,1,1]',
        expected: '6',
      },
      {
        input: 'nums = [5,5,6,6,6,6,7]',
        expected: '5',
      },
      {
        input: 'nums = [1,1,2,2,3,3,3,3,3,4]',
        expected: '8',
      },
    ],
    topics: ['two-pointer', 'array', 'in-place'],
    interviewExcerpt:
      'Imagine you’re cleaning up a sorted dataset where no record should appear more than twice. Can you trim it in-place using only constant extra space?',
    difficulty: 'medium',
    frequency: 78,
    tags: ['two pointers', 'array', 'in-place', 'duplicates'],
    companies: [
      { name: 'LeetCode', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use a write index `i` to maintain the valid portion of the array.',
      "For each element, allow it if fewer than 2 have been kept, or it's not equal to the element at `i-2`.",
      'Only compare with the element two steps behind because no more than two duplicates are allowed.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'function removeDuplicates(nums) {\n  let i = 0;\n  for (const num of nums) {\n    if (i < 2 || num !== nums[i - 2]) {\n      nums[i++] = num;\n    }\n  }\n  return i;\n}',
      },
      {
        language: 'python',
        code: 'def removeDuplicates(nums):\n    i = 0\n    for num in nums:\n        if i < 2 or num != nums[i - 2]:\n            nums[i] = num\n            i += 1\n    return i',
      },
      {
        language: 'java',
        code: 'public int removeDuplicates(int[] nums) {\n    int i = 0;\n    for (int num : nums) {\n        if (i < 2 || num != nums[i - 2]) {\n            nums[i++] = num;\n        }\n    }\n    return i;\n}',
      },
      {
        language: 'cpp',
        code: 'int removeDuplicates(vector<int>& nums) {\n    int i = 0;\n    for (int num : nums) {\n        if (i < 2 || num != nums[i - 2]) {\n            nums[i++] = num;\n        }\n    }\n    return i;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function removeDuplicates(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def removeDuplicates(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public int removeDuplicates(int[] nums) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'int removeDuplicates(vector<int>& nums) {\n    // write code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Trapping Rain Water',
    slug: 'trapping-rain-water',
    description:
      'Given an elevation map (array of non-negative heights), compute how much water can be trapped after raining.',
    problemStatement:
      '<p>You are given an array <code>height</code> of <code>n</code> non-negative integers, where each element represents the elevation at that index. Compute how much rainwater can be trapped between these bars (width = 1 per bar) after raining.</p><p><strong>Examples:</strong></p><pre><code>Input: height = [3,0,1,0,4,0,2]\nOutput: 10</code></pre><p>Explanation: Water is trapped at indices 1, 2, 3, 5, totalling 10 units.</p><pre><code>Input: height = [4,2,0,3,2,5]\nOutput: 9</code></pre><p><strong>Constraints:</strong></p><ul><li><code>1 ≤ n ≤ 10<sup>5</sup></code></li><li><code>0 ≤ height[i] ≤ 10<sup>5</sup></code></li></ul><p><strong>Pro Tip:</strong> Use an optimal two-pointer technique—process from both ends inward while maintaining leftMax and rightMax for O(n) time and O(1) space.</p>',
    sampleTestCases: [
      {
        input: 'height = [3,0,1,0,4,0,2]',
        expected: '10',
      },
      {
        input: 'height = [4,2,0,3,2,5]',
        expected: '9',
      },
      {
        input: 'height = [1,2,3,4]',
        expected: '0',
      },
    ],
    testCases: [
      {
        input: 'height = [0,1,0,2,1,0,1,3,2,1,2,1]',
        expected: '6',
      },
      {
        input: 'height = [5,4,1,2]',
        expected: '1',
      },
      {
        input: 'height = [4,4,4,4]',
        expected: '0',
      },
      {
        input: 'height = [0,0,0,0]',
        expected: '0',
      },
      {
        input: 'height = [4,2,4]',
        expected: '2',
      },
      {
        input: 'height = [4,1,1,0,2,3]',
        expected: '8',
      },
      {
        input: 'height = [2,0,2]',
        expected: '2',
      },
      {
        input: 'height = [8,0,8]',
        expected: '8',
      },
      {
        input: 'height = [3,0,1,3,0,5]',
        expected: '8',
      },
      {
        input: 'height = [1]',
        expected: '0',
      },
    ],
    topics: ['two-pointer', 'sliding window', 'array'],
    interviewExcerpt:
      'Visualize the bars as walls holding water—can you efficiently calculate how much water is trapped using only constant extra space?',
    difficulty: 'hard',
    frequency: 85,
    tags: ['two pointer', 'array', 'prefix sums', 'greedy'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Maintain two pointers at both ends, and track leftMax and rightMax.',
      'Move the pointer with the lower max inward, and accumulate trapped water at each step as (current boundary) - (height at that index).',
      'This ensures all positions are processed in one pass without extra memory.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'function trap(height) {\n  let left = 0, right = height.length - 1;\n  let leftMax = 0, rightMax = 0;\n  let total = 0;\n  while (left < right) {\n    if (height[left] < height[right]) {\n      height[left] >= leftMax ? (leftMax = height[left]) : total += leftMax - height[left];\n      left++;\n    } else {\n      height[right] >= rightMax ? (rightMax = height[right]) : total += rightMax - height[right];\n      right--;\n    }\n  }\n  return total;\n}',
      },
      {
        language: 'python',
        code: 'def trap(height):\n    left, right = 0, len(height)-1\n    leftMax = rightMax = 0\n    total = 0\n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= leftMax:\n                leftMax = height[left]\n            else:\n                total += leftMax - height[left]\n            left += 1\n        else:\n            if height[right] >= rightMax:\n                rightMax = height[right]\n            else:\n                total += rightMax - height[right]\n            right -= 1\n    return total',
      },
      {
        language: 'java',
        code: 'public int trap(int[] height) {\n    int left = 0, right = height.length-1;\n    int leftMax = 0, rightMax = 0;\n    int total = 0;\n    while (left < right) {\n        if (height[left] < height[right]) {\n            if (height[left] >= leftMax) leftMax = height[left];\n            else total += leftMax - height[left];\n            left++;\n        } else {\n            if (height[right] >= rightMax) rightMax = height[right];\n            else total += rightMax - height[right];\n            right--;\n        }\n    }\n    return total;\n}',
      },
      {
        language: 'cpp',
        code: 'int trap(vector<int>& height) {\n    int left = 0, right = height.size()-1;\n    int leftMax = 0, rightMax = 0;\n    int total = 0;\n    while (left < right) {\n        if (height[left] < height[right]) {\n            leftMax = max(leftMax, height[left]);\n            total += leftMax - height[left];\n            left++;\n        } else {\n            rightMax = max(rightMax, height[right]);\n            total += rightMax - height[right];\n            right--;\n        }\n    }\n    return total;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function trap(height) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def trap(height):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public int trap(int[] height) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'int trap(const vector<int>& height) {\n    // write code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Find Minimum in Rotated Sorted Array',
    slug: 'find-minimum-in-rotated-sorted-array',
    description:
      'Find the minimum element in a rotated sorted array with distinct elements.',
    problemStatement:
      'You are given a rotated sorted array of distinct integers. A rotated array means the original array was sorted in ascending order and then some leading elements were moved to the end. Your task is to find the minimum element in the array.\n\nUse an efficient algorithm with better than linear time complexity.\n\nExamples:\n<pre><code>Input: [3,4,5,1,2]\nOutput: 1\nExplanation: The original sorted array [1,2,3,4,5] was rotated 3 times.\n\nInput: [11,13,15,17]\nOutput: 11\nExplanation: The array is already sorted and not rotated.\n\nInput: [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original sorted array [0,1,2,4,5,6,7] was rotated 4 times.</code></pre>\n\n<ul>\n<li>1 &lt;= nums.length &lt;= 5000</li>\n<li>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></li>\n<li>All the integers of nums are unique.</li>\n<li>nums is guaranteed to be a rotated sorted array.</li>\n</ul>\n\nPro Tip – Binary search can help optimize the search in a rotated structure. Think about how the midpoint value compares to the ends.',
    sampleTestCases: [
      {
        input: '5\n3 4 5 1 2',
        expected: '1',
      },
      {
        input: '4\n11 13 15 17',
        expected: '11',
      },
      {
        input: '7\n4 5 6 7 0 1 2',
        expected: '0',
      },
    ],
    testCases: [
      { input: '7\n4 5 6 7 0 1 2', expected: '0' },
      { input: '4\n11 13 15 17', expected: '11' },
      { input: '5\n3 4 5 1 2', expected: '1' },
      { input: '1\n10', expected: '10' },
      { input: '6\n2 3 4 5 6 1', expected: '1' },
      { input: '3\n2 3 1', expected: '1' },
      { input: '8\n7 8 1 2 3 4 5 6', expected: '1' },
      { input: '10\n6 7 8 9 10 1 2 3 4 5', expected: '1' },
      { input: '5\n5 1 2 3 4', expected: '1' },
      { input: '2\n2 1', expected: '1' },
      { input: '9\n3 4 5 6 7 8 9 10 1', expected: '1' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Hey! So imagine you have a list of unique numbers that was originally sorted, but someone rotated it. For example, [1,2,3,4,5] might become [4,5,1,2,3]. Now I want you to find the smallest number in that list. Can you figure out an efficient way to do it?',
    difficulty: 'medium',
    frequency: 82,
    tags: ['binary search', 'array'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Try to use binary search to find the pivot point.',
      'Compare the middle element with the rightmost to decide which half to search.',
      'Look for the inflection point where the order breaks.',
    ],
    optimalComplexity: {
      time: 'O(log n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const result = findMin(nums);\n  console.log(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    result = findMin(nums)\n    print(result)',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.nextLine());\n        int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n        System.out.println(findMin(nums));\n    }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n    int n; cin >> n;\n    vector<int> nums(n);\n    for (int i = 0; i < n; ++i) cin >> nums[i];\n    cout << findMin(nums) << endl;\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function findMin(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def findMin(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int findMin(int[] nums) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int findMin(vector<int>& nums) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Find Peak Element',
    slug: 'find-peak-element',
    description:
      'Find any peak element in an array where a peak is greater than its neighbors.',
    problemStatement:
      'Given an array of integers `nums`, find a peak element and return its index. A peak element is an element that is strictly greater than its neighbors. For corner elements, we consider only one neighbor.\n\nYou may assume that `nums[i] != nums[i+1]` for all valid `i`. Your solution should be logarithmic in time.\n\nExamples:\n<pre><code>Input: [1,2,3,1]\nOutput: 2\nExplanation: nums[2] = 3 is greater than nums[1] and nums[3].\n\nInput: [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: nums[5] = 6 is greater than nums[4] and nums[6]. Other valid answers include index 1 or 4.</code></pre>\n\n<ul>\n<li>1 &lt;= nums.length &lt;= 10<sup>5</sup></li>\n<li>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</li>\n<li>nums[i] != nums[i + 1]</li>\n</ul>\n\nPro Tip – You can use a modified binary search to narrow down the peak by comparing mid with mid+1.',
    sampleTestCases: [
      {
        input: '4\n1 2 3 1',
        expected: '2',
      },
      {
        input: '7\n1 2 1 3 5 6 4',
        expected: '5',
      },
      {
        input: '1\n10',
        expected: '0',
      },
    ],
    testCases: [
      { input: '4\n1 2 3 1', expected: '2' },
      { input: '7\n1 2 1 3 5 6 4', expected: '5' },
      { input: '1\n10', expected: '0' },
      { input: '2\n3 2', expected: '0' },
      { input: '2\n2 3', expected: '1' },
      { input: '5\n5 10 20 15 7', expected: '2' },
      { input: '3\n10 20 15', expected: '1' },
      { input: '6\n1 3 2 1 4 6', expected: '1' },
      { input: '3\n6 5 4', expected: '0' },
      { input: '3\n4 5 6', expected: '2' },
      { input: '6\n2 1 3 5 6 4', expected: '4' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Imagine an array of mountains and valleys—your job is to find any one of the peaks. A peak is taller than the ones next to it. Can you think of a way to use binary search to locate one of the peaks efficiently?',
    difficulty: 'medium',
    frequency: 87,
    tags: ['binary search', 'array'],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Bloomberg', logoUrl: '' },
    ],
    hints: [
      'Think in terms of binary search: compare mid with mid+1.',
      'If mid is less than mid+1, peak lies on the right; else on the left.',
      'Edge values are considered to have one neighbor.',
    ],
    optimalComplexity: {
      time: 'O(log n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const result = findPeakElement(nums);\n  console.log(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    result = findPeakElement(nums)\n    print(result)',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.nextLine());\n        int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n        System.out.println(findPeakElement(nums));\n    }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n    int n; cin >> n;\n    vector<int> nums(n);\n    for (int i = 0; i < n; ++i) cin >> nums[i];\n    cout << findPeakElement(nums) << endl;\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function findPeakElement(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def findPeakElement(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int findPeakElement(int[] nums) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int findPeakElement(vector<int>& nums) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'First and Last Position of Element',
    slug: 'first-and-last-position-of-element',
    description:
      'Given a sorted array, find the first and last position of a given target value.',
    problemStatement:
      'You are given an array of integers `nums` sorted in non-decreasing order, and an integer `target`. Your task is to find the starting and ending position of `target` in the array. If `target` is not present, return [-1, -1].\n\nYou must write an algorithm with O(log n) runtime complexity.\n\nExamples:\n<pre><code>Input: [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExplanation: The target 8 starts at index 3 and ends at index 4.\n\nInput: [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nExplanation: The target 6 is not found in the array.\n\nInput: [], target = 0\nOutput: [-1,-1]</code></pre>\n\n<ul>\n<li>0 &lt;= nums.length &lt;= 10<sup>5</sup></li>\n<li>-10<sup>9</sup> &lt;= nums[i], target &lt;= 10<sup>9</sup></li>\n<li>nums is a non-decreasing array</li>\n</ul>\n\nPro Tip – Use two modified binary searches: one to find the first occurrence and one for the last.',
    sampleTestCases: [
      {
        input: '6\n5 7 7 8 8 10\n8',
        expected: '3 4',
      },
      {
        input: '6\n5 7 7 8 8 10\n6',
        expected: '-1 -1',
      },
      {
        input: '0\n\n0',
        expected: '-1 -1',
      },
    ],
    testCases: [
      { input: '6\n5 7 7 8 8 10\n8', expected: '3 4' },
      { input: '6\n5 7 7 8 8 10\n6', expected: '-1 -1' },
      { input: '0\n\n0', expected: '-1 -1' },
      { input: '1\n1\n1', expected: '0 0' },
      { input: '1\n1\n0', expected: '-1 -1' },
      { input: '5\n2 2 2 2 2\n2', expected: '0 4' },
      { input: '8\n1 2 3 4 5 6 7 8\n5', expected: '4 4' },
      { input: '8\n1 1 2 3 3 3 4 5\n3', expected: '3 5' },
      { input: '5\n1 3 3 3 5\n3', expected: '1 3' },
      { input: '6\n1 2 3 4 5 6\n7', expected: '-1 -1' },
      { input: '3\n1 1 1\n1', expected: '0 2' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "So imagine you're working with sorted logs or data entries, and you want to find the start and end index of a particular entry. If it's not there, you just return -1 for both. How would you approach this with high efficiency?",
    difficulty: 'medium',
    frequency: 90,
    tags: ['binary search', 'array'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Use binary search twice to find the boundaries.',
      "Once you find the target, don't stop. Keep moving to edges.",
      'Consider edge cases with empty arrays or only one occurrence.',
    ],
    optimalComplexity: {
      time: 'O(log n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = n ? input[1].split(" ").map(Number) : [];\n  const target = parseInt(input[n ? 2 : 1]);\n  const result = searchRange(nums, target);\n  console.log(result.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split())) if n else []\n    target = int(input_lines[2 if n else 1])\n    result = searchRange(nums, target)\n    print(" ".join(map(str, result)))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.nextLine());\n        int[] nums = n > 0 ? Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray() : new int[0];\n        int target = Integer.parseInt(sc.nextLine());\n        int[] result = searchRange(nums, target);\n        System.out.println(result[0] + " " + result[1]);\n    }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n    int n; cin >> n;\n    vector<int> nums;\n    if (n > 0) {\n        nums.resize(n);\n        for (int i = 0; i < n; ++i) cin >> nums[i];\n    }\n    int target; cin >> target;\n    vector<int> result = searchRange(nums, target);\n    cout << result[0] << " " << result[1] << endl;\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function searchRange(nums, target) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def searchRange(nums, target):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int[] searchRange(int[] nums, int target) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> searchRange(vector<int>& nums, int target) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Kth Element of Two Sorted Arrays',
    slug: 'kth-element-of-two-sorted-arrays',
    description:
      'Find the k-th smallest element in the union of two sorted arrays.',
    problemStatement:
      'Given two sorted arrays `arr1` and `arr2` of sizes `n` and `m` respectively, and an integer `k`, find the k-th smallest element in the merged sorted array of both arrays. You must do this without actually merging the arrays.\n\n<pre><code>Input: arr1 = [2, 3, 6, 7, 9], arr2 = [1, 4, 8, 10], k = 5\nOutput: 6\nExplanation: Merged array = [1, 2, 3, 4, 6, 7, 8, 9, 10], 5th element is 6\n\nInput: arr1 = [1, 2], arr2 = [3, 4, 5, 6], k = 4\nOutput: 4\nExplanation: Merged array = [1, 2, 3, 4, 5, 6], 4th element is 4</code></pre>\n\n<ul>\n<li>1 ≤ n, m ≤ 10<sup>6</sup></li>\n<li>0 ≤ arr1[i], arr2[i] ≤ 10<sup>9</sup></li>\n<li>1 ≤ k ≤ n + m</li>\n<li>Both arrays are sorted in non-decreasing order</li>\n</ul>\n\nPro Tip – Think about how binary search can help you avoid merging both arrays completely. Use array partitioning tricks to narrow the search.',
    sampleTestCases: [
      {
        input: '5 4 5\n2 3 6 7 9\n1 4 8 10',
        expected: '6',
      },
      {
        input: '2 4 4\n1 2\n3 4 5 6',
        expected: '4',
      },
    ],
    testCases: [
      { input: '3 3 4\n1 3 5\n2 4 6', expected: '4' },
      { input: '4 5 7\n1 2 3 4\n5 6 7 8 9', expected: '7' },
      { input: '1 1 1\n5\n10', expected: '5' },
      { input: '1 1 2\n5\n10', expected: '10' },
      { input: '3 2 4\n2 3 4\n1 5', expected: '4' },
      { input: '6 5 9\n1 2 3 4 5 6\n7 8 9 10 11', expected: '9' },
      { input: '3 4 5\n2 3 5\n1 4 6 7', expected: '5' },
      { input: '3 3 2\n10 20 30\n5 15 25', expected: '10' },
      { input: '3 3 6\n1 3 5\n2 4 6', expected: '6' },
      { input: '2 3 3\n7 9\n1 4 10', expected: '7' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're working on a data fusion system at Google, where two live sorted data streams arrive, and you need to find the k-th smallest record between them in real-time without merging. How would you do it efficiently?",
    categories: ['array', 'binary search', 'merge'],
    difficulty: 'medium',
    frequency: 89,
    tags: ['binary search', 'array', 'two pointer', 'divide and conquer'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Use binary search on the smaller array.',
      'Think about how many elements you can take from each array so that their combined total is k.',
      'You do not need to merge the arrays—just simulate the merge process cleverly.',
    ],
    optimalComplexity: {
      time: 'O(log(min(n, m)))',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const [n, m, k] = input[0].split(' ').map(Number);\n  const arr1 = input[1].split(' ').map(Number);\n  const arr2 = input[2].split(' ').map(Number);\n  const result = findKthElement(arr1, arr2, k);\n  console.log(result);\n}\nmain();",
      },
      {
        language: 'python',
        code: 'def parse_input():\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n, m, k = map(int, input_lines[0].split())\n    arr1 = list(map(int, input_lines[1].split()))\n    arr2 = list(map(int, input_lines[2].split()))\n    return arr1, arr2, k\n\nif __name__ == "__main__":\n    arr1, arr2, k = parse_input()\n    print(find_kth_element(arr1, arr2, k))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        int[] arr1 = new int[n];\n        int[] arr2 = new int[m];\n        for (int i = 0; i < n; i++) arr1[i] = sc.nextInt();\n        for (int i = 0; i < m; i++) arr2[i] = sc.nextInt();\n        System.out.println(findKthElement(arr1, arr2, k));\n    }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<int> arr1(n), arr2(m);\n    for (int i = 0; i < n; i++) cin >> arr1[i];\n    for (int i = 0; i < m; i++) cin >> arr2[i];\n    cout << findKthElement(arr1, arr2, k) << endl;\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function findKthElement(arr1, arr2, k) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def find_kth_element(arr1, arr2, k):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int findKthElement(int[] arr1, int[] arr2, int k) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int findKthElement(vector<int>& arr1, vector<int>& arr2, int k) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Merge Intervals',
    slug: 'merge-intervals',
    description: 'Merge overlapping intervals from a list of intervals.',
    problemStatement:
      "You are given an array of intervals where each interval is a pair of integers [start, end], representing the start and end times of an interval. Your task is to merge all overlapping intervals and return the result as a list of non-overlapping intervals that cover all the intervals in the input.\n\n<pre><code>Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Intervals [1,3] and [2,6] overlap and are merged into [1,6].\n\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] touch and are merged into [1,5].</code></pre>\n\n<ul>\n<li>1 ≤ intervals.length ≤ 10<sup>4</sup></li>\n<li>intervals[i].length == 2</li>\n<li>0 ≤ intervals[i][0] ≤ intervals[i][1] ≤ 10<sup>4</sup></li>\n</ul>\n\nPro Tip – Sort intervals by their start time before merging. Then, iterate through the list and compare the current interval's start with the last merged interval's end.",
    sampleTestCases: [
      {
        input: '4\n1 3\n2 6\n8 10\n15 18',
        expected: '1 6\n8 10\n15 18',
      },
      {
        input: '2\n1 4\n4 5',
        expected: '1 5',
      },
    ],
    testCases: [
      { input: '3\n1 2\n3 4\n5 6', expected: '1 2\n3 4\n5 6' },
      { input: '3\n1 4\n2 5\n7 9', expected: '1 5\n7 9' },
      { input: '1\n2 3', expected: '2 3' },
      { input: '5\n1 3\n2 4\n5 7\n6 8\n9 10', expected: '1 4\n5 8\n9 10' },
      { input: '3\n1 10\n2 3\n4 5', expected: '1 10' },
      { input: '4\n1 5\n2 3\n4 6\n7 8', expected: '1 6\n7 8' },
      { input: '4\n1 4\n0 2\n3 5\n7 9', expected: '0 5\n7 9' },
      { input: '2\n0 0\n0 0', expected: '0 0' },
      { input: '3\n1 4\n0 2\n3 5', expected: '0 5' },
      { input: '3\n6 8\n1 9\n2 4', expected: '1 9' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're building a calendar tool at Amazon that automatically merges overlapping meeting slots. How would you design a function to combine overlapping time intervals?",
    categories: ['array', 'sorting'],
    difficulty: 'medium',
    frequency: 94,
    tags: ['sorting', 'interval', 'greedy'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Sort the intervals based on the starting time.',
      'Iterate through the sorted intervals and merge where overlap exists.',
      'Use a result list to store the merged intervals progressively.',
    ],
    optimalComplexity: {
      time: 'O(n log n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const intervals = [];\n  for (let i = 1; i <= n; i++) {\n    intervals.push(input[i].split(' ').map(Number));\n  }\n  const result = mergeIntervals(intervals);\n  for (let [s, e] of result) {\n    console.log(`${s} ${e}`);\n  }\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    intervals = [list(map(int, line.split())) for line in lines[1:]]\n    return intervals\n\nif __name__ == '__main__':\n    intervals = parse_input()\n    result = merge_intervals(intervals)\n    for interval in result:\n        print(f\"{interval[0]} {interval[1]}\")",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int[][] intervals = new int[n][2];\n    for (int i = 0; i < n; i++) {\n      intervals[i][0] = sc.nextInt();\n      intervals[i][1] = sc.nextInt();\n    }\n    List<int[]> result = mergeIntervals(intervals);\n    for (int[] interval : result) {\n      System.out.println(interval[0] + " " + interval[1]);\n    }\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  vector<vector<int>> intervals(n, vector<int>(2));\n  for (int i = 0; i < n; i++) {\n    cin >> intervals[i][0] >> intervals[i][1];\n  }\n  vector<vector<int>> result = mergeIntervals(intervals);\n  for (auto &interval : result) {\n    cout << interval[0] << " " << interval[1] << "\\n";\n  }\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function mergeIntervals(intervals) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def merge_intervals(intervals):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static List<int[]> mergeIntervals(int[][] intervals) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<vector<int>> mergeIntervals(vector<vector<int>>& intervals) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Insert Interval',
    slug: 'insert-interval',
    description:
      'Insert a new interval into a list of non-overlapping intervals and merge if necessary.',
    problemStatement:
      'You are given an array of non-overlapping intervals sorted by their start times and a new interval. Insert the new interval into the array, ensuring that the final list of intervals remains sorted and non-overlapping by merging where necessary.\n\n<pre><code>Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\nExplanation: The new interval [2,5] overlaps with [1,3], so they are merged into [1,5].\n\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Intervals [3,5],[6,7],[8,10] all overlap with [4,8] and are merged.</code></pre>\n\n<ul>\n<li>0 ≤ intervals.length ≤ 10<sup>4</sup></li>\n<li>intervals[i].length == 2</li>\n<li>0 ≤ intervals[i][0] ≤ intervals[i][1] ≤ 10<sup>4</sup></li>\n<li>newInterval.length == 2</li>\n<li>0 ≤ newInterval[0] ≤ newInterval[1] ≤ 10<sup>4</sup></li>\n</ul>\n\nPro Tip – Since the intervals are already sorted and non-overlapping, iterate once and insert the new interval at the right place, merging as you go.',
    sampleTestCases: [
      {
        input: '2\n1 3\n6 9\n2 5',
        expected: '1 5\n6 9',
      },
      {
        input: '5\n1 2\n3 5\n6 7\n8 10\n12 16\n4 8',
        expected: '1 2\n3 10\n12 16',
      },
    ],
    testCases: [
      { input: '0\n\n5 7', expected: '5 7' },
      { input: '1\n1 5\n2 3', expected: '1 5' },
      { input: '2\n1 3\n6 9\n2 5', expected: '1 5\n6 9' },
      { input: '3\n1 2\n3 5\n6 7\n4 6', expected: '1 2\n3 7' },
      { input: '2\n1 5\n6 8\n0 0', expected: '0 0\n1 5\n6 8' },
      { input: '3\n1 2\n3 5\n6 7\n0 0', expected: '0 0\n1 2\n3 5\n6 7' },
      { input: '2\n1 2\n3 5\n6 7', expected: '1 2\n3 5\n6 7' },
      {
        input: '4\n1 2\n3 5\n6 7\n9 10\n8 8',
        expected: '1 2\n3 5\n6 7\n8 8\n9 10',
      },
      { input: '2\n1 5\n10 12\n5 10', expected: '1 12' },
      { input: '2\n2 3\n5 7\n1 6', expected: '1 7' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'At Facebook, we use time blocks to schedule system maintenance. Imagine a list of scheduled time intervals and a new one just came in. Can you insert it and merge any overlaps efficiently?',
    categories: ['array', 'interval'],
    difficulty: 'medium',
    frequency: 87,
    tags: ['array', 'greedy', 'interval'],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Apple', logoUrl: '' },
    ],
    hints: [
      'Traverse through all intervals and keep those that come before the new interval.',
      'Merge all overlapping intervals with the new interval.',
      'Add remaining intervals after the merged new interval.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const intervals = [];\n  for (let i = 1; i <= n; i++) {\n    intervals.push(input[i].split(' ').map(Number));\n  }\n  const newInterval = input[n + 1].split(' ').map(Number);\n  const result = insertInterval(intervals, newInterval);\n  for (let [s, e] of result) {\n    console.log(`${s} ${e}`);\n  }\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    intervals = [list(map(int, line.split())) for line in lines[1:n+1]]\n    new_interval = list(map(int, lines[n+1].split()))\n    return intervals, new_interval\n\nif __name__ == '__main__':\n    intervals, new_interval = parse_input()\n    result = insert_interval(intervals, new_interval)\n    for i in result:\n        print(f\"{i[0]} {i[1]}\")",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[][] intervals = new int[n][2];\n    for (int i = 0; i < n; i++) {\n      String[] parts = sc.nextLine().split(" ");\n      intervals[i][0] = Integer.parseInt(parts[0]);\n      intervals[i][1] = Integer.parseInt(parts[1]);\n    }\n    String[] newParts = sc.nextLine().split(" ");\n    int[] newInterval = new int[]{Integer.parseInt(newParts[0]), Integer.parseInt(newParts[1])};\n    List<int[]> result = insertInterval(intervals, newInterval);\n    for (int[] interval : result) {\n      System.out.println(interval[0] + " " + interval[1]);\n    }\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  vector<vector<int>> intervals(n, vector<int>(2));\n  for (int i = 0; i < n; i++) {\n    cin >> intervals[i][0] >> intervals[i][1];\n  }\n  vector<int> newInterval(2);\n  cin >> newInterval[0] >> newInterval[1];\n  vector<vector<int>> result = insertInterval(intervals, newInterval);\n  for (auto &interval : result) {\n    cout << interval[0] << " " << interval[1] << "\\n";\n  }\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function insertInterval(intervals, newInterval) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def insert_interval(intervals, new_interval):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static List<int[]> insertInterval(int[][] intervals, int[] newInterval) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<vector<int>> insertInterval(vector<vector<int>>& intervals, vector<int>& newInterval) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Sort Colors (Dutch National Flag)',
    slug: 'sort-colors-dutch-national-flag',
    description:
      'Sort an array containing 0s, 1s, and 2s in-place using a single pass.',
    problemStatement:
      'You are given an array `nums` consisting only of integers 0, 1, and 2. Your task is to sort the array in-place so that all 0s come first, followed by all 1s, and then all 2s. You must solve this in one pass using constant space.\n\n<pre><code>Input: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\nExplanation: All 0s are moved to the front, 1s in the middle, and 2s at the end.\n\nInput: nums = [2,0,1]\nOutput: [0,1,2]</code></pre>\n\n<ul>\n<li>1 ≤ nums.length ≤ 10<sup>5</sup></li>\n<li>nums[i] is either 0, 1, or 2</li>\n</ul>\n\nPro Tip – Use three pointers (low, mid, high) to swap and position elements correctly in a single traversal.',
    sampleTestCases: [
      {
        input: '6\n2 0 2 1 1 0',
        expected: '0 0 1 1 2 2',
      },
      {
        input: '3\n2 0 1',
        expected: '0 1 2',
      },
    ],
    testCases: [
      { input: '6\n0 1 2 0 1 2', expected: '0 0 1 1 2 2' },
      { input: '3\n0 0 0', expected: '0 0 0' },
      { input: '3\n2 2 2', expected: '2 2 2' },
      { input: '3\n1 1 1', expected: '1 1 1' },
      { input: '4\n0 2 1 0', expected: '0 0 1 2' },
      { input: '5\n1 0 1 0 2', expected: '0 0 1 1 2' },
      { input: '7\n2 2 1 1 0 0 1', expected: '0 0 1 1 1 2 2' },
      { input: '1\n0', expected: '0' },
      { input: '2\n1 0', expected: '0 1' },
      { input: '5\n2 1 0 2 1', expected: '0 1 1 2 2' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re organizing colored balls (red=0, white=1, blue=2) into order for a UI animation system at Google. The requirement is to do it in-place and in a single scan. How would you approach this efficiently?',
    categories: ['array', 'sorting', 'in-place'],
    difficulty: 'medium',
    frequency: 92,
    tags: ['two pointer', 'sorting', 'array'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
      { name: 'Bloomberg', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Think of the problem as placing red, white, and blue balls in order.',
      'Use three pointers: one for 0, one for 2, and one traversing the array.',
      'Swap in-place based on values and update pointers accordingly.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const nums = input[1].split(' ').map(Number);\n  sortColors(nums);\n  console.log(nums.join(' '));\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    return nums\n\nif __name__ == '__main__':\n    nums = parse_input()\n    sort_colors(nums)\n    print(' '.join(map(str, nums)))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int[] nums = new int[n];\n    for (int i = 0; i < n; i++) nums[i] = sc.nextInt();\n    sortColors(nums);\n    for (int x : nums) System.out.print(x + " ");\n  }\n}',
      },
      {
        language: 'cpp',
        code: "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; i++) cin >> nums[i];\n  sortColors(nums);\n  for (int x : nums) cout << x << ' ';\n  return 0;\n}",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function sortColors(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def sort_colors(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static void sortColors(int[] nums) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'void sortColors(vector<int>& nums) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Find Missing Number (0 to n)',
    slug: 'find-missing-number-0-to-n',
    description:
      'Find the missing number from an array containing numbers from 0 to n with one number missing.',
    problemStatement:
      'You are given an array `nums` containing `n` distinct numbers taken from the range `[0, n]`. That means exactly one number from the range is missing. Your task is to return the missing number.\n\n<pre><code>Input: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, missing number is 2.\n\nInput: nums = [0,1]\nOutput: 2\nExplanation: n = 2, so numbers should be [0,1,2]. 2 is missing.</code></pre>\n\n<ul>\n<li>1 ≤ nums.length ≤ 10<sup>5</sup></li>\n<li>0 ≤ nums[i] ≤ n</li>\n<li>All the numbers in nums are unique and only one number is missing</li>\n</ul>\n\nPro Tip – Try computing the expected sum of numbers from 0 to n and subtract the sum of the input array to find the missing value.',
    sampleTestCases: [
      {
        input: '3\n3 0 1',
        expected: '2',
      },
      {
        input: '2\n0 1',
        expected: '2',
      },
    ],
    testCases: [
      { input: '1\n0', expected: '1' },
      { input: '3\n0 1 2', expected: '3' },
      { input: '3\n1 2 3', expected: '0' },
      { input: '4\n0 1 3 4', expected: '2' },
      { input: '5\n5 4 2 1 0', expected: '3' },
      { input: '6\n0 1 2 3 5 6', expected: '4' },
      { input: '2\n1 2', expected: '0' },
      { input: '5\n3 0 1 2 5', expected: '4' },
      { input: '10\n0 1 2 3 4 5 6 7 8 10', expected: '9' },
      { input: '7\n7 5 6 1 4 2 0', expected: '3' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re building a leaderboard system at Microsoft. Player IDs are assigned from 0 to n, but one ID seems to be missing. How would you efficiently find the missing ID?',
    categories: ['array', 'math', 'bit manipulation'],
    difficulty: 'easy',
    frequency: 90,
    tags: ['math', 'xor', 'array'],
    companies: [
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Apple', logoUrl: '' },
    ],
    hints: [
      'Calculate sum from 0 to n using the formula n*(n+1)/2.',
      'Subtract the sum of elements in the array from the total sum.',
      'Alternatively, use XOR from 0 to n and XOR with all elements in the array.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const nums = input[1].split(' ').map(Number);\n  const result = missingNumber(nums);\n  console.log(result);\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    nums = list(map(int, lines[1].split()))\n    return nums\n\nif __name__ == '__main__':\n    nums = parse_input()\n    print(missing_number(nums))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    String[] parts = sc.nextLine().split(" ");\n    int[] nums = new int[n];\n    for (int i = 0; i < n; i++) nums[i] = Integer.parseInt(parts[i]);\n    System.out.println(missingNumber(nums));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; i++) cin >> nums[i];\n  cout << missingNumber(nums) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function missingNumber(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def missing_number(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int missingNumber(int[] nums) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int missingNumber(vector<int>& nums) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Find All Duplicates in Array',
    slug: 'find-all-duplicates-in-array',
    description:
      'Identify all elements that appear exactly twice in an array where numbers range from 1 to n.',
    problemStatement:
      'You are given an integer array `nums` of length `n` where each number is between `1` and `n` (inclusive). Some elements appear twice and others appear once. Return an array of all elements that appear exactly twice. You must solve this problem in O(n) time and without using extra space.\n\n<pre><code>Input: nums = [4,3,2,7,8,2,3,1]\nOutput: [2,3]\nExplanation: 2 and 3 appear twice.\n\nInput: nums = [1,1,2]\nOutput: [1]</code></pre>\n\n<ul>\n<li>1 ≤ nums.length ≤ 10<sup>5</sup></li>\n<li>1 ≤ nums[i] ≤ nums.length</li>\n<li>Each element appears once or twice only</li>\n</ul>\n\nPro Tip – Use the sign of elements (positive/negative) at index positions to track which elements have been seen before.',
    sampleTestCases: [
      {
        input: '8\n4 3 2 7 8 2 3 1',
        expected: '2 3',
      },
      {
        input: '3\n1 1 2',
        expected: '1',
      },
    ],
    testCases: [
      { input: '3\n1 2 3', expected: '' },
      { input: '6\n1 2 3 1 2 3', expected: '1 2 3' },
      { input: '2\n2 2', expected: '2' },
      { input: '5\n4 3 2 1 1', expected: '1' },
      { input: '4\n1 1 1 1', expected: '1' },
      { input: '1\n1', expected: '' },
      { input: '7\n3 3 3 4 5 6 7', expected: '3' },
      { input: '8\n8 7 6 5 4 3 2 1', expected: '' },
      { input: '5\n2 4 3 5 3', expected: '3' },
      { input: '6\n5 4 3 2 1 2', expected: '2' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "At Amazon, you're analyzing customer feedback where IDs from 1 to n are logged. If a user submitted twice, how would you detect them efficiently without extra memory?",
    categories: ['array', 'in-place', 'duplicate'],
    difficulty: 'medium',
    frequency: 88,
    tags: ['array', 'in-place', 'cycle sort'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Traverse and mark visited elements using negation at indexed positions.',
      "If a number points to an already negative index, it's a duplicate.",
      "Don't use extra space; leverage the array itself.",
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const nums = input[1].split(' ').map(Number);\n  const result = findDuplicates(nums);\n  console.log(result.join(' '));\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    nums = list(map(int, input_lines[1].split()))\n    return nums\n\nif __name__ == '__main__':\n    nums = parse_input()\n    print(' '.join(map(str, find_duplicates(nums))))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    List<Integer> result = findDuplicates(nums);\n    for (int x : result) System.out.print(x + " ");\n  }\n}',
      },
      {
        language: 'cpp',
        code: "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; i++) cin >> nums[i];\n  vector<int> res = findDuplicates(nums);\n  for (int x : res) cout << x << ' ';\n  return 0;\n}",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function findDuplicates(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def find_duplicates(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static List<Integer> findDuplicates(int[] nums) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> findDuplicates(vector<int>& nums) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Majority Element (Boyer-Moore)',
    slug: 'majority-element-boyer-moore',
    description:
      'Find the element that appears more than ⌊n / 2⌋ times in the array using constant space.',
    problemStatement:
      'Given an array `nums` of size `n`, return the majority element — the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.\n\n<pre><code>Input: nums = [3,2,3]\nOutput: 3\n\nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2</code></pre>\n\n<ul>\n<li>1 ≤ nums.length ≤ 5 × 10<sup>4</sup></li>\n<li>-10<sup>9</sup> ≤ nums[i] ≤ 10<sup>9</sup></li>\n<li>The majority element always exists</li>\n</ul>\n\nPro Tip – Use the Boyer-Moore Voting Algorithm to find the majority in linear time and constant space.',
    sampleTestCases: [
      {
        input: '3\n3 2 3',
        expected: '3',
      },
      {
        input: '7\n2 2 1 1 1 2 2',
        expected: '2',
      },
    ],
    testCases: [
      { input: '1\n1', expected: '1' },
      { input: '5\n1 1 1 2 2', expected: '1' },
      { input: '6\n1 2 3 2 2 2', expected: '2' },
      { input: '5\n3 3 4 2 3', expected: '3' },
      { input: '7\n1 1 2 2 2 2 2', expected: '2' },
      { input: '5\n4 4 4 4 1', expected: '4' },
      { input: '6\n5 5 5 3 3 5', expected: '5' },
      { input: '7\n6 6 6 7 7 7 6', expected: '6' },
      { input: '4\n9 9 9 8', expected: '9' },
      { input: '3\n0 0 0', expected: '0' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re developing a polling system at Twitter. One candidate is guaranteed to have more than half the total votes. Can you identify this majority candidate efficiently in a single pass?',
    categories: ['array', 'counting'],
    difficulty: 'easy',
    frequency: 95,
    tags: ['boyer-moore', 'array', 'voting'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Twitter', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Boyer-Moore Voting Algorithm maintains a count that is incremented or decremented.',
      'Reset the candidate when count becomes 0.',
      'The final candidate will be the majority element.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const nums = input[1].split(' ').map(Number);\n  const result = majorityElement(nums);\n  console.log(result);\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    nums = list(map(int, lines[1].split()))\n    return nums\n\nif __name__ == '__main__':\n    nums = parse_input()\n    print(majority_element(nums))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    System.out.println(majorityElement(nums));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; i++) cin >> nums[i];\n  cout << majorityElement(nums) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function majorityElement(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def majority_element(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int majorityElement(int[] nums) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int majorityElement(vector<int>& nums) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Majority Element (Boyer-Moore)',
    slug: 'majority-element-boyer-moore',
    description:
      'Find the element that appears more than ⌊n / 2⌋ times in the array using constant space.',
    problemStatement:
      'Given an array `nums` of size `n`, return the majority element — the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.\n\n<pre><code>Input: nums = [3,2,3]\nOutput: 3\n\nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2</code></pre>\n\n<ul>\n<li>1 ≤ nums.length ≤ 5 × 10<sup>4</sup></li>\n<li>-10<sup>9</sup> ≤ nums[i] ≤ 10<sup>9</sup></li>\n<li>The majority element always exists</li>\n</ul>\n\nPro Tip – Use the Boyer-Moore Voting Algorithm to find the majority in linear time and constant space.',
    sampleTestCases: [
      {
        input: '3\n3 2 3',
        expected: '3',
      },
      {
        input: '7\n2 2 1 1 1 2 2',
        expected: '2',
      },
    ],
    testCases: [
      { input: '1\n1', expected: '1' },
      { input: '5\n1 1 1 2 2', expected: '1' },
      { input: '6\n1 2 3 2 2 2', expected: '2' },
      { input: '5\n3 3 4 2 3', expected: '3' },
      { input: '7\n1 1 2 2 2 2 2', expected: '2' },
      { input: '5\n4 4 4 4 1', expected: '4' },
      { input: '6\n5 5 5 3 3 5', expected: '5' },
      { input: '7\n6 6 6 7 7 7 6', expected: '6' },
      { input: '4\n9 9 9 8', expected: '9' },
      { input: '3\n0 0 0', expected: '0' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re developing a polling system at Twitter. One candidate is guaranteed to have more than half the total votes. Can you identify this majority candidate efficiently in a single pass?',
    categories: ['array', 'counting'],
    difficulty: 'easy',
    frequency: 95,
    tags: ['boyer-moore', 'array', 'voting'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Twitter', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Boyer-Moore Voting Algorithm maintains a count that is incremented or decremented.',
      'Reset the candidate when count becomes 0.',
      'The final candidate will be the majority element.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const nums = input[1].split(' ').map(Number);\n  const result = majorityElement(nums);\n  console.log(result);\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    nums = list(map(int, lines[1].split()))\n    return nums\n\nif __name__ == '__main__':\n    nums = parse_input()\n    print(majority_element(nums))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    System.out.println(majorityElement(nums));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; i++) cin >> nums[i];\n  cout << majorityElement(nums) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function majorityElement(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def majority_element(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int majorityElement(int[] nums) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int majorityElement(vector<int>& nums) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Count Inversions',
    slug: 'count-inversions',
    description:
      'Count the number of inversion pairs in an array where a larger element appears before a smaller one.',
    problemStatement:
      'Given an array `nums`, an inversion is a pair `(i, j)` such that `i < j` and `nums[i] > nums[j]`. Your task is to count the total number of inversions in the array.\n\n<pre><code>Input: nums = [2, 4, 1, 3, 5]\nOutput: 3\nExplanation: Inversion pairs are (2,1), (4,1), (4,3).\n\nInput: nums = [5, 4, 3, 2, 1]\nOutput: 10\nExplanation: All pairs are inversions.</code></pre>\n\n<ul>\n<li>1 ≤ nums.length ≤ 10<sup>5</sup></li>\n<li>-10<sup>9</sup> ≤ nums[i] ≤ 10<sup>9</sup></li>\n</ul>\n\nPro Tip – Use a modified merge sort algorithm to count inversions efficiently in O(n log n) time.',
    sampleTestCases: [
      {
        input: '5\n2 4 1 3 5',
        expected: '3',
      },
      {
        input: '5\n5 4 3 2 1',
        expected: '10',
      },
    ],
    testCases: [
      { input: '5\n1 2 3 4 5', expected: '0' },
      { input: '4\n1 3 2 4', expected: '1' },
      { input: '6\n6 5 4 3 2 1', expected: '15' },
      { input: '6\n1 3 5 2 4 6', expected: '3' },
      { input: '3\n1 1 1', expected: '0' },
      { input: '5\n5 1 2 3 4', expected: '4' },
      { input: '7\n1 5 3 2 6 4 7', expected: '5' },
      { input: '1\n100', expected: '0' },
      { input: '2\n1 0', expected: '1' },
      { input: '4\n4 3 2 1', expected: '6' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You’re debugging a performance regression at Apple and need to analyze how 'unsorted' a dataset is. Count the number of inversions to quantify it efficiently.",
    categories: ['array', 'sorting', 'divide and conquer'],
    difficulty: 'hard',
    frequency: 77,
    tags: ['merge sort', 'divide and conquer', 'array'],
    companies: [
      { name: 'Apple', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use a modified merge sort to count how many elements are skipped while merging.',
      'Count inversions during the merge phase, not the divide phase.',
      'Brute-force methods will not scale well for n = 10^5.',
    ],
    optimalComplexity: {
      time: 'O(n log n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const nums = input[1].split(' ').map(Number);\n  const result = countInversions(nums);\n  console.log(result);\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    nums = list(map(int, lines[1].split()))\n    return nums\n\nif __name__ == '__main__':\n    nums = parse_input()\n    print(count_inversions(nums))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    System.out.println(countInversions(nums));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; i++) cin >> nums[i];\n  cout << countInversions(nums) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function countInversions(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def count_inversions(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int countInversions(int[] nums) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int countInversions(vector<int>& nums) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Count Inversions',
    slug: 'count-inversions',
    description:
      'Count the number of inversion pairs in an array where a larger element appears before a smaller one.',
    problemStatement:
      'Given an array `nums`, an inversion is a pair `(i, j)` such that `i < j` and `nums[i] > nums[j]`. Your task is to count the total number of inversions in the array.\n\n<pre><code>Input: nums = [2, 4, 1, 3, 5]\nOutput: 3\nExplanation: Inversion pairs are (2,1), (4,1), (4,3).\n\nInput: nums = [5, 4, 3, 2, 1]\nOutput: 10\nExplanation: All pairs are inversions.</code></pre>\n\n<ul>\n<li>1 ≤ nums.length ≤ 10<sup>5</sup></li>\n<li>-10<sup>9</sup> ≤ nums[i] ≤ 10<sup>9</sup></li>\n</ul>\n\nPro Tip – Use a modified merge sort algorithm to count inversions efficiently in O(n log n) time.',
    sampleTestCases: [
      {
        input: '5\n2 4 1 3 5',
        expected: '3',
      },
      {
        input: '5\n5 4 3 2 1',
        expected: '10',
      },
    ],
    testCases: [
      { input: '5\n1 2 3 4 5', expected: '0' },
      { input: '4\n1 3 2 4', expected: '1' },
      { input: '6\n6 5 4 3 2 1', expected: '15' },
      { input: '6\n1 3 5 2 4 6', expected: '3' },
      { input: '3\n1 1 1', expected: '0' },
      { input: '5\n5 1 2 3 4', expected: '4' },
      { input: '7\n1 5 3 2 6 4 7', expected: '5' },
      { input: '1\n100', expected: '0' },
      { input: '2\n1 0', expected: '1' },
      { input: '4\n4 3 2 1', expected: '6' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You’re debugging a performance regression at Apple and need to analyze how 'unsorted' a dataset is. Count the number of inversions to quantify it efficiently.",
    categories: ['array', 'sorting', 'divide and conquer'],
    difficulty: 'hard',
    frequency: 77,
    tags: ['merge sort', 'divide and conquer', 'array'],
    companies: [
      { name: 'Apple', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use a modified merge sort to count how many elements are skipped while merging.',
      'Count inversions during the merge phase, not the divide phase.',
      'Brute-force methods will not scale well for n = 10^5.',
    ],
    optimalComplexity: {
      time: 'O(n log n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const nums = input[1].split(' ').map(Number);\n  const result = countInversions(nums);\n  console.log(result);\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    nums = list(map(int, lines[1].split()))\n    return nums\n\nif __name__ == '__main__':\n    nums = parse_input()\n    print(count_inversions(nums))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    System.out.println(countInversions(nums));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; i++) cin >> nums[i];\n  cout << countInversions(nums) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function countInversions(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def count_inversions(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int countInversions(int[] nums) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int countInversions(vector<int>& nums) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Count Subarrays with Given XOR',
    slug: 'count-subarrays-with-given-xor',
    description:
      'Count the number of subarrays whose XOR equals a given value.',
    problemStatement:
      'You are given an array `nums` and an integer `k`. Your task is to count the number of subarrays whose XOR is equal to `k`.\n\n<pre><code>Input: nums = [4, 2, 2, 6, 4], k = 6\nOutput: 4\nExplanation: The subarrays are [4,2], [2,2,6], [6], and [4,2,2,6].\n\nInput: nums = [5, 6, 7, 8, 9], k = 5\nOutput: 2\nExplanation: The subarrays are [5] and [6,7,8,9].</code></pre>\n\n<ul>\n<li>1 ≤ nums.length ≤ 10<sup>5</sup></li>\n<li>0 ≤ nums[i] ≤ 10<sup>9</sup></li>\n<li>0 ≤ k ≤ 10<sup>9</sup></li>\n</ul>\n\nPro Tip – Use prefix XOR and a hash map to count the frequency of needed prefixes to achieve XOR equal to k.',
    sampleTestCases: [
      {
        input: '5\n4 2 2 6 4\n6',
        expected: '4',
      },
      {
        input: '5\n5 6 7 8 9\n5',
        expected: '2',
      },
    ],
    testCases: [
      { input: '4\n1 2 3 4\n4', expected: '2' },
      { input: '3\n1 1 1\n0', expected: '1' },
      { input: '5\n0 0 0 0 0\n0', expected: '15' },
      { input: '6\n3 6 8 10 15 50\n5', expected: '0' },
      { input: '1\n10\n10', expected: '1' },
      { input: '2\n1 2\n3', expected: '1' },
      { input: '3\n2 2 2\n2', expected: '4' },
      { input: '5\n1 2 3 4 5\n1', expected: '2' },
      { input: '6\n4 2 2 6 4 2\n6', expected: '6' },
      { input: '5\n8 1 2 12 7\n7', expected: '2' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'At Google, you’re working on detecting signal patterns in data streams. Can you efficiently find the number of subarrays that XOR to a given signature?',
    categories: ['array', 'prefix xor', 'hash map'],
    difficulty: 'medium',
    frequency: 89,
    tags: ['prefix xor', 'hash map', 'array'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Use prefix XOR to maintain the XOR from the beginning to current index.',
      'If `prefix XOR ^ k` has appeared before, you found valid subarrays.',
      'Store the frequency of all prefix XORs in a hash map.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const nums = input[1].split(' ').map(Number);\n  const k = parseInt(input[2]);\n  const result = countSubarraysWithXOR(nums, k);\n  console.log(result);\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    nums = list(map(int, lines[1].split()))\n    k = int(lines[2])\n    return nums, k\n\nif __name__ == '__main__':\n    nums, k = parse_input()\n    print(count_subarrays_with_xor(nums, k))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int k = Integer.parseInt(sc.nextLine());\n    System.out.println(countSubarraysWithXOR(nums, k));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\nint main() {\n  int n, k;\n  cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; i++) cin >> nums[i];\n  cin >> k;\n  cout << countSubarraysWithXOR(nums, k) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function countSubarraysWithXOR(nums, k) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def count_subarrays_with_xor(nums, k):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int countSubarraysWithXOR(int[] nums, int k) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int countSubarraysWithXOR(vector<int>& nums, int k) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Count Smaller Elements After Self',
    slug: 'count-smaller-elements-after-self',
    description:
      'Count the number of smaller elements to the right of each element in an array.',
    problemStatement:
      'You are given an integer array `nums`. For each element `nums[i]`, count the number of smaller elements to its right and return the result as an array.\n\n<pre><code>Input: nums = [5,2,6,1]\nOutput: [2,1,1,0]\nExplanation: \n- 5 has two smaller elements after it: 2 and 1\n- 2 has one smaller element after it: 1\n- 6 has one smaller element after it: 1\n- 1 has no smaller elements after it</code></pre>\n\n<ul>\n<li>1 ≤ nums.length ≤ 10<sup>5</sup></li>\n<li>-10<sup>4</sup> ≤ nums[i] ≤ 10<sup>4</sup></li>\n</ul>\n\nPro Tip – Use a modified merge sort or Binary Indexed Tree (Fenwick Tree) to solve this efficiently.',
    sampleTestCases: [
      {
        input: '4\n5 2 6 1',
        expected: '2 1 1 0',
      },
      {
        input: '5\n1 2 7 8 5',
        expected: '0 0 1 1 0',
      },
    ],
    testCases: [
      { input: '4\n5 2 6 1', expected: '2 1 1 0' },
      { input: '3\n1 1 1', expected: '0 0 0' },
      { input: '3\n3 2 1', expected: '2 1 0' },
      { input: '5\n1 2 3 4 5', expected: '0 0 0 0 0' },
      { input: '6\n7 5 6 3 4 1', expected: '5 3 3 1 1 0' },
      { input: '1\n9', expected: '0' },
      { input: '4\n10 9 8 7', expected: '3 2 1 0' },
      { input: '5\n1 9 5 3 6', expected: '0 3 2 0 0' },
      { input: '5\n5 4 3 2 1', expected: '4 3 2 1 0' },
      { input: '3\n1 3 2', expected: '0 1 0' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "At Bloomberg, you're optimizing a real-time ranking system. Given a list of incoming values, how would you efficiently count how many lower-ranked values follow each one?",
    categories: ['array', 'divide and conquer', 'binary indexed tree'],
    difficulty: 'hard',
    frequency: 85,
    tags: ['merge sort', 'fenwick tree', 'binary search', 'segment tree'],
    companies: [
      { name: 'Bloomberg', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Try modifying merge sort to keep track of element counts while merging.',
      'A Binary Indexed Tree or Segment Tree can help maintain counts efficiently.',
      'Consider processing the elements from right to left.',
    ],
    optimalComplexity: {
      time: 'O(n log n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const nums = input[1].split(' ').map(Number);\n  const result = countSmaller(nums);\n  console.log(result.join(' '));\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    nums = list(map(int, lines[1].split()))\n    return nums\n\nif __name__ == '__main__':\n    nums = parse_input()\n    print(' '.join(map(str, count_smaller(nums))))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    List<Integer> result = countSmaller(nums);\n    for (int x : result) System.out.print(x + " ");\n  }\n}',
      },
      {
        language: 'cpp',
        code: "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; i++) cin >> nums[i];\n  vector<int> result = countSmaller(nums);\n  for (int x : result) cout << x << ' ';\n  return 0;\n}",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function countSmaller(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def count_smaller(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static List<Integer> countSmaller(int[] nums) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> countSmaller(vector<int>& nums) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Find the Duplicate Number',
    slug: 'find-the-duplicate-number',
    description:
      'Find the only duplicate number in an array containing n+1 integers from 1 to n.',
    problemStatement:
      'You are given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive. There is only one repeated number in `nums`, but it could be repeated more than once. Your task is to find and return that duplicate number. You must solve this problem without modifying the array and using constant extra space.\n\n<pre><code>Input: nums = [1,3,4,2,2]\nOutput: 2\n\nInput: nums = [3,1,3,4,2]\nOutput: 3</code></pre>\n\n<ul>\n<li>2 ≤ nums.length ≤ 10<sup>5</sup></li>\n<li>1 ≤ nums[i] ≤ n (where n = nums.length - 1)</li>\n<li>Only one number is repeated in the array</li>\n<li>You must not modify the array (read-only)</li>\n<li>Use constant extra space</li>\n</ul>\n\nPro Tip – Use Floyd’s Tortoise and Hare (Cycle Detection) algorithm to detect the duplicate efficiently in linear time.',
    sampleTestCases: [
      {
        input: '5\n1 3 4 2 2',
        expected: '2',
      },
      {
        input: '5\n3 1 3 4 2',
        expected: '3',
      },
    ],
    testCases: [
      { input: '5\n1 3 4 2 2', expected: '2' },
      { input: '5\n3 1 3 4 2', expected: '3' },
      { input: '6\n1 4 6 5 3 2', expected: '1' },
      { input: '7\n7 6 5 4 3 2 2', expected: '2' },
      { input: '6\n6 5 4 3 2 1', expected: '6' },
      { input: '4\n2 2 2 2', expected: '2' },
      { input: '3\n1 1 2', expected: '1' },
      { input: '4\n1 3 4 2 2', expected: '2' },
      { input: '5\n2 5 1 1 4', expected: '1' },
      { input: '5\n5 1 2 3 5', expected: '5' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "At Meta, you're debugging a user ID system where one ID was issued more than once. You can't change the data or use extra memory — how would you find the duplicate?",
    categories: ['array', 'cycle detection'],
    difficulty: 'medium',
    frequency: 98,
    tags: ['cycle detection', "floyd's", 'array', 'binary search'],
    companies: [
      { name: 'Meta', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Floyd’s Tortoise and Hare algorithm works because of the cyclic nature of the index-value relationship.',
      'Treat array as a linked list and find the cycle entry point.',
      "Don't sort or modify the input.",
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const nums = input[1].split(' ').map(Number);\n  const result = findDuplicate(nums);\n  console.log(result);\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    nums = list(map(int, lines[1].split()))\n    return nums\n\nif __name__ == '__main__':\n    nums = parse_input()\n    print(find_duplicate(nums))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    System.out.println(findDuplicate(nums));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; i++) cin >> nums[i];\n  cout << findDuplicate(nums) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function findDuplicate(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def find_duplicate(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int findDuplicate(int[] nums) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int findDuplicate(vector<int>& nums) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Longest Consecutive Sequence',
    slug: 'longest-consecutive-sequence',
    description:
      'Find the length of the longest consecutive elements sequence in an unsorted array.',
    problemStatement:
      'Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.\n\n<pre><code>Input: nums = [100, 4, 200, 1, 3, 2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore, its length is 4.\n\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9</code></pre>\n\n<ul>\n<li>0 ≤ nums.length ≤ 10<sup>5</sup></li>\n<li>-10<sup>9</sup> ≤ nums[i] ≤ 10<sup>9</sup></li>\n</ul>\n\nPro Tip – Use a HashSet to keep track of elements and only start counting when the current number is the beginning of a sequence.',
    sampleTestCases: [
      {
        input: '6\n100 4 200 1 3 2',
        expected: '4',
      },
      {
        input: '10\n0 3 7 2 5 8 4 6 0 1',
        expected: '9',
      },
    ],
    testCases: [
      { input: '0\n', expected: '0' },
      { input: '1\n1', expected: '1' },
      { input: '5\n1 2 0 1 3', expected: '4' },
      { input: '5\n10 5 6 7 11', expected: '4' },
      { input: '5\n1 3 5 2 4', expected: '5' },
      { input: '6\n100 99 98 4 3 2', expected: '3' },
      { input: '4\n1 3 5 7', expected: '1' },
      { input: '8\n10 20 30 1 2 3 4 5', expected: '5' },
      { input: '9\n1 9 3 10 4 20 2 8 6', expected: '6' },
      { input: '7\n5 6 3 1 2 4 7', expected: '7' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re building a streak tracking system at Netflix. Given a set of login days, how would you compute the user’s longest consecutive login streak efficiently?',
    categories: ['hashing', 'array'],
    difficulty: 'medium',
    frequency: 93,
    tags: ['hashing', 'set', 'array'],
    companies: [
      { name: 'Netflix', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Apple', logoUrl: '' },
    ],
    hints: [
      'Put all elements into a HashSet for O(1) lookups.',
      'Only start counting from numbers that are the beginning of a sequence.',
      'Keep track of the max length as you go.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const nums = n === 0 ? [] : input[1].split(' ').map(Number);\n  const result = longestConsecutive(nums);\n  console.log(result);\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    nums = list(map(int, lines[1].split())) if n > 0 else []\n    return nums\n\nif __name__ == '__main__':\n    nums = parse_input()\n    print(longest_consecutive(nums))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = n == 0 ? new int[0] : Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    System.out.println(longestConsecutive(nums));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; i++) cin >> nums[i];\n  cout << longestConsecutive(nums) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function longestConsecutive(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def longest_consecutive(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int longestConsecutive(int[] nums) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int longestConsecutive(vector<int>& nums) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Subarray Sum Equals K',
    slug: 'subarray-sum-equals-k',
    description:
      'Find the number of continuous subarrays whose sum equals to k.',
    problemStatement:
      'Given an integer array `nums` and an integer `k`, return the total number of continuous subarrays whose sum equals to `k`.\n\n<pre><code>Input: nums = [1,1,1], k = 2\nOutput: 2\nExplanation: The subarrays [1,1] at index (0,1) and (1,2) both sum to 2.\n\nInput: nums = [1,2,3], k = 3\nOutput: 2</code></pre>\n\n<ul>\n<li>1 ≤ nums.length ≤ 2 × 10<sup>4</sup></li>\n<li>-1000 ≤ nums[i] ≤ 1000</li>\n<li>-10<sup>7</sup> ≤ k ≤ 10<sup>7</sup></li>\n</ul>\n\nPro Tip – Use prefix sum and a hash map to store prefix sum frequencies. This allows you to check in constant time how many times a prefix sum of `sum - k` has occurred.',
    sampleTestCases: [
      {
        input: '3\n1 1 1\n2',
        expected: '2',
      },
      {
        input: '3\n1 2 3\n3',
        expected: '2',
      },
    ],
    testCases: [
      { input: '5\n1 2 3 4 5\n9', expected: '2' },
      { input: '6\n3 4 7 2 -3 1\n7', expected: '4' },
      { input: '5\n1 -1 0 1 1\n1', expected: '6' },
      { input: '3\n1 1 1\n1', expected: '3' },
      { input: '1\n100\n100', expected: '1' },
      { input: '5\n-1 -1 1 1 1\n0', expected: '4' },
      { input: '4\n1 2 1 2\n3', expected: '3' },
      { input: '2\n1 2\n4', expected: '0' },
      { input: '4\n0 0 0 0\n0', expected: '10' },
      { input: '6\n1 -1 1 -1 1 -1\n0', expected: '9' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "At Amazon, you're designing a revenue tracker. Given a stream of daily profits, how many consecutive day intervals add up to a specific profit goal?",
    categories: ['array', 'prefix sum', 'hash map'],
    difficulty: 'medium',
    frequency: 95,
    tags: ['prefix sum', 'hash map', 'array'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Use a hash map to keep track of how many times each prefix sum occurs.',
      "If sum - k exists in the map, it means there's a subarray summing to k.",
      'Be sure to initialize the prefix sum frequency map with {0: 1}.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const nums = input[1].split(' ').map(Number);\n  const k = parseInt(input[2]);\n  const result = subarraySum(nums, k);\n  console.log(result);\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    nums = list(map(int, lines[1].split()))\n    k = int(lines[2])\n    return nums, k\n\nif __name__ == '__main__':\n    nums, k = parse_input()\n    print(subarray_sum(nums, k))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int k = Integer.parseInt(sc.nextLine());\n    System.out.println(subarraySum(nums, k));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\nint main() {\n  int n, k;\n  cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; i++) cin >> nums[i];\n  cin >> k;\n  cout << subarraySum(nums, k) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function subarraySum(nums, k) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def subarray_sum(nums, k):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int subarraySum(int[] nums, int k) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int subarraySum(vector<int>& nums, int k) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Group Anagrams (via arrays of char freq)',
    slug: 'group-anagrams-via-arrays-of-char-freq',
    description:
      'Group words that are anagrams of each other using character frequency arrays.',
    problemStatement:
      'Given an array of strings `strs`, group the anagrams together. You must return a list of groups where each group contains strings that are anagrams of each other. Use character frequency arrays instead of sorting.\n\n<pre><code>Input: strs = ["eat","tea","tan","ate","nat","bat"]\nOutput: [["eat","tea","ate"],["tan","nat"],["bat"]]\n\nInput: strs = [""]\nOutput: [[""]]</code></pre>\n\n<ul>\n<li>1 ≤ strs.length ≤ 10<sup>4</sup></li>\n<li>0 ≤ strs[i].length ≤ 100</li>\n<li>strs[i] consists of lowercase English letters</li>\n</ul>\n\nPro Tip – Instead of sorting, build a 26-length frequency array for each word and use it as a hashable key to group words.',
    sampleTestCases: [
      {
        input: '6\neat\ntea\ntan\nate\nnat\nbat',
        expected: 'eat tea ate\ntan nat\nbat',
      },
      {
        input: '1\n""',
        expected: '""',
      },
    ],
    testCases: [
      { input: '3\naaa\naaa\naaa', expected: 'aaa aaa aaa' },
      { input: '5\nabc\nbca\ncab\nxyz\nyzx', expected: 'abc bca cab\nxyz yzx' },
      { input: '4\nabc\ndef\nghi\ncba', expected: 'abc cba\ndef\nghi' },
      { input: '2\na\nb', expected: 'a\nb' },
      { input: '1\nabcd', expected: 'abcd' },
      {
        input: '6\nsilent\nlisten\nenlist\ngoogle\nelints\ninlets',
        expected: 'silent listen enlist elints inlets\ngoogle',
      },
      {
        input: '3\nanagram\nnagaram\nmanagra',
        expected: 'anagram nagaram managra',
      },
      { input: '2\nrat\ttar', expected: 'rat\ntar' },
      { input: '0\n', expected: '' },
      { input: '3\naaa\naab\naa', expected: 'aaa\naab\naa' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're working on a plagiarism checker at Microsoft. Can you group documents based on anagram similarity, using letter counts instead of sorting for efficiency?",
    categories: ['string', 'hashing'],
    difficulty: 'medium',
    frequency: 91,
    tags: ['hash map', 'string', 'array'],
    companies: [
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Use a 26-element array to count letters for each string.',
      'Convert that array into a hashable form (like a string) for use as a dictionary key.',
      'Group all words with the same frequency key.',
    ],
    optimalComplexity: {
      time: 'O(n * k)',
      space: 'O(n * k)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const lines = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(lines[0]);\n  const strs = lines.slice(1);\n  const result = groupAnagrams(strs);\n  for (let group of result) {\n    console.log(group.join(' '));\n  }\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    strs = lines[1:]\n    return strs\n\nif __name__ == '__main__':\n    strs = parse_input()\n    result = group_anagrams(strs)\n    for group in result:\n        print(' '.join(group))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    List<String> strs = new ArrayList<>();\n    for (int i = 0; i < n; i++) strs.add(sc.nextLine());\n    List<List<String>> result = groupAnagrams(strs);\n    for (List<String> group : result) System.out.println(String.join(" ", group));\n  }\n}',
      },
      {
        language: 'cpp',
        code: "#include <iostream>\n#include <unordered_map>\n#include <vector>\n#include <string>\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  cin.ignore();\n  vector<string> strs(n);\n  for (int i = 0; i < n; ++i) getline(cin, strs[i]);\n  vector<vector<string>> result = groupAnagrams(strs);\n  for (auto &group : result) {\n    for (auto &s : group) cout << s << ' ';\n    cout << '\\n';\n  }\n  return 0;\n}",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function groupAnagrams(strs) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def group_anagrams(strs):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static List<List<String>> groupAnagrams(List<String> strs) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<vector<string>> groupAnagrams(vector<string>& strs) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Intersection of Two Arrays',
    slug: 'intersection-of-two-arrays',
    description:
      'Find the unique intersection elements between two integer arrays.',
    problemStatement:
      'Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must be unique, and the result can be in any order.\n\n<pre><code>Input: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2]\n\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [9,4]</code></pre>\n\n<ul>\n<li>1 ≤ nums1.length, nums2.length ≤ 10<sup>3</sup></li>\n<li>0 ≤ nums1[i], nums2[i] ≤ 1000</li>\n</ul>\n\nPro Tip – Use a set to store unique elements from the first array, and filter the second array by checking membership.',
    sampleTestCases: [
      {
        input: '4\n1 2 2 1\n2\n2 2',
        expected: '2',
      },
      {
        input: '3\n4 9 5\n5\n9 4 9 8 4',
        expected: '9 4',
      },
    ],
    testCases: [
      { input: '3\n1 2 3\n3\n3 4 5', expected: '3' },
      { input: '2\n5 5\n2\n5 5', expected: '5' },
      { input: '3\n1 2 3\n3\n4 5 6', expected: '' },
      { input: '5\n1 2 3 4 5\n5\n5 4 3 2 1', expected: '1 2 3 4 5' },
      { input: '4\n1 1 2 2\n2\n2 2', expected: '2' },
      { input: '0\n\n3\n1 2 3', expected: '' },
      { input: '3\n1 2 3\n0\n', expected: '' },
      { input: '3\n6 7 8\n3\n8 9 10', expected: '8' },
      { input: '4\n0 1 2 3\n4\n3 2 1 0', expected: '0 1 2 3' },
      {
        input: '5\n1000 200 300 400 500\n5\n200 300 1000 600 700',
        expected: '1000 200 300',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "At Apple, you're building a syncing system for calendar events across devices. Given two sets of events, identify the common ones without duplicates efficiently.",
    categories: ['array', 'hash set'],
    difficulty: 'easy',
    frequency: 90,
    tags: ['hash set', 'array'],
    companies: [
      { name: 'Apple', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use a hash set to record elements from one array.',
      'Check for membership of each element from the second array.',
      'Avoid duplicates in the result by using a set.',
    ],
    optimalComplexity: {
      time: 'O(n + m)',
      space: 'O(min(n, m))',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n1 = parseInt(input[0]);\n  const nums1 = n1 === 0 ? [] : input[1].split(' ').map(Number);\n  const n2 = parseInt(input[2]);\n  const nums2 = n2 === 0 ? [] : input[3].split(' ').map(Number);\n  const result = intersection(nums1, nums2);\n  console.log(result.join(' '));\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n1 = int(lines[0])\n    nums1 = list(map(int, lines[1].split())) if n1 > 0 else []\n    n2 = int(lines[2])\n    nums2 = list(map(int, lines[3].split())) if n2 > 0 else []\n    return nums1, nums2\n\nif __name__ == '__main__':\n    nums1, nums2 = parse_input()\n    print(' '.join(map(str, intersection(nums1, nums2))))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n1 = Integer.parseInt(sc.nextLine());\n    int[] nums1 = n1 == 0 ? new int[0] : Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int n2 = Integer.parseInt(sc.nextLine());\n    int[] nums2 = n2 == 0 ? new int[0] : Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int[] result = intersection(nums1, nums2);\n    for (int x : result) System.out.print(x + " ");\n  }\n}',
      },
      {
        language: 'cpp',
        code: "#include <iostream>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\nint main() {\n  int n1; cin >> n1;\n  vector<int> nums1(n1);\n  for (int i = 0; i < n1; i++) cin >> nums1[i];\n  int n2; cin >> n2;\n  vector<int> nums2(n2);\n  for (int i = 0; i < n2; i++) cin >> nums2[i];\n  vector<int> result = intersection(nums1, nums2);\n  for (int x : result) cout << x << ' ';\n  return 0;\n}",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function intersection(nums1, nums2) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def intersection(nums1, nums2):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int[] intersection(int[] nums1, int[] nums2) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Contains Duplicate III',
    slug: 'contains-duplicate-iii',
    description:
      'Check if there are two distinct indices i and j such that the absolute difference between nums[i] and nums[j] is at most t, and the absolute difference between i and j is at most k.',
    problemStatement:
      'You are given an integer array `nums` and two integers `k` and `t`. Return true if there are two distinct indices `i` and `j` in the array such that:\n\n- `abs(nums[i] - nums[j]) <= t`, and\n- `abs(i - j) <= k`\n\n<pre><code>Input: nums = [1,2,3,1], k = 3, t = 0\nOutput: true\n\nInput: nums = [1,0,1,1], k = 1, t = 2\nOutput: true\n\nInput: nums = [1,5,9,1,5,9], k = 2, t = 3\nOutput: false</code></pre>\n\n<ul>\n<li>1 ≤ nums.length ≤ 2 × 10<sup>4</sup></li>\n<li>-2<sup>31</sup> ≤ nums[i] ≤ 2<sup>31</sup> - 1</li>\n<li>0 ≤ k ≤ 10<sup>4</sup></li>\n<li>0 ≤ t ≤ 2<sup>31</sup> - 1</li>\n</ul>\n\nPro Tip – Use a sliding window with a balanced BST or bucketing approach to maintain the current window of k elements and check for nearby duplicates.',
    sampleTestCases: [
      {
        input: '4\n1 2 3 1\n3\n0',
        expected: 'true',
      },
      {
        input: '4\n1 0 1 1\n1\n2',
        expected: 'true',
      },
      {
        input: '6\n1 5 9 1 5 9\n2\n3',
        expected: 'false',
      },
    ],
    testCases: [
      { input: '2\n1 2\n0\n1', expected: 'false' },
      { input: '3\n1 2 3\n1\n1', expected: 'true' },
      { input: '4\n1 5 9 13\n2\n3', expected: 'false' },
      { input: '4\n1 2 1 2\n2\n0', expected: 'true' },
      { input: '3\n1 1 1\n1\n0', expected: 'true' },
      { input: '5\n-1 -1 2 3 1\n1\n0', expected: 'true' },
      {
        input: '3\n2147483647 -2147483647 2147483647\n1\n2147483647',
        expected: 'false',
      },
      { input: '5\n1 3 6 2 4\n2\n1', expected: 'true' },
      { input: '3\n1 5 9\n1\n3', expected: 'false' },
      { input: '3\n1 5 9\n2\n4', expected: 'false' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "At Google, you're analyzing sensor readings for potential anomalies. You need to detect if any two readings are close in value and time. Can you implement this efficiently?",
    categories: ['array', 'sliding window', 'bucket'],
    difficulty: 'hard',
    frequency: 86,
    tags: ['bucket sort', 'ordered set', 'sliding window'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Uber', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Use a sliding window of size k.',
      'Use a bucket-based approach to handle value closeness.',
      'Make sure to handle integer overflows properly.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(k)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const nums = input[1].split(' ').map(Number);\n  const k = parseInt(input[2]);\n  const t = parseInt(input[3]);\n  const result = containsNearbyAlmostDuplicate(nums, k, t);\n  console.log(result);\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    nums = list(map(int, lines[1].split()))\n    k = int(lines[2])\n    t = int(lines[3])\n    return nums, k, t\n\nif __name__ == '__main__':\n    nums, k, t = parse_input()\n    print(contains_nearby_almost_duplicate(nums, k, t))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int k = Integer.parseInt(sc.nextLine());\n    int t = Integer.parseInt(sc.nextLine());\n    System.out.println(containsNearbyAlmostDuplicate(nums, k, t));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  vector<long long> nums(n);\n  for (int i = 0; i < n; i++) cin >> nums[i];\n  long long k, t; cin >> k >> t;\n  cout << boolalpha << containsNearbyAlmostDuplicate(nums, k, t) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function containsNearbyAlmostDuplicate(nums, k, t) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def contains_nearby_almost_duplicate(nums, k, t):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'bool containsNearbyAlmostDuplicate(vector<long long>& nums, long long k, long long t) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Single Number',
    slug: 'single-number',
    description:
      'Find the element that appears only once in an array where every other element appears twice.',
    problemStatement:
      'You are given a non-empty array of integers `nums`, where every element appears twice except for one. Find and return the element that appears only once. You must implement a solution with linear runtime complexity and use only constant extra space.\n\n<pre><code>Input: nums = [2,2,1]\nOutput: 1\n\nInput: nums = [4,1,2,1,2]\nOutput: 4</code></pre>\n\n<ul>\n<li>1 ≤ nums.length ≤ 3 × 10<sup>4</sup></li>\n<li>-3 × 10<sup>4</sup> ≤ nums[i] ≤ 3 × 10<sup>4</sup></li>\n<li>Each element in the array appears twice except for one element which appears only once</li>\n</ul>\n\nPro Tip – XOR is its own inverse and satisfies `a ^ a = 0` and `a ^ 0 = a`. Use XOR to isolate the single number.',
    sampleTestCases: [
      {
        input: '3\n2 2 1',
        expected: '1',
      },
      {
        input: '5\n4 1 2 1 2',
        expected: '4',
      },
    ],
    testCases: [
      { input: '1\n5', expected: '5' },
      { input: '3\n0 1 0', expected: '1' },
      { input: '7\n3 3 4 4 5 5 9', expected: '9' },
      { input: '9\n10 10 11 11 12 12 13 13 20', expected: '20' },
      { input: '5\n1 1 2 2 3', expected: '3' },
      { input: '5\n6 7 6 8 8', expected: '7' },
      { input: '3\n-1 -1 0', expected: '0' },
      { input: '3\n-3 4 -3', expected: '4' },
      { input: '5\n1000 1000 999 999 -200', expected: '-200' },
      { input: '7\n6 7 7 8 8 6 10', expected: '10' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "At Google, you're analyzing signal logs where all but one sensor reading are duplicated due to redundancy. Can you efficiently find the unique signal?",
    categories: ['bit manipulation', 'array'],
    difficulty: 'easy',
    frequency: 97,
    tags: ['bit manipulation', 'array', 'xor'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use bitwise XOR to cancel out duplicate elements.',
      'XOR of a number with itself is zero; XOR of a number with 0 is the number.',
      'Keep XORing all numbers to isolate the unique one.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const nums = input[1].split(' ').map(Number);\n  const result = singleNumber(nums);\n  console.log(result);\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    nums = list(map(int, lines[1].split()))\n    return nums\n\nif __name__ == '__main__':\n    nums = parse_input()\n    print(single_number(nums))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    System.out.println(singleNumber(nums));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; i++) cin >> nums[i];\n  cout << singleNumber(nums) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function singleNumber(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def single_number(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int singleNumber(int[] nums) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int singleNumber(vector<int>& nums) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Missing and Repeating Number',
    slug: 'missing-and-repeating-number',
    description:
      'Find the one missing and one repeating number in an array of size n containing numbers from 1 to n.',
    problemStatement:
      'You are given an array `nums` of size `n`, containing numbers in the range `1` to `n`. Exactly one number in this range is missing from the array, and exactly one number appears twice. Find both the missing number and the repeating number.\n\n<pre><code>Input: nums = [3, 1, 2, 5, 3]\nOutput: repeating = 3, missing = 4\n\nInput: nums = [4, 3, 6, 2, 1, 1]\nOutput: repeating = 1, missing = 5</code></pre>\n\n<ul>\n<li>2 ≤ nums.length = n ≤ 10<sup>5</sup></li>\n<li>1 ≤ nums[i] ≤ n</li>\n<li>Exactly one number appears twice and exactly one number is missing</li>\n</ul>\n\nPro Tip – Use mathematics: sum and sum of squares formulas to derive missing and repeating in O(n) time and O(1) extra space.',
    sampleTestCases: [
      {
        input: '5\n3 1 2 5 3',
        expected: '3 4',
      },
      {
        input: '6\n4 3 6 2 1 1',
        expected: '1 5',
      },
    ],
    testCases: [
      { input: '2\n1 1', expected: '1 2' },
      { input: '3\n2 2 3', expected: '2 1' },
      { input: '4\n1 4 2 2', expected: '2 3' },
      { input: '5\n5 3 2 1 5', expected: '5 4' },
      { input: '5\n1 2 2 4 5', expected: '2 3' },
      { input: '6\n1 3 3 4 5 6', expected: '3 2' },
      { input: '6\n1 2 3 4 4 6', expected: '4 5' },
      { input: '7\n7 3 4 5 6 2 2', expected: '2 1' },
      { input: '7\n1 2 3 4 5 7 7', expected: '7 6' },
      { input: '8\n1 2 3 5 6 7 8 8', expected: '8 4' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're helping debug a user ID assignment system at Google. Each user ID from 1 to n should appear exactly once, but due to a glitch one ID is duplicated and one is missing. Can you identify both efficiently using constant extra memory?",
    categories: ['array', 'math'],
    difficulty: 'medium',
    frequency: 80,
    tags: ['math', 'sum', 'bit manipulation', 'array'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Let S = sum of 1..n, P = sum of squares of 1..n. Subtract actual sums to derive missing and repeating.',
      'Compute actual sum A and sum of squares B. Then: A - S = repeating - missing, B - P = repeating² - missing² = (repeating - missing)(repeating + missing).',
      'Solve the two equations to find both numbers.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf‑8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const nums = input[1].split(' ').map(Number);\n  const [rep, miss] = findMissingAndRepeating(nums);\n  console.log(rep + ' ' + miss);\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    nums = list(map(int, lines[1].split()))\n    return n, nums\n\nif __name__ == '__main__':\n    n, nums = parse_input()\n    rep, miss = find_missing_and_repeating(nums)\n    print(rep, miss)",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();\n    int[] ans = findMissingAndRepeating(nums);\n    System.out.println(ans[0] + " " + ans[1]);\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  vector<long long> nums(n);\n  for (int i = 0; i < n; ++i) cin >> nums[i];\n  auto ans = findMissingAndRepeating(nums);\n  cout << ans.first << " " << ans.second;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function findMissingAndRepeating(nums) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def find_missing_and_repeating(nums):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int[] findMissingAndRepeating(int[] nums) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'pair<int,int> findMissingAndRepeating(vector<long long>& nums) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Reverse a String',
    slug: 'reverse-a-string',
    description: 'Reverse the characters of a given string in-place.',
    problemStatement:
      'Write a function that reverses a string. The input string is given as an array of characters `s`. You must do this by modifying the input array in-place with O(1) extra memory.\n\n<pre><code>Input: s = ["h","e","l","l","o"]\nOutput: ["o","l","l","e","h"]\n\nInput: s = ["H","a","n","n","a","h"]\nOutput: ["h","a","n","n","a","H"]</code></pre>\n\n<ul>\n<li>1 ≤ s.length ≤ 10<sup>5</sup></li>\n<li>s[i] is a printable ASCII character</li>\n</ul>\n\nPro Tip – Use two pointers to swap characters from both ends of the array toward the center.',
    sampleTestCases: [
      {
        input: '5\nh e l l o',
        expected: 'o l l e h',
      },
      {
        input: '6\nH a n n a h',
        expected: 'h a n n a H',
      },
    ],
    testCases: [
      { input: '1\na', expected: 'a' },
      { input: '2\nx y', expected: 'y x' },
      { input: '3\nr a t', expected: 't a r' },
      { input: '4\n1 2 3 4', expected: '4 3 2 1' },
      { input: '6\np y t h o n', expected: 'n o h t y p' },
      { input: '7\ns t r i n g s', expected: 's g n i r t s' },
      { input: '3\nA B C', expected: 'C B A' },
      { input: '5\nz y x w v', expected: 'v w x y z' },
      { input: '8\n1 a 2 b 3 c 4 d', expected: 'd 4 c 3 b 2 a 1' },
      { input: '4\nm o m s', expected: 's m o m' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're implementing a string utility tool at Meta. One function must reverse a string in-place to save space. Can you optimize it for performance and memory?",
    categories: ['string', 'two pointer'],
    difficulty: 'easy',
    frequency: 89,
    tags: ['string', 'two pointer', 'in-place'],
    companies: [
      { name: 'Meta', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Apple', logoUrl: '' },
    ],
    hints: [
      'Use a two-pointer approach starting from both ends of the array.',
      'Swap elements until the pointers meet or cross.',
      'No additional memory should be used beyond a few variables.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const lines = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(lines[0]);\n  const s = lines[1].split(' ');\n  reverseString(s);\n  console.log(s.join(' '));\n}\nmain();",
      },
      {
        language: 'python',
        code: "def parse_input():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0])\n    s = lines[1].split(' ')\n    return s\n\nif __name__ == '__main__':\n    s = parse_input()\n    reverse_string(s)\n    print(' '.join(s))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    String[] s = sc.nextLine().split(" ");\n    reverseString(s);\n    System.out.println(String.join(" ", s));\n  }\n}',
      },
      {
        language: 'cpp',
        code: "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nint main() {\n  int n; cin >> n;\n  vector<string> s(n);\n  for (int i = 0; i < n; ++i) cin >> s[i];\n  reverseString(s);\n  for (string& c : s) cout << c << ' ';\n  return 0;\n}",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function reverseString(s) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def reverse_string(s):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static void reverseString(String[] s) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'void reverseString(vector<string>& s) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Check Palindrome',
    slug: 'check-palindrome',
    description: 'Determine whether a given string is a palindrome.',
    problemStatement:
      'Write a function that checks whether a given string `s` is a palindrome. A string is a palindrome if it reads the same backward as forward. Consider only alphanumeric characters and ignore cases.\n\n<pre><code>Input: s = "A man, a plan, a canal: Panama"\nOutput: true\n\nInput: s = "race a car"\nOutput: false</code></pre>\n\n<ul>\n<li>1 ≤ s.length ≤ 2 × 10<sup>5</sup></li>\n<li>s consists of printable ASCII characters</li>\n</ul>\n\nPro Tip – Clean the string by removing non-alphanumeric characters and converting to lowercase. Then use two pointers to check from both ends.',
    sampleTestCases: [
      {
        input: 'A man, a plan, a canal: Panama',
        expected: 'true',
      },
      {
        input: 'race a car',
        expected: 'false',
      },
    ],
    testCases: [
      { input: 'madam', expected: 'true' },
      { input: 'hello', expected: 'false' },
      { input: 'Able was I ere I saw Elba', expected: 'true' },
      { input: "No 'x' in Nixon", expected: 'true' },
      { input: 'Was it a car or a cat I saw?', expected: 'true' },
      { input: '12321', expected: 'true' },
      { input: '12345', expected: 'false' },
      { input: ' ', expected: 'true' },
      { input: '.,', expected: 'true' },
      { input: 'a.', expected: 'true' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "At Meta, you're building a text processing pipeline. One function must validate if a sentence is a palindrome for user input verification. How would you implement it efficiently?",
    categories: ['string', 'two pointer'],
    difficulty: 'easy',
    frequency: 88,
    tags: ['string', 'two pointer', 'cleaning'],
    companies: [
      { name: 'Meta', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Ignore non-alphanumeric characters using regex or filter.',
      'Convert the string to lowercase before checking.',
      'Use two pointers starting from both ends.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const s = fs.readFileSync(0, 'utf-8').trim();\n  const result = isPalindrome(s);\n  console.log(result);\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s = sys.stdin.read().strip()\n    print(is_palindrome(s))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    System.out.println(isPalindrome(s));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n  string s;\n  getline(cin, s);\n  cout << boolalpha << isPalindrome(s);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function isPalindrome(s) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def is_palindrome(s):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static boolean isPalindrome(String s) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'bool isPalindrome(string s) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Remove Duplicates from String',
    slug: 'remove-duplicates-from-string',
    description:
      'Remove all duplicate characters from a string, preserving the order of their first occurrences.',
    problemStatement:
      'You are given a string `s`. Your task is to remove all duplicate characters from `s` such that each character appears only once and in the order of their first appearance.\n\n<pre><code>Input: s = "bcabc"\nOutput: "bca"\n\nInput: s = "cbacdcbc"\nOutput: "cbad"</code></pre>\n\n<ul>\n<li>1 ≤ s.length ≤ 10<sup>5</sup></li>\n<li>`s` consists of lowercase English letters only</li>\n</ul>\n\nPro Tip – Use a hash set to keep track of characters already added to the result, and iterate through the string to build the final output.',
    sampleTestCases: [
      {
        input: 'bcabc',
        expected: 'bca',
      },
      {
        input: 'cbacdcbc',
        expected: 'cbad',
      },
    ],
    testCases: [
      { input: 'abcd', expected: 'abcd' },
      { input: 'aabbcc', expected: 'abc' },
      { input: 'a', expected: 'a' },
      { input: 'aaa', expected: 'a' },
      { input: 'abababab', expected: 'ab' },
      { input: 'zxyzzx', expected: 'zxy' },
      { input: 'leetcode', expected: 'letcod' },
      { input: 'programming', expected: 'progamin' },
      { input: 'banana', expected: 'ban' },
      { input: 'mississippi', expected: 'misp' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'At Amazon, you’re designing a system to compress strings by removing duplicates while preserving order. Can you build an efficient algorithm for this?',
    categories: ['string', 'hashing'],
    difficulty: 'easy',
    frequency: 85,
    tags: ['string', 'hash set', 'array'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use a set to track seen characters.',
      'Iterate through the string and add characters to the result only if they haven’t been seen yet.',
      'Preserve the original order by appending characters as they are encountered.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const s = fs.readFileSync(0, 'utf-8').trim();\n  const result = removeDuplicates(s);\n  console.log(result);\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s = sys.stdin.read().strip()\n    print(remove_duplicates(s))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    System.out.println(removeDuplicates(s));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n  string s; getline(cin, s);\n  cout << removeDuplicates(s);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function removeDuplicates(s) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def remove_duplicates(s):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static String removeDuplicates(String s) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'string removeDuplicates(string s) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Count Vowels and Consonants',
    slug: 'count-vowels-and-consonants',
    description: 'Count the number of vowels and consonants in a given string.',
    problemStatement:
      'Given a string `s` consisting of alphabetic characters (both uppercase and lowercase), write a function to return the number of vowels and consonants in the string. Vowels are `a`, `e`, `i`, `o`, and `u`. All other alphabetic characters are considered consonants.\n\n<pre><code>Input: s = "hello"\nOutput: vowels = 2, consonants = 3\n\nInput: s = "DSA Platform"\nOutput: vowels = 3, consonants = 8</code></pre>\n\n<ul>\n<li>1 ≤ s.length ≤ 10<sup>5</sup></li>\n<li>`s` contains only letters and spaces</li>\n</ul>\n\nPro Tip – Convert all characters to lowercase and use a set for fast vowel lookup. Skip spaces and non-alphabetic characters.',
    sampleTestCases: [
      {
        input: 'hello',
        expected: '2 3',
      },
      {
        input: 'DSA Platform',
        expected: '3 8',
      },
    ],
    testCases: [
      { input: 'aeiou', expected: '5 0' },
      { input: 'bcdfg', expected: '0 5' },
      { input: 'AaEeIiOoUu', expected: '10 0' },
      { input: 'xyz', expected: '0 3' },
      { input: 'The quick brown fox', expected: '5 13' },
      { input: ' ', expected: '0 0' },
      { input: 'H', expected: '0 1' },
      { input: 'A', expected: '1 0' },
      { input: 'Functional Programming', expected: '7 13' },
      { input: 'Data Structures and Algorithms', expected: '10 20' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're working on a speech analysis tool at Microsoft. One task is to analyze spoken words and count vowels vs consonants. Can you build this feature?",
    categories: ['string', 'counting'],
    difficulty: 'easy',
    frequency: 82,
    tags: ['string', 'counting', 'vowels', 'set'],
    companies: [
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use a set to store vowels for O(1) lookup.',
      'Ignore spaces and count only alphabetic characters.',
      'Convert the input to lowercase to simplify comparison.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const s = fs.readFileSync(0, 'utf-8').trim();\n  const [v, c] = countVowelsAndConsonants(s);\n  console.log(v + ' ' + c);\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s = sys.stdin.read().strip()\n    v, c = count_vowels_and_consonants(s)\n    print(v, c)",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    int[] res = countVowelsAndConsonants(s);\n    System.out.println(res[0] + " " + res[1]);\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n  string s;\n  getline(cin, s);\n  auto res = countVowelsAndConsonants(s);\n  cout << res.first << " " << res.second;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function countVowelsAndConsonants(s) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def count_vowels_and_consonants(s):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int[] countVowelsAndConsonants(String s) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'pair<int,int> countVowelsAndConsonants(string s) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Toggle Case of Characters',
    slug: 'toggle-case-of-characters',
    description:
      'Convert every lowercase letter to uppercase and every uppercase letter to lowercase in a given string.',
    problemStatement:
      'Given a string `s` consisting of alphabetic characters, write a function to toggle the case of each character. That is, convert each lowercase character to uppercase and each uppercase character to lowercase.\n\n<pre><code>Input: s = "AbCDeF"\nOutput: "aBcdEf"\n\nInput: s = "HeLLo WOrLD"\nOutput: "hEllo woRld"</code></pre>\n\n<ul>\n<li>1 ≤ s.length ≤ 10<sup>5</sup></li>\n<li>`s` contains only alphabetic characters and spaces</li>\n</ul>\n\nPro Tip – You can use built-in character manipulation methods or ASCII values to toggle character cases.',
    sampleTestCases: [
      {
        input: 'AbCDeF',
        expected: 'aBcdEf',
      },
      {
        input: 'HeLLo WOrLD',
        expected: 'hEllo woRld',
      },
    ],
    testCases: [
      { input: 'a', expected: 'A' },
      { input: 'Z', expected: 'z' },
      { input: 'abc', expected: 'ABC' },
      { input: 'XYZ', expected: 'xyz' },
      { input: 'JavaScript', expected: 'jAVAsCRIPT' },
      { input: 'ToGgLe', expected: 'tOgGlE' },
      { input: 'Case', expected: 'cASE' },
      { input: 'tOGGLE', expected: 'Toggle' },
      { input: 'aAaAaA', expected: 'AaAaAa' },
      { input: 'cOdInG', expected: 'CoDiNg' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "At Microsoft, you're working on a text processing tool that needs to invert letter casing for formatting purposes. Can you implement this toggle functionality efficiently?",
    categories: ['string', 'character manipulation'],
    difficulty: 'easy',
    frequency: 77,
    tags: ['string', 'case conversion', 'character loop'],
    companies: [
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      "Loop through each character and check if it's uppercase or lowercase.",
      'Use built-in methods or ASCII values to convert case.',
      'Preserve non-alphabetic characters like spaces.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const s = fs.readFileSync(0, 'utf-8').trim();\n  const result = toggleCase(s);\n  console.log(result);\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s = sys.stdin.read().strip()\n    print(toggle_case(s))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    System.out.println(toggleCase(s));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n  string s; getline(cin, s);\n  cout << toggleCase(s);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function toggleCase(s) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def toggle_case(s):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static String toggleCase(String s) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'string toggleCase(string s) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Convert String to Integer (Atoi)',
    slug: 'convert-string-to-integer-atoi',
    description:
      'Implement the atoi function, which converts a string to a 32-bit signed integer.',
    problemStatement:
      'Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++\'s atoi function). The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible and interprets them as a numerical value.\n\nThe string can contain additional characters after those that form the integral number, which are ignored. If the first sequence of non-whitespace characters is not a valid integral number, return 0.\n\nIf the number is out of the 32-bit signed integer range [−2<sup>31</sup>, 2<sup>31</sup> − 1], clamp the integer so that it remains in the range.\n\n<pre><code>Input: "42"\nOutput: 42\n\nInput: "   -42"\nOutput: -42\n\nInput: "4193 with words"\nOutput: 4193\n\nInput: "words and 987"\nOutput: 0\n\nInput: "-91283472332"\nOutput: -2147483648</code></pre>\n\n<ul>\n<li>0 ≤ s.length ≤ 200</li>\n<li>`s` consists of English letters, digits, whitespace, and the characters \'+\', \'-\'.</li>\n</ul>\n\nPro Tip – Use regular expressions or manual parsing. Be careful with leading spaces, optional sign, digit extraction, and overflow.',
    sampleTestCases: [
      { input: '42', expected: '42' },
      { input: '   -42', expected: '-42' },
      { input: '4193 with words', expected: '4193' },
    ],
    testCases: [
      { input: 'words and 987', expected: '0' },
      { input: '-91283472332', expected: '-2147483648' },
      { input: '91283472332', expected: '2147483647' },
      { input: '+1', expected: '1' },
      { input: '+-12', expected: '0' },
      { input: '00000-42a1234', expected: '0' },
      { input: '   +0 123', expected: '0' },
      { input: '3.14159', expected: '3' },
      { input: '-0012a42', expected: '-12' },
      { input: '', expected: '0' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're building a parser at Amazon that must extract integer values from unstructured strings. Your job is to write the conversion logic that behaves like C's atoi function.",
    categories: ['string', 'parsing'],
    difficulty: 'medium',
    frequency: 84,
    tags: ['string', 'parsing', 'conversion', 'edge-cases'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Apple', logoUrl: '' },
    ],
    hints: [
      'Handle leading whitespaces using a loop or trim.',
      'Track sign, then process numerical digits while checking for overflow.',
      'Stop parsing when non-digit is encountered after optional sign and digits.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const s = fs.readFileSync(0, 'utf-8').trim();\n  console.log(myAtoi(s));\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s = sys.stdin.read().strip()\n    print(my_atoi(s))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    System.out.println(myAtoi(s));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n  string s; getline(cin, s);\n  cout << myAtoi(s);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function myAtoi(s) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def my_atoi(s):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int myAtoi(String s) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int myAtoi(string s) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Check if Two Strings are Anagram',
    slug: 'check-if-two-strings-are-anagram',
    description: 'Determine whether two strings are anagrams of each other.',
    problemStatement:
      'Write a function that takes two strings `s` and `t`, and returns `true` if `t` is an anagram of `s`, and `false` otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once.\n\n<pre><code>Input: s = "anagram", t = "nagaram"\nOutput: true\n\nInput: s = "rat", t = "car"\nOutput: false</code></pre>\n\n<ul>\n<li>1 ≤ s.length, t.length ≤ 5 × 10<sup>4</sup></li>\n<li>`s` and `t` consist of lowercase English letters</li>\n</ul>\n\nPro Tip – Use a frequency counter to compare the character counts in both strings.',
    sampleTestCases: [
      { input: 'anagram\nnagaram', expected: 'true' },
      { input: 'rat\ncar', expected: 'false' },
    ],
    testCases: [
      { input: 'a\nb', expected: 'false' },
      { input: 'abc\nbca', expected: 'true' },
      { input: 'listen\nsilent', expected: 'true' },
      { input: 'triangle\nintegral', expected: 'true' },
      { input: 'hello\nbello', expected: 'false' },
      { input: 'aabbcc\nddbbcc', expected: 'false' },
      { input: 'night\nthing', expected: 'true' },
      { input: 'abcd\nabcde', expected: 'false' },
      { input: 'racecar\ncarrace', expected: 'true' },
      { input: 'binary\nbrainy', expected: 'true' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're building a search assistant at Google. To match user input with known phrases, you must detect anagrams. How would you efficiently verify if two strings are anagrams?",
    categories: ['string', 'hashing'],
    difficulty: 'easy',
    frequency: 86,
    tags: ['string', 'hashmap', 'frequency counter', 'sorting'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Count the frequency of each character in both strings.',
      'If the frequencies match, the strings are anagrams.',
      'Alternatively, sort both strings and compare.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const [s, t] = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  console.log(isAnagram(s, t));\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s, t = sys.stdin.read().strip().split('\\n')\n    print(is_anagram(s, t))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.nextLine();\n        String t = sc.nextLine();\n        System.out.println(isAnagram(s, t));\n    }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n  string s, t; getline(cin, s); getline(cin, t);\n  cout << boolalpha << isAnagram(s, t);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function isAnagram(s, t) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def is_anagram(s, t):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static boolean isAnagram(String s, String t) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'bool isAnagram(string s, string t) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Check if Two Strings are Anagram',
    slug: 'check-if-two-strings-are-anagram',
    description: 'Determine whether two strings are anagrams of each other.',
    problemStatement:
      'Write a function that takes two strings `s` and `t`, and returns `true` if `t` is an anagram of `s`, and `false` otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once.\n\n<pre><code>Input: s = "anagram", t = "nagaram"\nOutput: true\n\nInput: s = "rat", t = "car"\nOutput: false</code></pre>\n\n<ul>\n<li>1 ≤ s.length, t.length ≤ 5 × 10<sup>4</sup></li>\n<li>`s` and `t` consist of lowercase English letters</li>\n</ul>\n\nPro Tip – Use a frequency counter to compare the character counts in both strings.',
    sampleTestCases: [
      { input: 'anagram\nnagaram', expected: 'true' },
      { input: 'rat\ncar', expected: 'false' },
    ],
    testCases: [
      { input: 'a\nb', expected: 'false' },
      { input: 'abc\nbca', expected: 'true' },
      { input: 'listen\nsilent', expected: 'true' },
      { input: 'triangle\nintegral', expected: 'true' },
      { input: 'hello\nbello', expected: 'false' },
      { input: 'aabbcc\nddbbcc', expected: 'false' },
      { input: 'night\nthing', expected: 'true' },
      { input: 'abcd\nabcde', expected: 'false' },
      { input: 'racecar\ncarrace', expected: 'true' },
      { input: 'binary\nbrainy', expected: 'true' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're building a search assistant at Google. To match user input with known phrases, you must detect anagrams. How would you efficiently verify if two strings are anagrams?",
    categories: ['string', 'hashing'],
    difficulty: 'easy',
    frequency: 86,
    tags: ['string', 'hashmap', 'frequency counter', 'sorting'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Count the frequency of each character in both strings.',
      'If the frequencies match, the strings are anagrams.',
      'Alternatively, sort both strings and compare.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const [s, t] = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  console.log(isAnagram(s, t));\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s, t = sys.stdin.read().strip().split('\\n')\n    print(is_anagram(s, t))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.nextLine();\n        String t = sc.nextLine();\n        System.out.println(isAnagram(s, t));\n    }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n  string s, t; getline(cin, s); getline(cin, t);\n  cout << boolalpha << isAnagram(s, t);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function isAnagram(s, t) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def is_anagram(s, t):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static boolean isAnagram(String s, String t) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'bool isAnagram(string s, string t) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Check if Rotation of Another String',
    slug: 'check-if-rotation-of-another-string',
    description: 'Determine whether one string is a rotation of another.',
    problemStatement:
      'Given two strings `s1` and `s2`, write a function to check if `s2` is a rotation of `s1` using only one call to a substring checking method. A string `s2` is a rotation of `s1` if it can be obtained by moving some leading characters of `s1` to the end without changing the order of the remaining characters.\n\n<pre><code>Input: s1 = "waterbottle", s2 = "erbottlewat"\nOutput: true\n\nInput: s1 = "hello", s2 = "llohe"\nOutput: true\n\nInput: s1 = "hello", s2 = "llhoe"\nOutput: false</code></pre>\n\n<ul>\n<li>1 ≤ s1.length = s2.length ≤ 100</li>\n<li>`s1` and `s2` consist of lowercase English letters only</li>\n</ul>\n\nPro Tip – Concatenate s1 with itself and check if s2 is a substring of the result.',
    sampleTestCases: [
      { input: 'waterbottle\nerbottlewat', expected: 'true' },
      { input: 'hello\nllohe', expected: 'true' },
    ],
    testCases: [
      { input: 'hello\nllhoe', expected: 'false' },
      { input: 'abcde\ncdeab', expected: 'true' },
      { input: 'abcde\neabcd', expected: 'true' },
      { input: 'abcde\ndabce', expected: 'false' },
      { input: 'aaaaa\naaaaa', expected: 'true' },
      { input: 'rotation\ntationro', expected: 'true' },
      { input: 'rotation\nationtor', expected: 'false' },
      { input: 'xyz\nzxy', expected: 'true' },
      { input: 'xyz\nyzx', expected: 'false' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "At Apple, you're optimizing a music player that needs to detect song loop patterns. Can you determine if one pattern is a rotated version of another efficiently?",
    categories: ['string', 'substring search'],
    difficulty: 'easy',
    frequency: 78,
    tags: ['string', 'rotation', 'substring check'],
    companies: [
      { name: 'Apple', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Concatenate s1 with itself and check if s2 is a substring.',
      'Check lengths first—if unequal, return false immediately.',
      'Rotation means a portion of the start was moved to the end.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const [s1, s2] = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  console.log(isRotation(s1, s2));\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s1, s2 = sys.stdin.read().strip().split('\\n')\n    print(is_rotation(s1, s2))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s1 = sc.nextLine();\n        String s2 = sc.nextLine();\n        System.out.println(isRotation(s1, s2));\n    }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n  string s1, s2;\n  getline(cin, s1);\n  getline(cin, s2);\n  cout << boolalpha << isRotation(s1, s2);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function isRotation(s1, s2) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def is_rotation(s1, s2):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static boolean isRotation(String s1, String s2) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'bool isRotation(string s1, string s2) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Check if Two Strings are Isomorphic',
    slug: 'check-if-two-strings-are-isomorphic',
    description:
      'Determine whether two strings are isomorphic by comparing character mappings.',
    problemStatement:
      'Two strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`, with each character mapping to another character consistently and uniquely. No two characters may map to the same character, but a character may map to itself.\n\nWrite a function to determine if `s` and `t` are isomorphic.\n\n<pre><code>Input: s = "egg", t = "add"\nOutput: true\n\nInput: s = "foo", t = "bar"\nOutput: false\n\nInput: s = "paper", t = "title"\nOutput: true</code></pre>\n\n<ul>\n<li>1 ≤ s.length, t.length ≤ 5 × 10<sup>4</sup></li>\n<li>`s` and `t` consist of lowercase English letters only</li>\n</ul>\n\nPro Tip – Use two hash maps to maintain the mapping in both directions (s → t and t → s) and ensure they are consistent.',
    sampleTestCases: [
      { input: 'egg\nadd', expected: 'true' },
      { input: 'foo\nbar', expected: 'false' },
    ],
    testCases: [
      { input: 'paper\ntitle', expected: 'true' },
      { input: 'ab\nca', expected: 'true' },
      { input: 'ab\ncc', expected: 'false' },
      { input: 'abab\ncdcd', expected: 'true' },
      { input: 'aaaa\nbbbb', expected: 'true' },
      { input: 'abcd\neeff', expected: 'false' },
      { input: 'abc\ndef', expected: 'true' },
      { input: 'abca\ndeed', expected: 'false' },
      { input: 'turtle\nturtll', expected: 'false' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "At Google, you're tasked with implementing a cipher translator. Each character must uniquely and consistently map to another character. Can you determine if two strings follow the same pattern?",
    categories: ['string', 'hash map'],
    difficulty: 'easy',
    frequency: 83,
    tags: ['string', 'hashmap', 'bijection', 'mapping'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Map each character from s to t and t to s simultaneously.',
      'If any mapping is inconsistent, return false.',
      'Check lengths first—they must match.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const [s, t] = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  console.log(areIsomorphic(s, t));\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s, t = sys.stdin.read().strip().split('\\n')\n    print(are_isomorphic(s, t))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    String t = sc.nextLine();\n    System.out.println(areIsomorphic(s, t));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n  string s, t;\n  getline(cin, s);\n  getline(cin, t);\n  cout << boolalpha << areIsomorphic(s, t);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function areIsomorphic(s, t) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def are_isomorphic(s, t):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static boolean areIsomorphic(String s, String t) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'bool areIsomorphic(string s, string t) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Longest Substring Without Repeating Characters',
    slug: 'longest-substring-without-repeating-characters',
    description:
      'Find the length of the longest substring without repeating characters.',
    problemStatement:
      'Given a string `s`, find the length of the longest substring without repeating characters.\n\n<pre><code>Input: s = "abcabcbb"\nOutput: 3\n\nInput: s = "bbbbb"\nOutput: 1\n\nInput: s = "pwwkew"\nOutput: 3</code></pre>\n\n<ul>\n<li>0 ≤ s.length ≤ 5 × 10<sup>4</sup></li>\n<li>`s` consists of English letters, digits, symbols, and spaces</li>\n</ul>\n\nPro Tip – Use a sliding window approach with a hash map to track characters and their indices.',
    sampleTestCases: [
      { input: 'abcabcbb', expected: '3' },
      { input: 'bbbbb', expected: '1' },
      { input: 'pwwkew', expected: '3' },
    ],
    testCases: [
      { input: 'abcdef', expected: '6' },
      { input: 'dvdf', expected: '3' },
      { input: '', expected: '0' },
      { input: ' ', expected: '1' },
      { input: 'au', expected: '2' },
      { input: 'anviaj', expected: '5' },
      { input: 'tmmzuxt', expected: '5' },
      { input: 'abba', expected: '2' },
      { input: 'abcdeafgh', expected: '7' },
      { input: 'aab', expected: '2' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're building an input prediction engine at Netflix. You need to identify the longest sequence a user types without repeating any character. Can you solve this efficiently?",
    categories: ['string', 'sliding window'],
    difficulty: 'medium',
    frequency: 91,
    tags: ['sliding window', 'string', 'hashmap'],
    companies: [
      { name: 'Netflix', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use a hash map to store characters and their last index.',
      'Maintain a sliding window by adjusting the left pointer when duplicates appear.',
      'Track the maximum window size as you iterate.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(min(n, m))',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const s = fs.readFileSync(0, 'utf-8').trim();\n  console.log(lengthOfLongestSubstring(s));\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s = sys.stdin.read().strip()\n    print(length_of_longest_substring(s))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    System.out.println(lengthOfLongestSubstring(s));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n  string s; getline(cin, s);\n  cout << lengthOfLongestSubstring(s);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function lengthOfLongestSubstring(s) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def length_of_longest_substring(s):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int lengthOfLongestSubstring(String s) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int lengthOfLongestSubstring(string s) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Minimum Window Substring',
    slug: 'minimum-window-substring',
    description:
      'Find the smallest substring in `s` that contains all characters of `t` (including duplicates).',
    problemStatement:
      'Given two strings `s` and `t`, return the minimum window in `s` which contains all characters in `t`. If there is no such window, return an empty string "".\n\n<pre><code>Input: s = "ADOBECODEBANC", t = "ABC"\nOutput: "BANC"\n\nInput: s = "a", t = "a"\nOutput: "a"\n\nInput: s = "a", t = "aa"\nOutput: ""  (no valid window)\n</code></pre>\n\n<ul>\n<li>m = s.length, n = t.length</li>\n<li>1 ≤ m, n ≤ 10⁵</li>\n<li>`s` and `t` consist of English letters (uppercase and lowercase)</li>\n</ul>\n\nPro Tip – Use a **sliding window** with two hash maps (or counters): one for required character counts from `t`, and another for counts within the current window in `s`. Expand the window until it\'s valid, then shrink it while keeping it valid to find the minimum-length window efficiently. :contentReference[oaicite:1]{index=1}',
    sampleTestCases: [
      {
        input: 'ADOBECODEBANC\nABC',
        expected: 'BANC',
      },
      {
        input: 'a\na',
        expected: 'a',
      },
    ],
    testCases: [
      { input: 'a\naa', expected: '' },
      { input: 'ab\nb', expected: 'b' },
      { input: 'aabdec\nabc', expected: 'abdec' },
      { input: 'abdbca\nabc', expected: 'bca' },
      { input: 'aa\naa', expected: 'aa' },
      { input: 'ab\nb', expected: 'b' },
      { input: 'cadbanc\nabc', expected: 'anc' },
      { input: 'ADOBECODEBANC\nABBC', expected: '' },
      { input: 'ADOBECODEBANC\nBEC', expected: 'BEC' },
      { input: 'xyz\na', expected: '' },
    ],
    topics: ['sliding window', 'hash map', 'string'],
    interviewExcerpt:
      'You’re building a text search feature at Amazon. To optimize cost, you need to extract the smallest snippet from a document that contains all the search terms. Could you use a sliding-window approach to solve this efficiently?',
    categories: ['string', 'sliding window'],
    difficulty: 'hard',
    frequency: 90,
    tags: ['sliding window', 'two pointer', 'frequency counter', 'substring'],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Apple', logoUrl: '' },
    ],
    hints: [
      'Use one hash map for required counts (`t`) and another for window counts.',
      'Track how many characters are satisfied; expand `right` until valid, then shrink `left` while still valid.',
      'Update the best (smallest) window during contraction.',
    ],
    optimalComplexity: {
      time: 'O(m + n)',
      space: 'O(unique characters in t + unique in window)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const [s, t] = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  console.log(minWindow(s, t));\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s, t = sys.stdin.read().strip().split('\\n')\n    print(min_window(s, t))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    String t = sc.nextLine();\n    System.out.println(minWindow(s, t));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n  string s, t;\n  getline(cin, s);\n  getline(cin, t);\n  cout << minWindow(s, t);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function minWindow(s, t) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def min_window(s, t):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static String minWindow(String s, String t) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'string minWindow(string s, string t) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Longest Repeating Character Replacement',
    slug: 'longest-repeating-character-replacement',
    description:
      'Find the length of the longest substring containing the same character after performing at most k character replacements.',
    problemStatement:
      'You are given a string `s` (consisting of uppercase English letters) and an integer `k`. You may perform at most `k` operations, where each operation lets you change any character in the string to any other uppercase letter. Return the length of the longest substring you can obtain that contains the same character.\n\n<pre><code>Input: s = "AABABBA", k = 1\nOutput: 4\nExplanation: Replace the one \'A\' with a \'B\' to form "AABBBBA". The longest repeating substring is "BBBB" of length 4.\n\nInput: s = "ABAB", k = 2\nOutput: 4\nExplanation: Replace both \'A\'s with \'B\' or vice versa to get "BBBB" or "AAAA" of length 4.</code></pre>\n\n<ul>\n<li>1 ≤ s.length ≤ 10<sup>5</sup></li>\n<li>s consists only of uppercase English letters (\'A\'–\'Z\')</li>\n<li>0 ≤ k ≤ s.length</li>\n</ul>\n\nPro Tip – Use a **sliding window** and keep track of the frequency of characters within the window and the count of the most frequent character. If the window length minus the max frequency exceeds `k`, shrink the window from the left.\n',
    sampleTestCases: [
      { input: 'AABABBA\n1', expected: '4' },
      { input: 'ABAB\n2', expected: '4' },
    ],
    testCases: [
      { input: 'AAAA\n0', expected: '4' },
      { input: 'ABCDE\n0', expected: '1' },
      { input: 'AABBBCC\n2', expected: '5' },
      { input: 'BAAAB\n2', expected: '5' },
      { input: 'BBBAAA\n3', expected: '6' },
      { input: 'CABCBBAB\n1', expected: '4' },
      { input: 'ABAA\n0', expected: '2' },
      { input: 'ABAA\n1', expected: '3' },
      { input: 'ABAA\n2', expected: '4' },
    ],
    topics: ['string', 'sliding window', 'hash map'],
    interviewExcerpt:
      "You're optimizing text formatting in a UI at Meta. You want to create the longest sequence of identical characters by changing up to K characters. How would you compute this quickly?",
    categories: ['string', 'sliding window'],
    difficulty: 'medium',
    frequency: 89,
    tags: ['sliding window', 'two pointer', 'hash map', 'char frequency'],
    companies: [
      { name: 'LeetCode', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Meta', logoUrl: '' },
    ],
    hints: [
      'Use a sliding window with two pointers: left and right.',
      'Maintain a frequency counter for characters and track the count of the most frequent one (`maxCount`).',
      'If `window size - maxCount > k`, shrink window by incrementing left.',
      'Always update result = max(result, window size).',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)', // because the counter size is fixed at 26 letters
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const [s, kStr] = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const k = parseInt(kStr);\n  console.log(characterReplacement(s, k));\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s, kStr = sys.stdin.read().strip().split('\\n')\n    k = int(kStr)\n    print(character_replacement(s, k))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    int k = Integer.parseInt(sc.nextLine());\n    System.out.println(characterReplacement(s, k));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n  string s;\n  getline(cin, s);\n  int k;\n  cin >> k;\n  cout << characterReplacement(s, k);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function characterReplacement(s, k) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def character_replacement(s, k):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int characterReplacement(String s, int k) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int characterReplacement(string s, int k) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Permutation in String',
    slug: 'permutation-in-string',
    description:
      'Determine if one string contains any permutation of another string as a substring.',
    problemStatement:
      'Given two strings `s1` and `s2`, return `true` if `s2` contains a permutation of `s1` as a substring; otherwise, return `false`.\n\nA permutation of `s1` is any rearrangement of its characters. For example:\n\n<pre><code>Input: s1 = "ab", s2 = "eidbaooo"\nOutput: true  // substring "ba" is a permutation of "ab"\n\nInput: s1 = "ab", s2 = "eidboaoo"\nOutput: false</code></pre>\n\n<ul>\n<li>1 ≤ s1.length, s2.length ≤ 10⁵</li>\n<li>`s1` and `s2` consist of lowercase English letters</li>\n</ul>\n\nPro Tip – Use a **fixed-size sliding window** of length `s1.length()` on `s2`, alongside **frequency count arrays** of size 26. At each step, compare counts to check if the window matches `s1`’s character frequencies.',
    sampleTestCases: [
      {
        input: 'ab\neidbaooo',
        expected: 'true',
      },
      {
        input: 'ab\neidboaoo',
        expected: 'false',
      },
    ],
    testCases: [
      { input: 'adc\ndcda', expected: 'true' },
      { input: 'hello\nooolleoooleh', expected: 'false' },
      { input: 'a\na', expected: 'true' },
      { input: 'a\nb', expected: 'false' },
      { input: 'xyz\naxyz', expected: 'true' },
      { input: 'xyz\nzxy', expected: 'true' },
      { input: 'ab\nab', expected: 'true' },
      { input: 'ab\nba', expected: 'true' },
      { input: 'ab\nabc', expected: 'true' },
      { input: 'ab\nacb', expected: 'false' },
    ],
    topics: ['string', 'sliding window', 'hashing'],
    interviewExcerpt:
      "You're implementing a search feature at Google that needs to detect if a user’s search key (an anagram) appears in the document. Can you use a sliding window combined with frequency count to detect any permutation efficiently?",
    categories: ['string', 'sliding window'],
    difficulty: 'medium',
    frequency: 92,
    tags: [
      'sliding window',
      'frequency counter',
      'substring',
      'hash map',
      'array',
    ],
    companies: [
      { name: 'LeetCode', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Maintain two arrays of size 26 for character frequencies in `s1` and the current window of `s2`.',
      'Slide the window over `s2`, updating counts by adding a new char and removing the old one.',
      'At each step, compare the two frequency arrays for equality (arrays of size 26 comparison is O(1) time).',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const [s1, s2] = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  console.log(checkInclusion(s1, s2));\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s1, s2 = sys.stdin.read().strip().split('\\n')\n    print(check_inclusion(s1, s2))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s1 = sc.nextLine();\n    String s2 = sc.nextLine();\n    System.out.println(checkInclusion(s1, s2));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint main() {\n  string s1, s2;\n  getline(cin, s1);\n  getline(cin, s2);\n  cout << boolalpha << checkInclusion(s1, s2);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function checkInclusion(s1, s2) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def check_inclusion(s1, s2):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static boolean checkInclusion(String s1, String s2) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'bool checkInclusion(string s1, string s2) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Anagram Indices in String',
    slug: 'anagram-indices-in-string',
    description:
      'Find all starting indices of substrings in a string that are anagrams of another string.',
    problemStatement:
      'Given two strings, `s` and `p`, return an array of all indices in `s` where the substring starting at that index is an anagram of `p`. The order of output does not matter.\n\n<pre><code>Input: s = "cbaebabacd", p = "abc"\nOutput: [0, 6]\nExplanation:\n - Substring starting at 0 is "cba", which is an anagram of "abc".\n - Substring starting at 6 is "bac", which is an anagram of "abc".\n\nInput: s = "abab", p = "ab"\nOutput: [0, 1, 2]\nExplanation:\n - "ab", "ba", and "ab" at starting indices 0, 1, and 2 are anagrams of "ab".\n</code></pre>\n\n<ul>\n<li>1 ≤ s.length, p.length ≤ 10⁵</li>\n<li>`s` and `p` consist of lowercase English letters</li>\n</ul>\n\nPro Tip – Use a **sliding window** of length `p.length()` over `s` with two fixed-length frequency arrays (size 26). Slide the window right by updating counts and compare the window’s frequency against `p`’s frequency at each step.',
    sampleTestCases: [
      {
        input: 'cbaebabacd\nabc',
        expected: '[0, 6]',
      },
      {
        input: 'abab\nab',
        expected: '[0, 1, 2]',
      },
    ],
    testCases: [
      { input: 'af\nbf', expected: '[]' },
      { input: 'aa\naa', expected: '[0]' },
      { input: 'aa\na', expected: '[0, 1]' },
      { input: 'baa\naa', expected: '[1]' },
      { input: 'abab\nab', expected: '[0, 1, 2]' },
      { input: 'abcde\nabc', expected: '[0]' },
      { input: 'abcde\ncba', expected: '[0]' },
      { input: 'abcde\nbac', expected: '[0]' },
      { input: 'aaaaa\naaa', expected: '[0, 1, 2]' },
      { input: 'aaab\nabb', expected: '[1]' },
    ],
    topics: ['string', 'sliding window', 'hashing'],
    interviewExcerpt:
      "You're building a spell-checker at Google that highlights where anagrams of a keyword appear within a larger string. How would you track all starting positions efficiently? Think sliding window + character frequency.",
    categories: ['string', 'sliding window'],
    difficulty: 'medium',
    frequency: 90,
    tags: [
      'sliding window',
      'frequency counter',
      'substring',
      'hash map',
      'array',
    ],
    companies: [
      { name: 'LeetCode', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use two arrays of size 26: one for frequency of `p`, one for current window in `s`.',
      'Initialize the window on the first `p.length()` characters of `s`.',
      'Slide the window by removing the count of the character that moves out, and adding the new character count.',
      'Compare the two arrays at each step—if equal, record the starting index.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const [s, p] = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  console.log(findAnagrams(s, p));\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s, p = sys.stdin.read().strip().split('\\n')\n    print(find_anagrams(s, p))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    String p = sc.nextLine();\n    System.out.println(findAnagrams(s, p));\n  }\n}',
      },
      {
        language: 'cpp',
        code: "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n  string s, p;\n  getline(cin, s);\n  getline(cin, p);\n  vector<int> result = findAnagrams(s, p);\n  for (int idx : result) cout << idx << ' ';\n  return 0;\n}",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function findAnagrams(s, p) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def find_anagrams(s, p):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static List<Integer> findAnagrams(String s, String p) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> findAnagrams(string s, string p) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Substrings with Equal Number of 0s and 1s',
    slug: 'substrings-equal-0s-1s',
    description:
      'Count non-empty substrings in a binary string that have an equal number of 0s and 1s, with all 0s and all 1s grouped consecutively.',
    problemStatement:
      'Given a binary string `s`, return the number of substrings where the number of 0s and the number of 1s are equal, and all the 0s and all the 1s in the substring are grouped consecutively. That is, substrings like "0011" or "1100" are valid, but "0101" is not.\n\n<pre><code>Input: s = "00110011"\nOutput: 6\nExplanation: Valid substrings are "0011", "01", "1100", "10", "0011", "01"\n\nInput: s = "10101"\nOutput: 4\nExplanation: Valid substrings are "10", "01", "10", "01"</code></pre>\n\n<ul>\n<li>1 ≤ s.length ≤ 10⁵</li>\n<li>`s` consists of characters \'0\' and \'1\'</li>\n</ul>\n\nPro Tip – Count consecutive identical characters into groups, then the number of valid substrings crossing a boundary between groups is the minimum of the two adjacent group lengths.',
    sampleTestCases: [
      {
        input: '00110011',
        expected: '6',
      },
      {
        input: '10101',
        expected: '4',
      },
    ],
    testCases: [
      { input: '0011', expected: '2' },
      { input: '00011', expected: '2' },
      { input: '010', expected: '2' },
      { input: '0000', expected: '0' },
      { input: '1111', expected: '0' },
      { input: '00110', expected: '3' },
      { input: '01', expected: '1' },
      { input: '10', expected: '1' },
      { input: '001100', expected: '4' },
      { input: '11001100', expected: '6' },
    ],
    topics: ['string', 'two pointers', 'greedy'],
    interviewExcerpt:
      "At Google, you're tasked with identifying balanced patterns in a binary signal. You're asked: How many substrings are perfectly balanced (equal 0s & 1s) with grouped runs? How would you count efficiently?",
    categories: ['string', 'greedy'],
    difficulty: 'medium',
    frequency: 82,
    tags: ['string', 'two pointer', 'counting', 'prefix runs'],
    companies: [
      { name: 'LeetCode', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Group consecutive characters and track the lengths.',
      'Each boundary between groups contributes min(prevGroupLen, currentGroupLen) substrings.',
      'Traverse only once to build groups and another pass to sum contributions.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)', // for storing group lengths
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const s = fs.readFileSync(0, 'utf-8').trim();\n  console.log(countBinarySubstrings(s));\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s = sys.stdin.read().strip()\n    print(count_binary_substrings(s))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    System.out.println(countBinarySubstrings(s));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n  string s;\n  getline(cin, s);\n  cout << countBinarySubstrings(s);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function countBinarySubstrings(s) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def count_binary_substrings(s):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int countBinarySubstrings(String s) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int countBinarySubstrings(string s) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Count Occurrences of Anagram',
    slug: 'count-occurrences-of-anagram',
    description:
      'Count how many substrings in a given text are anagrams of a given pattern.',
    problemStatement:
      'Given a text string `text` and a pattern string `pattern`, return the total number of substrings in `text` which are anagrams of `pattern`. Every permutation of the pattern that appears as a substring should be counted.\n\n<pre><code>Input: text = "forxxorfxdofr", pattern = "for"\nOutput: 3\nExplanation: Anagrams present are "for", "orf", and "ofr".\n\nInput: text = "aabaabaa", pattern = "aaba"\nOutput: 4\nExplanation: Anagrams "aaba" and "abaa" appear multiple times.</code></pre>\n\n<ul>\n<li>1 ≤ pattern.length ≤ text.length ≤ 10<sup>5</sup></li>\n<li>`text` and `pattern` consist of lowercase English letters</li>\n</ul>\n\nPro Tip – Use a sliding window of size equal to pattern\'s length, and maintain a frequency map of characters needed. Slide across the text, updating counts dynamically and tracking matches efficiently (no need to re-check full window each time).',
    sampleTestCases: [
      {
        input: 'forxxorfxdofr\nfor',
        expected: '3',
      },
      {
        input: 'aabaabaa\naaba',
        expected: '4',
      },
    ],
    testCases: [
      { input: 'abcdefg\naf', expected: '1' },
      { input: 'ababab\nab', expected: '5' },
      { input: 'bbbb\na', expected: '0' },
      { input: 'abcabc\ndabc', expected: '3' },
      { input: 'aaaa\naa', expected: '3' },
      { input: 'abcd\neu', expected: '0' },
      { input: 'abdccba\nabc', expected: '2' },
      { input: 'forxxorfxdofr\norf', expected: '3' },
      { input: 'aabaabaa\naba', expected: '4' },
      { input: 'xyzzya\nxyz', expected: '1' },
    ],
    topics: ['string', 'sliding window', 'hash map'],
    interviewExcerpt:
      "You're processing a log stream at Google, detecting any anagram of a known signature in the data. Count how many matches occur quickly using sliding window + frequency tracking.",
    categories: ['string', 'sliding window'],
    difficulty: 'medium',
    frequency: 87,
    tags: ['sliding window', 'hash map', 'frequency counter', 'substring'],
    companies: [
      { name: 'GeeksforGeeks', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use a frequency map for the pattern.',
      "Use a sliding window of pattern's length over the text.",
      'Maintain a match count of how many required characters are satisfied.',
      'Update the map and match count efficiently when sliding the window.',
    ],
    optimalComplexity: {
      time: 'O(n + m)',
      space: 'O(1)', // constant-size map of lowercase letters
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const [text, pattern] = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  console.log(countAnagramOccurrences(text, pattern));\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    text, pattern = sys.stdin.read().strip().split('\\n')\n    print(count_anagram_occurrences(text, pattern))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String text = sc.nextLine();\n    String pattern = sc.nextLine();\n    System.out.println(countAnagramOccurrences(text, pattern));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint main() {\n  string text, pattern;\n  getline(cin, text);\n  getline(cin, pattern);\n  cout << countAnagramOccurrences(text, pattern);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function countAnagramOccurrences(text, pattern) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def count_anagram_occurrences(text, pattern):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int countAnagramOccurrences(String text, String pattern) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int countAnagramOccurrences(string text, string pattern) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Longest Palindromic Substring',
    slug: 'longest-palindromic-substring',
    description:
      'Find the longest contiguous substring in a string that reads the same backward as forward.',
    problemStatement:
      'Given a string `s`, return the longest palindromic substring in `s`.\n\n<pre><code>Input: s = "babad"\nOutput: "bab"  // Note: "aba" is also valid.\n\nInput: s = "cbbd"\nOutput: "bb"\n\nInput: s = "a"\nOutput: "a"\n\nInput: s = "ac"\nOutput: "a"  // or "c"</code></pre>\n\n<ul>\n<li>0 ≤ s.length ≤ 10⁵</li>\n<li>`s` consists of printable characters (letters, digits, symbols).</li>\n</ul>\n\nPro Tip – The most efficient solution uses **Manacher’s Algorithm**, which finds the longest palindromic substring in **O(n)** time. Simpler—but slower—alternatives include **center expansion** (O(n²)), and dynamic programming (O(n²) time and space).',
    sampleTestCases: [
      { input: 'babad', expected: '"bab" or "aba"' },
      { input: 'cbbd', expected: '"bb"' },
    ],
    testCases: [
      { input: 'a', expected: '"a"' },
      { input: 'ac', expected: '"a" or "c"' },
      { input: 'forgeeksskeegfor', expected: '"geeksskeeg"' },
      { input: 'abacdfgdcaba', expected: '"aba"' },
      { input: 'abacdedcaba', expected: '"abacdedcaba"' },
      { input: 'noonxyz', expected: 'noon"' },
      { input: 'abb', expected: 'bb' },
    ],
    topics: ['string', 'two pointer', 'advanced algorithm'],
    interviewExcerpt:
      "At Google, you're optimizing a text editor's search function. You need to identify the longest palindrome in a document efficiently — ideally in linear time.",
    categories: ['string', 'advanced'],
    difficulty: 'hard',
    frequency: 90,
    tags: ['Manacher', 'palindrome', 'string', 'sliding window'],
    companies: [
      { name: 'LeetCode', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Manacher’s Algorithm transforms the problem so both even- and odd-length palindromes can be handled uniformly by inserting special characters.',
      'Alternatively, you can expand around each center in O(n²) time, which may still pass for moderate n.',
      'DP solution builds a table dp[i][j] to mark substrings s[i..j] as palindromes.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const s = fs.readFileSync(0, 'utf-8').trim();\n  console.log(longestPalindrome(s));\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s = sys.stdin.read().strip()\n    print(longest_palindrome(s))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    System.out.println(longestPalindrome(s));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main(){string s;getline(cin,s);cout<<longestPalindrome(s);return 0;}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: "function longestPalindrome(s) {\n  // write Manacher's or expand-around-center\n}",
      },
      {
        language: 'python',
        code: 'def longest_palindrome(s):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static String longestPalindrome(String s) {\n    // implement here\n}',
      },
      {
        language: 'cpp',
        code: 'string longestPalindrome(string s) {\n    // implement here\n}',
      },
    ],
  },
  {
    title: 'Find All Palindromic Substrings',
    slug: 'find-all-palindromic-substrings',
    description:
      'Count and optionally list all palindromic substrings within a given string.',
    problemStatement:
      'Given a string `s`, return the total number of palindromic substrings in `s`. Optionally, also retrieve the actual substrings if needed.\n\n<pre><code>Input: s = "aaa"\nOutput: 6\nExplanation:\nSubstrings are "a", "a", "a", "aa", "aa", "aaa", all of which are palindromes.\n\nInput: s = "abc"\nOutput: 3\nExplanation: Substrings are "a", "b", "c".\n</code></pre>\n\n<ul>\n<li>1 ≤ s.length ≤ 10⁴ (for counting); listing substrings may be O(n²) output size.</li>\n<li>`s` consists of printable characters (letters, digits, symbols).</li>\n</ul>\n\nPro Tip – Use either:\n- **Center Expansion**: Expand around each character (odd-length) and between characters (even-length), totaling O(n²) time but O(1) space.\n- **Manacher’s Algorithm**: Achieves O(n) time to compute palindrome radii, enabling fast counting.\n- To **list all palindromes**, use center expansion and record each match.',
    sampleTestCases: [
      {
        input: 'aaa',
        expected: '6',
      },
      {
        input: 'aba',
        expected: '4',
      },
    ],
    testCases: [
      { input: 'a', expected: '1' },
      { input: 'abc', expected: '3' },
      { input: 'abaa', expected: '7' },
      { input: 'abccba', expected: '9' },
      { input: 'aaaab', expected: '10' },
      { input: 'racecar', expected: '10' },
      { input: 'ababa', expected: '9' },
      { input: 'abba', expected: '6' },
      { input: 'level', expected: '7' },
      { input: 'noon', expected: '6' },
    ],
    topics: ['string', 'palindrome', 'center expansion', 'Manacher'],
    interviewExcerpt:
      "At Google, you're optimizing a search feature and want to highlight every palindromic phrase typed by the user. How would you count or list them efficiently in real-time?",
    categories: ['string', 'two pointer', 'advanced'],
    difficulty: 'medium',
    frequency: 84,
    tags: ['palindromic substring', 'counting', 'center expansion', 'Manacher'],
    companies: [
      { name: 'LeetCode', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Expand around each index for odd-length palindromes, and around each gap for even-length.',
      'Or apply Manacher’s linear-time algorithm to get radii for palindromes centered at each position.',
      'Be cautious when listing substrings—you may generate O(n²) output even if counting is easier.',
    ],
    optimalComplexity: {
      time: 'O(n²) for center-expansion (O(n) for counting with Manacher)',
      space: 'O(1)',
    },
    solutionCount: 2,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const s = fs.readFileSync(0, 'utf-8').trim();\n  console.log(countPalindromicSubstrings(s));\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    s = sys.stdin.read().strip()\n    print(count_palindromic_substrings(s))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    System.out.println(countPalindromicSubstrings(s));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main(){string s;getline(cin,s);cout<<countPalindromicSubstrings(s);return 0;}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function countPalindromicSubstrings(s) {\n  // write center-expansion or Manacher here\n}',
      },
      {
        language: 'python',
        code: 'def count_palindromic_substrings(s):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int countPalindromicSubstrings(String s) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'int countPalindromicSubstrings(string s) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Implement strstr() / indexOf()',
    slug: 'implement-strstr',
    description:
      'Return the index of the first occurrence of the substring `needle` in the string `haystack`, or -1 if `needle` is not part of `haystack`.',
    problemStatement:
      'Implement `strStr(haystack, needle)` or `haystack.indexOf(needle)`.\n\n<pre><code>Input: haystack = "hello", needle = "ll"\nOutput: 2\n\nInput: haystack = "aaaaa", needle = "bba"\nOutput: -1\n\nInput: haystack = "", needle = ""\nOutput: 0</code></pre>\n\n<ul>\n<li>0 ≤ haystack.length, needle.length ≤ 10⁵</li>\n<li>Both strings consist of printable characters</li>\n</ul>\n\nPro Tip – For optimal performance, KMP (Knuth–Morris–Pratt) algorithm runs in **O(n + m)** time. For simpler implementations, a sliding window with direct comparisons can suffice in **O(n * m)** time.',
    sampleTestCases: [
      {
        input: 'hello\nll',
        expected: '2',
      },
      {
        input: 'aaaaa\nbba',
        expected: '-1',
      },
    ],
    testCases: [
      { input: 'abc\nc', expected: '2' },
      { input: 'mississippi\nissip', expected: '4' },
      { input: 'a\n', expected: '0' },
      { input: 'a\na', expected: '0' },
      { input: 'a\nb', expected: '-1' },
      { input: 'hello\n', expected: '0' },
      { input: 'abcd\nef', expected: '-1' },
      { input: 'abcdeabf\naab', expected: '5' },
      { input: 'abc\n', expected: '0' },
      { input: 'abc\nabc', expected: '0' },
    ],
    topics: ['string', 'pattern matching', 'KMP'],
    interviewExcerpt:
      "You're building a substring-search function for a text processing tool. Implement it efficiently—ideally with linear-time complexity.",
    categories: ['string', 'search'],
    difficulty: 'medium',
    frequency: 88,
    tags: ['string', 'KMP', 'sliding window', 'pattern search'],
    companies: [
      { name: 'LeetCode', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Handle edge cases first (empty strings).',
      'Use naive sliding window for simplicity or KMP for performance.',
      'Build the LPS (longest prefix-suffix) table for KMP.',
    ],
    optimalComplexity: {
      time: 'O(n + m)',
      space: 'O(m)', // for KMP's LPS array
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const [hay, needle] = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  console.log(strStr(hay, needle));\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys\nif __name__ == '__main__':\n    hay, needle = sys.stdin.read().strip().split('\\n')\n    print(str_str(hay, needle))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String hay = sc.nextLine();\n    String needle = sc.nextLine();\n    System.out.println(strStr(hay, needle));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main(){string hay,needle;getline(cin,hay);getline(cin,needle);cout<<strStr(hay,needle);return 0;}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function strStr(haystack, needle) {\n  // implement here\n}',
      },
      {
        language: 'python',
        code: 'def str_str(haystack, needle):\n    # implement here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int strStr(String haystack, String needle) {\n    // implement here\n}',
      },
      {
        language: 'cpp',
        code: 'int strStr(string haystack, string needle) {\n    // implement here\n}',
      },
    ],
  },
  {
    title: 'Rabin-Karp Pattern Search',
    slug: 'rabin-karp-pattern-search',
    description:
      'Search for all occurrences of a pattern in a text using the Rabin-Karp algorithm.',
    problemStatement: `Given a text string and a pattern string, implement the Rabin-Karp algorithm to find all starting indices where the pattern appears in the text. The Rabin-Karp algorithm uses hashing to efficiently match the pattern against substrings of the text.

Return all starting indices of pattern matches in ascending order.

<pre><code>Input: text = "abcabcabcd", pattern = "abc"
Output: [0, 3, 6]

Input: text = "aaaaa", pattern = "aa"
Output: [0, 1, 2, 3]

Input: text = "abcdef", pattern = "gh"
Output: []
</code></pre>

<ul>
<li>1 ≤ text.length, pattern.length ≤ 10<sup>5</sup></li>
<li>Pattern can appear multiple times and can overlap in the text</li>
<li>Output indices must be in ascending order</li>
<li>All characters are lowercase English letters</li>
</ul>

Pro Tip: Use a rolling hash to avoid recomputing hashes from scratch for each substring.
Pro Tip: Be cautious with hash collisions; handle them by verifying substrings when hashes match.`,
    sampleTestCases: [
      {
        input: 'abcabcabcd\nabc',
        expected: '0 3 6',
      },
      {
        input: 'aaaaa\naa',
        expected: '0 1 2 3',
      },
      {
        input: 'abcdef\ngh',
        expected: '',
      },
    ],
    testCases: [
      { input: 'a\na', expected: '0' },
      { input: 'a\nb', expected: '' },
      { input: 'abcabcabcabc\nabc', expected: '0 3 6 9' },
      { input: 'zzzzzzzzzz\nzz', expected: '0 1 2 3 4 5 6 7 8' },
      { input: 'abcdabcabcabcabcabcabc\nabc', expected: '0 4 7 10 13 16 19' },
      { input: 'abcdefghij\nijk', expected: '' },
      { input: 'aaaaabaaaaa\naaa', expected: '0 1 2 6 7' },
      { input: 'helloworldhellohello\nhello', expected: '0 10 15' },
      {
        input: 'patterngoesinpatternpatternpattern\npattern',
        expected: '0 13 20 27',
      },
      { input: 'ababababababab\naba', expected: '0 2 4 6 8 10' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're working at Google and are optimizing a search feature. Can you implement an efficient way to find all occurrences of a keyword (pattern) in a large body of text using the Rabin-Karp algorithm?",
    difficulty: 'medium',
    frequency: 78,
    tags: ['hashing', 'string', 'sliding window', 'rolling hash'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Precompute the hash of the pattern and initial hash of the first window in the text.',
      'Use a rolling hash technique to slide the window efficiently.',
      'Double-check matches to avoid false positives due to hash collisions.',
    ],
    optimalComplexity: {
      time: 'O(n + m)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const text = input[0];
  const pattern = input[1];
  const result = rabinKarp(text, pattern);
  console.log(result.join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    input_lines = sys.stdin.read().strip().split("\\n")
    text = input_lines[0]
    pattern = input_lines[1]
    result = rabin_karp(text, pattern)
    print(" ".join(map(str, result)))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String text = sc.nextLine();
    String pattern = sc.nextLine();
    List<Integer> res = RabinKarp.rabinKarp(text, pattern);
    for (int i = 0; i < res.size(); i++) {
      System.out.print(res.get(i));
      if (i != res.size() - 1) System.out.print(" ");
    }
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
#include <vector>
using namespace std;
int main() {
    string text, pattern;
    getline(cin, text);
    getline(cin, pattern);
    vector<int> result = rabinKarp(text, pattern);
    for (int i = 0; i < result.size(); ++i) {
        cout << result[i];
        if (i != result.size() - 1) cout << " ";
    }
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function rabinKarp(text, pattern) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def rabin_karp(text, pattern):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `import java.util.*;
class RabinKarp {
  public static List<Integer> rabinKarp(String text, String pattern) {
    // write code here
    return new ArrayList<>();
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <vector>
#include <string>
using namespace std;

vector<int> rabinKarp(const string &text, const string &pattern) {
    // write code here
    return {};
}`,
      },
    ],
  },
  {
    title: 'Knuth-Morris-Pratt (KMP) Pattern Search',
    slug: 'knuth-morris-pratt-kmp-pattern-search',
    description:
      'Search for all occurrences of a pattern in a text using the KMP string matching algorithm.',
    problemStatement: `Implement the Knuth-Morris-Pratt (KMP) algorithm to find all starting indices where a given pattern appears in a text. The KMP algorithm improves upon the naive string matching approach by precomputing a longest prefix-suffix (LPS) array to avoid unnecessary comparisons.

Return all starting indices of pattern matches in ascending order.

<pre><code>Input: text = "abxabcabcaby", pattern = "abcaby"
Output: [6]

Input: text = "aaaaa", pattern = "aa"
Output: [0, 1, 2, 3]

Input: text = "abcdef", pattern = "gh"
Output: []
</code></pre>

<ul>
<li>1 ≤ text.length, pattern.length ≤ 10<sup>5</sup></li>
<li>Pattern can appear multiple times and can overlap in the text</li>
<li>Output indices must be in ascending order</li>
<li>All characters are lowercase English letters</li>
</ul>

Pro Tip: Build the LPS (Longest Prefix Suffix) array before scanning the text to improve matching efficiency.
Pro Tip: This algorithm is especially useful when multiple pattern searches are needed on a long static text.`,
    sampleTestCases: [
      {
        input: 'abxabcabcaby\nabcaby',
        expected: '6',
      },
      {
        input: 'aaaaa\naa',
        expected: '0 1 2 3',
      },
      {
        input: 'abcdef\ngh',
        expected: '',
      },
    ],
    testCases: [
      { input: 'a\na', expected: '0' },
      { input: 'a\nb', expected: '' },
      { input: 'abcabcabcabc\nabc', expected: '0 3 6 9' },
      { input: 'zzzzzzzzzz\nzz', expected: '0 1 2 3 4 5 6 7 8' },
      { input: 'abcdabcabcabcabcabcabc\nabc', expected: '0 4 7 10 13 16 19' },
      { input: 'abcdefghij\nijk', expected: '' },
      { input: 'aaaaabaaaaa\naaa', expected: '0 1 2 6 7' },
      { input: 'helloworldhellohello\nhello', expected: '0 10 15' },
      {
        input: 'patterngoesinpatternpatternpattern\npattern',
        expected: '0 13 20 27',
      },
      { input: 'ababababababab\naba', expected: '0 2 4 6 8 10' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're designing a plagiarism detection tool at Adobe. You need to search for repeated sequences efficiently. Can you use the KMP algorithm to implement this functionality?",
    difficulty: 'medium',
    frequency: 81,
    tags: ['string', 'kmp', 'prefix', 'pattern matching'],
    companies: [
      { name: 'Adobe', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Build the LPS (Longest Prefix Suffix) array for the pattern.',
      'Use the LPS array to skip characters in the text during a mismatch.',
      "Don't re-check characters that are already known to match.",
    ],
    optimalComplexity: {
      time: 'O(n + m)',
      space: 'O(m)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const text = input[0];
  const pattern = input[1];
  const result = kmpSearch(text, pattern);
  console.log(result.join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    input_lines = sys.stdin.read().strip().split("\\n")
    text = input_lines[0]
    pattern = input_lines[1]
    result = kmp_search(text, pattern)
    print(" ".join(map(str, result)))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String text = sc.nextLine();
    String pattern = sc.nextLine();
    List<Integer> res = KMP.kmpSearch(text, pattern);
    for (int i = 0; i < res.size(); i++) {
      System.out.print(res.get(i));
      if (i != res.size() - 1) System.out.print(" ");
    }
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
#include <vector>
using namespace std;
int main() {
    string text, pattern;
    getline(cin, text);
    getline(cin, pattern);
    vector<int> result = kmpSearch(text, pattern);
    for (int i = 0; i < result.size(); ++i) {
        cout << result[i];
        if (i != result.size() - 1) cout << " ";
    }
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function kmpSearch(text, pattern) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def kmp_search(text, pattern):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `import java.util.*;
class KMP {
  public static List<Integer> kmpSearch(String text, String pattern) {
    // write code here
    return new ArrayList<>();
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <vector>
#include <string>
using namespace std;

vector<int> kmpSearch(const string &text, const string &pattern) {
    // write code here
    return {};
}`,
      },
    ],
  },
  {
    title: 'Z-Algorithm Pattern Search',
    slug: 'z-algorithm-pattern-search',
    description:
      'Search for all occurrences of a pattern in a text using the Z-Algorithm.',
    problemStatement: `Implement the Z-Algorithm to find all starting indices where a given pattern appears in a text. The Z-Algorithm computes a Z-array for efficient substring matching by leveraging string overlaps.

To use the Z-Algorithm for pattern search, concatenate the pattern, a special character (not in the text or pattern), and the text. Compute the Z-array on this combined string to find matches.

Return all starting indices of pattern matches in ascending order.

<pre><code>Input: text = "ababcababc", pattern = "abc"
Output: [2, 7]

Input: text = "aaaaa", pattern = "aa"
Output: [0, 1, 2, 3]

Input: text = "abcdef", pattern = "gh"
Output: []
</code></pre>

<ul>
<li>1 ≤ text.length, pattern.length ≤ 10<sup>5</sup></li>
<li>Pattern can appear multiple times and can overlap in the text</li>
<li>Output indices must be in ascending order</li>
<li>All characters are lowercase English letters</li>
</ul>

Pro Tip: Use a delimiter character (e.g., '$') that does not appear in the text or pattern to separate them for Z-array computation.
Pro Tip: This algorithm is very efficient for single pattern searches and also helpful in preprocessing for other problems.`,
    sampleTestCases: [
      {
        input: 'ababcababc\nabc',
        expected: '2 7',
      },
      {
        input: 'aaaaa\naa',
        expected: '0 1 2 3',
      },
      {
        input: 'abcdef\ngh',
        expected: '',
      },
    ],
    testCases: [
      { input: 'a\na', expected: '0' },
      { input: 'a\nb', expected: '' },
      { input: 'abcabcabcabc\nabc', expected: '0 3 6 9' },
      { input: 'zzzzzzzzzz\nzz', expected: '0 1 2 3 4 5 6 7 8' },
      { input: 'abcdabcabcabcabcabcabc\nabc', expected: '0 4 7 10 13 16 19' },
      { input: 'abcdefghij\nijk', expected: '' },
      { input: 'aaaaabaaaaa\naaa', expected: '0 1 2 6 7' },
      { input: 'helloworldhellohello\nhello', expected: '0 10 15' },
      {
        input: 'patterngoesinpatternpatternpattern\npattern',
        expected: '0 13 20 27',
      },
      { input: 'ababababababab\naba', expected: '0 2 4 6 8 10' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'At Amazon, you are designing a large-scale log monitoring tool. You need to detect certain key patterns across massive logs in real-time. Can you use the Z-algorithm for efficient pattern detection?',
    difficulty: 'medium',
    frequency: 77,
    tags: ['string', 'z-algorithm', 'pattern matching', 'preprocessing'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Oracle', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      "Construct a combined string: pattern + '$' + text.",
      'Compute the Z-array of the combined string.',
      'Look for Z-array values equal to the pattern length to find matches.',
    ],
    optimalComplexity: {
      time: 'O(n + m)',
      space: 'O(n + m)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const text = input[0];
  const pattern = input[1];
  const result = zAlgorithmSearch(text, pattern);
  console.log(result.join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    input_lines = sys.stdin.read().strip().split("\\n")
    text = input_lines[0]
    pattern = input_lines[1]
    result = z_algorithm_search(text, pattern)
    print(" ".join(map(str, result)))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String text = sc.nextLine();
    String pattern = sc.nextLine();
    List<Integer> res = ZAlgorithm.zAlgorithmSearch(text, pattern);
    for (int i = 0; i < res.size(); i++) {
      System.out.print(res.get(i));
      if (i != res.size() - 1) System.out.print(" ");
    }
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
#include <vector>
using namespace std;
int main() {
    string text, pattern;
    getline(cin, text);
    getline(cin, pattern);
    vector<int> result = zAlgorithmSearch(text, pattern);
    for (int i = 0; i < result.size(); ++i) {
        cout << result[i];
        if (i != result.size() - 1) cout << " ";
    }
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function zAlgorithmSearch(text, pattern) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def z_algorithm_search(text, pattern):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `import java.util.*;
class ZAlgorithm {
  public static List<Integer> zAlgorithmSearch(String text, String pattern) {
    // write code here
    return new ArrayList<>();
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <vector>
#include <string>
using namespace std;

vector<int> zAlgorithmSearch(const string &text, const string &pattern) {
    // write code here
    return {};
}`,
      },
    ],
  },
  {
    title: 'Wildcard Pattern Matching',
    slug: 'wildcard-pattern-matching',
    description:
      "Determine if a given text matches a wildcard pattern where '?' matches any single character and '*' matches any sequence (including empty).",
    problemStatement: `Given a text string <code>text</code> and a pattern string <code>pattern</code>, implement wildcard pattern matching where:
- '?' matches any single character.
- '*' matches any sequence of characters (including the empty sequence).

Return <code>true</code> if the pattern matches the entire text, otherwise return <code>false</code>.

<pre><code>Input: text = "abcde", pattern = "a?c*"
Output: true
Explanation: '?' matches 'b' and '*' matches "de".

Input: text = "baaabab", pattern = "a*ab"
Output: false
Explanation: The initial 'a' in pattern cannot match the starting 'b' in text.

Input: text = "abc", pattern = "*"
Output: true
Explanation: '*' matches the entire text "abc".
</code></pre>

<ul>
  <li>1 ≤ text.length, pattern.length ≤ 10<sup>3</sup></li>
  <li>Both strings consist of lowercase letters; <code>pattern</code> may also include '?' and '*'.</li>
  <li>Matching must cover the entire text—partial matches do not count.</li>
</ul>
Pro Tip: Use dynamic programming—define <code>dp[i][j]</code> to mean whether <code>text[i:]</code> matches <code>pattern[j:]</code>. Handle '?' and '*' carefully as special cases.`,
    sampleTestCases: [
      { input: 'abcde\na?c*', expected: 'true' },
      { input: 'baaabab\na*ab', expected: 'false' },
      { input: 'abc\n*', expected: 'true' },
    ],
    testCases: [
      { input: 'a\na', expected: 'true' },
      { input: 'a\n?', expected: 'true' },
      { input: 'ab\n?b', expected: 'true' },
      { input: 'ab\n?c', expected: 'false' },
      { input: 'abcdef\n*a?f', expected: 'true' },
      { input: 'abcdef\na*d?f', expected: 'false' },
      { input: 'xyzzz\n*?z', expected: 'true' },
      { input: 'xyzzz\n*?y', expected: 'false' },
      { input: 'aaa\na*a', expected: 'true' },
      { input: 'abc\n*****', expected: 'true' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You’re building a file search utility in Linux. You need to match filenames against wildcard patterns (with '?' and '*'). Can you implement an efficient algorithm to check if any filename fully matches a given pattern?",
    difficulty: 'medium',
    frequency: 65,
    tags: [
      'string',
      'dynamic programming',
      'wildcard matching',
      'pattern matching',
    ],
    companies: [
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use 2D dynamic programming: dp[i][j] = whether text[i:] matches pattern[j:].',
      "When encountering '*', consider both matching zero characters (skip '*') or one character (move forward in text).",
      "When encountering '?', simply match one character (if present), and move both pointers.",
    ],
    optimalComplexity: {
      time: 'O(n × m)',
      space: 'O(n × m)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const text = input[0];
  const pattern = input[1];
  const result = isMatch(text, pattern);
  console.log(result);
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    text = lines[0]
    pattern = lines[1]
    print(str(is_match(text, pattern)).lower())

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String text = sc.nextLine();
    String pattern = sc.nextLine();
    boolean res = Wildcard.isMatch(text, pattern);
    System.out.println(res);
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <bits/stdc++.h>
using namespace std;
int main(){
    string text, pattern;
    getline(cin, text);
    getline(cin, pattern);
    bool ans = isMatch(text, pattern);
    cout << (ans ? "true" : "false");
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function isMatch(text, pattern) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def is_match(text, pattern):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `import java.util.*;
class Wildcard {
  public static boolean isMatch(String text, String pattern) {
    // write code here
    return false;
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <string>
using namespace std;
bool isMatch(const string &text, const string &pattern) {
    // write code here
    return false;
}`,
      },
    ],
  },
  {
    title: 'Check Subsequence',
    slug: 'check-subsequence',
    description: 'Determine if one string is a subsequence of another.',
    problemStatement: `Given two strings <code>s</code> and <code>t</code>, determine if <code>s</code> is a subsequence of <code>t</code>. A subsequence is a sequence that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

Return <code>true</code> if <code>s</code> is a subsequence of <code>t</code>, otherwise return <code>false</code>.

<pre><code>Input: s = "abc", t = "ahbgdc"
Output: true

Input: s = "axc", t = "ahbgdc"
Output: false

Input: s = "", t = "anystring"
Output: true
</code></pre>

<ul>
  <li>0 ≤ s.length ≤ 10<sup>5</sup></li>
  <li>1 ≤ t.length ≤ 10<sup>5</sup></li>
  <li>Both strings consist of lowercase English letters only.</li>
</ul>

Pro Tip: Use two pointers to traverse both strings and compare characters greedily.`,
    sampleTestCases: [
      { input: 'abc\nahbgdc', expected: 'true' },
      { input: 'axc\nahbgdc', expected: 'false' },
      { input: '\nabc', expected: 'true' },
    ],
    testCases: [
      { input: 'a\na', expected: 'true' },
      { input: 'a\nb', expected: 'false' },
      { input: 'ace\nabcde', expected: 'true' },
      { input: 'aec\nabcde', expected: 'false' },
      { input: 'abc\nabc', expected: 'true' },
      { input: 'abc\nacb', expected: 'false' },
      { input: 'abc\nabdbc', expected: 'true' },
      { input: 'abc\nabdc', expected: 'false' },
      { input: 'abc\nabcdabc', expected: 'true' },
      { input: 'longsubsequence\nlongsubsequence', expected: 'true' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're working on a content filter at Netflix. Before recommending similar titles, you need to verify if a keyword sequence appears in a user's search query in the same order. Can you check if one string is a subsequence of another?",
    difficulty: 'easy',
    frequency: 86,
    tags: ['two pointer', 'string', 'greedy'],
    companies: [
      { name: 'Netflix', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Use two pointers, one for each string.',
      "Only advance the subsequence pointer when there's a character match.",
      "If the subsequence pointer reaches the end, it's a match.",
    ],
    optimalComplexity: {
      time: 'O(n + m)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").split("\\n");
  const s = input[0];
  const t = input[1];
  const result = isSubsequence(s, t);
  console.log(result);
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    lines = sys.stdin.read().split("\\n")
    s = lines[0]
    t = lines[1]
    print(str(is_subsequence(s, t)).lower())

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String s = sc.nextLine();
    String t = sc.nextLine();
    boolean result = SubsequenceChecker.isSubsequence(s, t);
    System.out.println(result);
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
using namespace std;
int main() {
    string s, t;
    getline(cin, s);
    getline(cin, t);
    cout << (isSubsequence(s, t) ? "true" : "false");
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function isSubsequence(s, t) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def is_subsequence(s, t):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class SubsequenceChecker {
  public static boolean isSubsequence(String s, String t) {
    // write code here
    return false;
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <string>
using namespace std;
bool isSubsequence(const string &s, const string &t) {
    // write code here
    return false;
}`,
      },
    ],
  },
  {
    title: 'Shortest Uncommon Subsequence',
    slug: 'shortest-uncommon-subsequence',
    description:
      'Find the length of the shortest subsequence in one string which is not a subsequence in another.',
    problemStatement: `Given two strings <code>S</code> and <code>T</code>, find the length of the shortest subsequence in <code>S</code> which is not a subsequence of <code>T</code>. If no such subsequence exists, return <code>-1</code>.

A subsequence is a sequence that appears in the same relative order, but is not necessarily contiguous.

Example:
<pre><code>Input:
S = "babab"
T = "babba"
Output: 3
Explanation: The subsequence "aab" (length 3) appears in S but not in T.

Input:
S = "abb"
T = "abab"
Output: -1
Explanation: Every subsequence of S appears in T.</code></pre>

<ul>
  <li>1 ≤ |S|, |T| ≤ 1000</li>
  <li>All characters are lowercase English letters.</li>
</ul>

Strategy:
<ul>
  <li>Define a DP function <code>dp(i, j)</code> representing the length of the shortest subsequence of <code>S[i:...]</code> that is not a subsequence of <code>T[j:...]</code>, or a special large value (INF) if none exists.</li>
  <li>Base cases:
    <ul>
      <li>If <code>i</code> reaches the end of S (<code>i === |S|</code>), return INF (no subsequence possible).</li>
      <li>If <code>j</code> reaches the end of T (<code>j === |T|</code>), return 1 (any character S[i] works).</li>
    </ul>
  </li>
  <li>Transition:
    <ul>
      <li>Option 1: Skip <code>S[i]</code> → result = <code>dp(i+1, j)</code>.</li>
      <li>Option 2: Find the next occurrence <code>k</code> of <code>S[i]</code> in <code>T[j:...]</code>. If not found, answer = 1. Otherwise, answer = 1 + <code>dp(i+1, k+1)</code>.</li>
    </ul>
  </li>
  <li>Take the minimum of both options. If result ≥ INF, return -1; otherwise, return result.</li>
</ul>

Pro Tip: Implement this with memoization or tabulation to keep time complexity at O(m × n × α) where α is the cost of locating the next occurrence (can be optimized using preprocessing).`,
    sampleTestCases: [
      {
        input: 'babab\nbabba',
        expected: '3',
      },
      {
        input: 'abb\nabab',
        expected: '-1',
      },
    ],
    testCases: [
      { input: 'a\na', expected: '-1' },
      { input: 'a\nb', expected: '1' },
      { input: 'abc\nd', expected: '1' },
      { input: 'aaa\na', expected: '-1' },
      { input: 'abcd\nabc', expected: '1' },
      { input: 'babab\nbabba', expected: '3' },
      { input: 'abb\nabab', expected: '-1' },
      { input: 'xyz\naxyz', expected: '-1' },
      { input: 'xyz\nab', expected: '1' },
      { input: 'leetcode\nleet', expected: '1' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're building a diff tool that identifies minimal patterns in code A that are not found in code B to flag unique fragments. Can you compute the shortest subsequence in one string that isn’t contained as a subsequence in another using efficient DP?",
    difficulty: 'hard',
    frequency: 42,
    tags: [
      'dynamic programming',
      'string',
      'subsequence',
      'DP with preprocessing',
    ],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Define dp(i, j) carefully—think of slicing the strings.',
      'Use INF to represent impossible states.',
      "Optimize finding next occurrence of characters in T using a preprocessed 'next index' table.",
    ],
    optimalComplexity: {
      time: 'O(m × n × σ) or O(m × n)',
      space: 'O(m × n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");

const INF = 1005;
function shortestUncommonSubsequence(S, T) {
  const m = S.length, n = T.length;
  // Prepare next-position table to locate next occurrence of each char in T
  const nextPos = Array.from({ length: n + 1 }, () => Array(26).fill(-1));
  for (let c = 0; c < 26; c++) {
    nextPos[n][c] = -1;
  }
  for (let i = n - 1; i >= 0; i--) {
    for (let c = 0; c < 26; c++) {
      nextPos[i][c] = nextPos[i + 1][c];
    }
    nextPos[i][T.charCodeAt(i) - 97] = i;
  }

  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(INF));
  for (let i = 0; i <= m; i++) dp[i][n] = 1;
  for (let j = 0; j <= n; j++) dp[m][j] = INF;

  for (let i = m - 1; i >= 0; i--) {
    for (let j = n - 1; j >= 0; j--) {
      const c = S.charCodeAt(i) - 97;
      const next = nextPos[j][c];
      const skip = dp[i + 1][j];
      const take = next === -1 ? 1 : 1 + dp[i + 1][next + 1];
      dp[i][j] = Math.min(skip, take);
    }
  }
  const ans = dp[0][0];
  return ans >= INF ? -1 : ans;
}

function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const S = input[0];
  const T = input[1];
  console.log(shortestUncommonSubsequence(S, T));
}
main();`,
      },
      {
        language: 'python',
        code: `INF = 1005
def shortest_uncommon_subsequence(S, T):
    m, n = len(S), len(T)
    next_pos = [[-1] * 26 for _ in range(n + 1)]
    for c in range(26):
        next_pos[n][c] = -1
    for i in range(n - 1, -1, -1):
        next_pos[i] = next_pos[i + 1].copy()
        next_pos[i][ord(T[i]) - 97] = i

    dp = [[INF] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        dp[i][n] = 1
    for j in range(n + 1):
        dp[m][j] = INF

    for i in range(m - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            c = ord(S[i]) - 97
            nxt = next_pos[j][c]
            skip = dp[i + 1][j]
            take = 1 if nxt == -1 else 1 + dp[i + 1][nxt + 1]
            dp[i][j] = min(skip, take)

    return -1 if dp[0][0] >= INF else dp[0][0]`,
      },
      {
        language: 'java',
        code: `class Solution {
    private static final int INF = 1005;
    public int shortestUncommonSubsequence(String S, String T) {
        int m = S.length(), n = T.length();
        int[][] nextPos = new int[n + 1][26];
        for (int c = 0; c < 26; c++) nextPos[n][c] = -1;
        for (int i = n - 1; i >= 0; i--) {
            for (int c = 0; c < 26; c++) nextPos[i][c] = nextPos[i + 1][c];
            nextPos[i][T.charAt(i) - 'a'] = i;
        }
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i <= m; i++) dp[i][n] = 1;
        for (int j = 0; j <= n; j++) dp[m][j] = INF;
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                int c = S.charAt(i) - 'a';
                int nxt = nextPos[j][c];
                int skip = dp[i + 1][j];
                int take = nxt == -1 ? 1 : 1 + dp[i + 1][nxt + 1];
                dp[i][j] = Math.min(skip, take);
            }
        }
        return dp[0][0] >= INF ? -1 : dp[0][0];
    }
}`,
      },
      {
        language: 'cpp',
        code: `#include <bits/stdc++.h>
using namespace std;
const int INF = 1005;
int shortestUncommonSubsequence(const string &S, const string &T) {
    int m = S.size(), n = T.size();
    vector<vector<int>> nextPos(n + 1, vector<int>(26, -1));
    for (int i = n - 1; i >= 0; i--) {
        nextPos[i] = nextPos[i + 1];
        nextPos[i][T[i] - 'a'] = i;
    }
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INF));
    for (int i = 0; i <= m; i++) dp[i][n] = 1;
    for (int j = 0; j <= n; j++) dp[m][j] = INF;
    for (int i = m - 1; i >= 0; i--) {
        for (int j = n - 1; j >= 0; j--) {
            int c = S[i] - 'a';
            int nxt = nextPos[j][c];
            int skip = dp[i + 1][j];
            int take = (nxt == -1) ? 1 : 1 + dp[i + 1][nxt + 1];
            dp[i][j] = min(skip, take);
        }
    }
    return dp[0][0] >= INF ? -1 : dp[0][0];
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function shortestUncommonSubsequence(S, T) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def shortest_uncommon_subsequence(S, T):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class Solution {
    public int shortestUncommonSubsequence(String S, String T) {
        // write code here
        return -1;
    }
}`,
      },
      {
        language: 'cpp',
        code: `int shortestUncommonSubsequence(const string &S, const string &T) {
    // write code here
    return -1;
}`,
      },
    ],
  },
  {
    title: 'Longest Prefix Suffix',
    slug: 'longest-prefix-suffix',
    description:
      'Find the length of the longest proper prefix of a string which is also a suffix.',
    problemStatement: `Given a string <code>s</code>, find the length of the longest proper prefix which is also a suffix.

A proper prefix is a prefix that is not equal to the entire string. The prefix and suffix should not overlap completely.

<pre><code>Input: s = "abab"
Output: 2
Explanation: "ab" is both prefix and suffix.

Input: s = "aaaa"
Output: 3
Explanation: "aaa" is both prefix and suffix.

Input: s = "abc"
Output: 0
Explanation: No proper prefix that is also a suffix.
</code></pre>

<ul>
  <li>1 ≤ s.length ≤ 10<sup>5</sup></li>
  <li>All characters are lowercase English letters.</li>
</ul>

Pro Tip: This problem is often solved using the LPS array used in the KMP algorithm.`,
    sampleTestCases: [
      { input: 'abab', expected: '2' },
      { input: 'aaaa', expected: '3' },
      { input: 'abc', expected: '0' },
    ],
    testCases: [
      { input: 'a', expected: '0' },
      { input: 'aa', expected: '1' },
      { input: 'abcab', expected: '2' },
      { input: 'abcdabc', expected: '0' },
      { input: 'abcabc', expected: '3' },
      { input: 'ababab', expected: '4' },
      { input: 'aabbaabb', expected: '4' },
      { input: 'aaaaa', expected: '4' },
      { input: 'abacabab', expected: '3' },
      { input: 'xyzxyzxy', expected: '3' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're implementing a text search feature at Google Docs. To optimize repeated pattern checks, you need a function that finds the length of the longest proper prefix which is also a suffix. Can you implement it efficiently?",
    difficulty: 'easy',
    frequency: 71,
    tags: ['kmp', 'string', 'prefix suffix', 'lps array'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Flipkart', logoUrl: '' },
    ],
    hints: [
      'Use the LPS (Longest Prefix Suffix) array concept from KMP.',
      'LPS[i] stores the length of the longest proper prefix which is also suffix for substring s[0...i].',
      'You only need the last value of the LPS array.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const s = fs.readFileSync(0, "utf-8").trim();
  const result = longestPrefixSuffix(s);
  console.log(result);
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    s = sys.stdin.read().strip()
    print(longest_prefix_suffix(s))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String s = sc.nextLine();
    int res = PrefixSuffix.longestPrefixSuffix(s);
    System.out.println(res);
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
using namespace std;
int main() {
    string s;
    getline(cin, s);
    cout << longestPrefixSuffix(s);
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function longestPrefixSuffix(s) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def longest_prefix_suffix(s):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class PrefixSuffix {
  public static int longestPrefixSuffix(String s) {
    // write code here
    return 0;
  }
}`,
      },
      {
        language: 'cpp',
        code: `int longestPrefixSuffix(const string &s) {
    // write code here
    return 0;
}`,
      },
    ],
  },
  {
    title: 'Minimum Insertions to Make Palindrome',
    slug: 'minimum-insertions-to-make-palindrome',
    description:
      'Find the minimum number of insertions required to make a string a palindrome.',
    problemStatement: `Given a string <code>s</code>, return the minimum number of insertions required to make it a palindrome. You can insert characters at any position in the string.

<pre><code>Input: s = "ab"
Output: 1
Explanation: Insert 'a' after 'b' to make "aba".

Input: s = "aa"
Output: 0
Explanation: Already a palindrome.

Input: s = "abcda"
Output: 2
Explanation: "abcdcba" or "adbcbda" are examples of valid results.
</code></pre>

<ul>
  <li>1 ≤ s.length ≤ 500</li>
  <li>All characters are lowercase English letters.</li>
</ul>

Pro Tip: Use dynamic programming to find the length of the longest palindromic subsequence (LPS). The number of insertions needed is <code>n - LPS</code>.`,
    sampleTestCases: [
      { input: 'ab', expected: '1' },
      { input: 'aa', expected: '0' },
      { input: 'abcda', expected: '2' },
    ],
    testCases: [
      { input: 'a', expected: '0' },
      { input: 'ab', expected: '1' },
      { input: 'race', expected: '3' },
      { input: 'google', expected: '2' },
      { input: 'abcba', expected: '0' },
      { input: 'abcde', expected: '4' },
      { input: 'abcdc', expected: '1' },
      { input: 'abbac', expected: '1' },
      { input: 'civic', expected: '0' },
      { input: 'madamimadam', expected: '0' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You are working at Meta on a chat feature that auto-corrects symmetric emoji sequences. You need to calculate the minimum insertions required to transform a string into a palindrome. Can you optimize this with dynamic programming?',
    difficulty: 'medium',
    frequency: 66,
    tags: ['dp', 'string', 'palindrome', 'lps'],
    companies: [
      { name: 'Meta', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Find the longest palindromic subsequence (LPS).',
      'The difference between the string length and LPS gives the minimum insertions.',
      'Use a DP table where dp[i][j] represents the LPS in s[i...j].',
    ],
    optimalComplexity: {
      time: 'O(n^2)',
      space: 'O(n^2)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const s = fs.readFileSync(0, "utf-8").trim();
  const result = minInsertions(s);
  console.log(result);
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    s = sys.stdin.read().strip()
    print(min_insertions(s))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String s = sc.nextLine();
    int res = Palindrome.minInsertions(s);
    System.out.println(res);
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
using namespace std;
int main() {
    string s;
    getline(cin, s);
    cout << minInsertions(s);
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function minInsertions(s) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def min_insertions(s):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class Palindrome {
  public static int minInsertions(String s) {
    // write code here
    return 0;
  }
}`,
      },
      {
        language: 'cpp',
        code: `int minInsertions(const string &s) {
    // write code here
    return 0;
}`,
      },
    ],
  },
  {
    title: 'First Non-Repeating Character',
    slug: 'first-non-repeating-character',
    description:
      'Find the index of the first non-repeating character in a string.',
    problemStatement: `Given a string <code>s</code>, return the index of the first non-repeating character. If there is no such character, return <code>-1</code>.

<pre><code>Input: s = "leetcode"
Output: 0

Input: s = "loveleetcode"
Output: 2

Input: s = "aabb"
Output: -1
</code></pre>

<ul>
  <li>1 ≤ s.length ≤ 10<sup>5</sup></li>
  <li>s consists of lowercase English letters.</li>
</ul>

Pro Tip: Use a frequency counter to track character counts and iterate once more to find the first character with frequency 1.`,
    sampleTestCases: [
      { input: 'leetcode', expected: '0' },
      { input: 'loveleetcode', expected: '2' },
      { input: 'aabb', expected: '-1' },
    ],
    testCases: [
      { input: 'a', expected: '0' },
      { input: 'aa', expected: '-1' },
      { input: 'abc', expected: '0' },
      { input: 'aabbccddeeffg', expected: '12' },
      { input: 'zxyxz', expected: '1' },
      { input: 'abcabc', expected: '-1' },
      { input: 'abacabad', expected: '6' },
      { input: 'abababab', expected: '-1' },
      { input: 'abcdeabc', expected: '3' },
      { input: 'aabbccddee', expected: '-1' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re designing an editor feature at Google Docs. It needs to highlight the first non-repeating character in a paragraph for grammar assistance. How would you determine the index of that character efficiently?',
    difficulty: 'easy',
    frequency: 92,
    tags: ['hash map', 'string', 'queue', 'character frequency'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Meta', logoUrl: '' },
    ],
    hints: [
      'Use a hash map to count character frequencies.',
      'Then, scan the string to find the first character with frequency one.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const s = fs.readFileSync(0, "utf-8").trim();
  const result = firstUniqChar(s);
  console.log(result);
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    s = sys.stdin.read().strip()
    print(first_unique_char(s))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String s = sc.nextLine();
    int res = UniqueChar.firstUniqChar(s);
    System.out.println(res);
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
using namespace std;
int main() {
    string s;
    getline(cin, s);
    cout << firstUniqChar(s);
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function firstUniqChar(s) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def first_unique_char(s):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class UniqueChar {
  public static int firstUniqChar(String s) {
    // write code here
    return -1;
  }
}`,
      },
      {
        language: 'cpp',
        code: `int firstUniqChar(const string &s) {
    // write code here
    return -1;
}`,
      },
    ],
  },
  {
    title: 'Group Anagrams',
    slug: 'group-anagrams',
    description:
      'Group strings that are anagrams of each other into separate groups.',
    problemStatement: `Given an array of strings <code>strs</code>, group the anagrams together. You may return the result in any order.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, using all original letters exactly once.

<pre><code>Input: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
Output: [["eat","tea","ate"],["tan","nat"],["bat"]]

Input: strs = [""]
Output: [[""]]

Input: strs = ["a"]
Output: [["a"]]
</code></pre>

<ul>
  <li>1 ≤ strs.length ≤ 10<sup>4</sup></li>
  <li>0 ≤ strs[i].length ≤ 100</li>
  <li><code>strs[i]</code> consists of lowercase English letters.</li>
</ul>

Pro Tip: Use a hash map with the sorted version of each string as the key to group anagrams efficiently.`,
    sampleTestCases: [
      {
        input: '6\neat tea tan ate nat bat',
        expected: 'eat tea ate\ntan nat\nbat',
      },
      { input: '1\n', expected: '' },
      { input: '1\na', expected: 'a' },
    ],
    testCases: [
      { input: '3\nabc bca cab', expected: 'abc bca cab' },
      { input: '2\na a', expected: 'a a' },
      { input: '5\nabc def ghi jkl mno', expected: 'abc\ndef\nghi\njkl\nmno' },
      { input: '4\nabcd bcda cadb dabc', expected: 'abcd bcda cadb dabc' },
      {
        input: '6\nrat tar art car arc rac',
        expected: 'rat tar art\ncar arc rac',
      },
      { input: '3\nxyz xzy zyx', expected: 'xyz xzy zyx' },
      { input: '2\nabcd dcba', expected: 'abcd dcba' },
      { input: '4\nabc bcd cde def', expected: 'abc\nbcd\ncde\ndef' },
      { input: '3\nabc aab baa', expected: 'abc\naab baa' },
      { input: '2\naaa aaa', expected: 'aaa aaa' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're building a word game at Facebook where players must find anagram groups. Given a list of words, can you cluster all words that are anagrams of each other?",
    difficulty: 'medium',
    frequency: 89,
    tags: ['hash map', 'string', 'sorting', 'anagram'],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Sort each string and use the sorted string as a key in a map.',
      'Group original strings under each sorted string key.',
    ],
    optimalComplexity: {
      time: 'O(n * k log k)',
      space: 'O(n * k)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(input[0]);
  const strs = input[1].split(" ");
  const result = groupAnagrams(strs);
  result.forEach(group => console.log(group.join(" ")));
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    lines = sys.stdin.read().split("\\n")
    n = int(lines[0])
    strs = lines[1].split()
    result = group_anagrams(strs)
    for group in result:
        print(" ".join(group))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = Integer.parseInt(sc.nextLine());
    String[] strs = sc.nextLine().split(" ");
    List<List<String>> res = Anagram.groupAnagrams(strs);
    for (List<String> group : res) {
      System.out.println(String.join(" ", group));
    }
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n;
    cin >> n;
    vector<string> strs(n);
    for (int i = 0; i < n; ++i) cin >> strs[i];
    vector<vector<string>> result = groupAnagrams(strs);
    for (auto &group : result) {
        for (auto &word : group) cout << word << " ";
        cout << "\\n";
    }
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function groupAnagrams(strs) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def group_anagrams(strs):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `import java.util.*;
class Anagram {
  public static List<List<String>> groupAnagrams(String[] strs) {
    // write code here
    return new ArrayList<>();
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <vector>
#include <string>
using namespace std;

vector<vector<string>> groupAnagrams(const vector<string> &strs) {
    // write code here
    return {};
}`,
      },
    ],
  },
  {
    title: 'Rearrange String with No Adjacent Same Characters',
    slug: 'rearrange-string-no-adjacent-same',
    description:
      'Rearrange a string so that no two adjacent characters are the same.',
    problemStatement: `Given a string <code>s</code>, rearrange its characters so that no two adjacent characters are the same. If such an arrangement is possible, return any valid rearranged string. If not, return an empty string.

<pre><code>Input: s = "aab"
Output: "aba"

Input: s = "aaab"
Output: ""

Input: s = "aaabbc"
Output: "ababac" or similar valid output
</code></pre>

<ul>
  <li>1 ≤ s.length ≤ 10<sup>5</sup></li>
  <li>s consists of lowercase English letters.</li>
</ul>

Pro Tip: Use a max heap to always place the most frequent character next, while temporarily skipping the last used character.`,
    sampleTestCases: [
      { input: 'aab', expected: 'aba' },
      { input: 'aaab', expected: '' },
      { input: 'aaabbc', expected: 'ababac' },
    ],
    testCases: [
      { input: 'a', expected: 'a' },
      { input: 'aa', expected: '' },
      { input: 'abc', expected: 'abc' },
      { input: 'aaaabc', expected: '' },
      { input: 'aabbcc', expected: 'abcabc' },
      { input: 'aaaabbcc', expected: 'ababacab' },
      { input: 'aaabc', expected: 'abaca' },
      { input: 'aaabbb', expected: 'ababab' },
      { input: 'aabbccddee', expected: 'abcdeabcde' },
      { input: 'zzzzzzaa', expected: '' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're optimizing a text editor's suggestion engine at Microsoft. The requirement is to avoid displaying two identical suggestions next to each other. Can you rearrange a suggestion string such that no two adjacent characters are the same?",
    difficulty: 'medium',
    frequency: 84,
    tags: ['heap', 'greedy', 'string', 'priority queue'],
    companies: [
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use a max heap to always pick the character with the highest frequency.',
      "Temporarily store the previously used character so it isn't reused immediately.",
      "Check if any character’s frequency exceeds (n+1)/2 — if so, it's impossible.",
    ],
    optimalComplexity: {
      time: 'O(n log k)',
      space: 'O(k)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const s = fs.readFileSync(0, "utf-8").trim();
  const result = rearrangeString(s);
  console.log(result);
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    s = sys.stdin.read().strip()
    print(rearrange_string(s))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String s = sc.nextLine();
    String res = Rearranger.rearrangeString(s);
    System.out.println(res);
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
using namespace std;
int main() {
    string s;
    getline(cin, s);
    cout << rearrangeString(s);
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function rearrangeString(s) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def rearrange_string(s):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class Rearranger {
  public static String rearrangeString(String s) {
    // write code here
    return "";
  }
}`,
      },
      {
        language: 'cpp',
        code: `string rearrangeString(const string &s) {
    // write code here
    return "";
}`,
      },
    ],
  },
  {
    title: 'Longest Common Prefix',
    slug: 'longest-common-prefix',
    description:
      'Find the longest common prefix string among an array of strings.',
    problemStatement: `Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

<pre><code>Input: strs = ["flower","flow","flight"]
Output: "fl"

Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.

Input: strs = ["interspecies","interstellar","interstate"]
Output: "inters"
</code></pre>

<ul>
  <li>1 ≤ strs.length ≤ 200</li>
  <li>0 ≤ strs[i].length ≤ 200</li>
  <li><code>strs[i]</code> consists only of lowercase English letters.</li>
</ul>

Pro Tip: Compare characters across all strings at each index until a mismatch is found.`,
    sampleTestCases: [
      { input: '3\nflower flow flight', expected: 'fl' },
      { input: '3\ndog racecar car', expected: '' },
      { input: '3\ninterspecies interstellar interstate', expected: 'inters' },
    ],
    testCases: [
      { input: '3\nabc abc abc', expected: 'abc' },
      { input: '2\nabc ab', expected: 'ab' },
      { input: '3\na ab abc', expected: 'a' },
      { input: '3\nabc def ghi', expected: '' },
      { input: '2\nprefix prefixsuffix', expected: 'prefix' },
      { input: '1\nunique', expected: 'unique' },
      { input: '3\nflaw flow flown', expected: 'fl' },
      { input: '3\n', expected: '' },
      { input: '2\ninter internal', expected: 'inter' },
      { input: '3\na a a', expected: 'a' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're developing a predictive typing feature at Google Keyboard. To speed up suggestions, you need to compute the longest shared prefix across multiple typed inputs. Can you implement this efficiently?",
    difficulty: 'easy',
    frequency: 93,
    tags: ['string', 'prefix', 'trie', 'vertical scan'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Start by assuming the entire first string is the prefix.',
      'Iteratively shorten the prefix by comparing it to each string.',
    ],
    optimalComplexity: {
      time: 'O(n * m)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(input[0]);
  const strs = input[1].split(" ");
  const result = longestCommonPrefix(strs);
  console.log(result);
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0])
    strs = lines[1].split()
    print(longest_common_prefix(strs))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = Integer.parseInt(sc.nextLine());
    String[] strs = sc.nextLine().split(" ");
    String res = Prefix.longestCommonPrefix(strs);
    System.out.println(res);
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n;
    cin >> n;
    vector<string> strs(n);
    for (int i = 0; i < n; ++i) cin >> strs[i];
    cout << longestCommonPrefix(strs);
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function longestCommonPrefix(strs) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def longest_common_prefix(strs):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class Prefix {
  public static String longestCommonPrefix(String[] strs) {
    // write code here
    return "";
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <string>
#include <vector>
using namespace std;
string longestCommonPrefix(const vector<string> &strs) {
    // write code here
    return "";
}`,
      },
    ],
  },
  {
    title: 'Valid Parentheses',
    slug: 'valid-parentheses',
    description:
      'Determine if the input string has valid open and close parentheses.',
    problemStatement: `Given a string <code>s</code> containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code>, and <code>']'</code>, determine if the input string is valid.

A string is valid if:
<ul>
  <li>Open brackets are closed by the same type of brackets.</li>
  <li>Open brackets are closed in the correct order.</li>
</ul>

<pre><code>Input: s = "()"
Output: true

Input: s = "()[]{}"
Output: true

Input: s = "(]"
Output: false
</code></pre>

<ul>
  <li>1 ≤ s.length ≤ 10<sup>4</sup></li>
  <li>s consists only of <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code>, and <code>']'</code>.</li>
</ul>

Pro Tip: Use a stack to track opening brackets and match them with the closing brackets.`,
    sampleTestCases: [
      { input: '()', expected: 'true' },
      { input: '()[]{}', expected: 'true' },
      { input: '(]', expected: 'false' },
    ],
    testCases: [
      { input: '[]', expected: 'true' },
      { input: '{[]}', expected: 'true' },
      { input: '([)]', expected: 'false' },
      { input: '{[()]}', expected: 'true' },
      { input: '{[(])}', expected: 'false' },
      { input: '(', expected: 'false' },
      { input: ')', expected: 'false' },
      { input: '', expected: 'true' },
      { input: '((()))', expected: 'true' },
      { input: '(()', expected: 'false' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're building a compiler at Amazon and need to validate code blocks. Can you write a function that checks whether brackets in a given snippet are balanced?",
    difficulty: 'easy',
    frequency: 97,
    tags: ['stack', 'string', 'bracket matching'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Meta', logoUrl: '' },
    ],
    hints: [
      'Use a stack to store opening brackets.',
      'Pop the stack when a closing bracket is encountered and ensure it matches.',
      'Return false early if any mismatch or leftover exists.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const s = fs.readFileSync(0, "utf-8").trim();
  console.log(isValid(s));
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    s = sys.stdin.read().strip()
    print(str(is_valid(s)).lower())

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String s = sc.nextLine();
    System.out.println(ParenthesesValidator.isValid(s));
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
using namespace std;
int main() {
    string s;
    getline(cin, s);
    cout << (isValid(s) ? "true" : "false");
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function isValid(s) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def is_valid(s):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class ParenthesesValidator {
  public static boolean isValid(String s) {
    // write code here
    return false;
  }
}`,
      },
      {
        language: 'cpp',
        code: `bool isValid(const string &s) {
    // write code here
    return false;
}`,
      },
    ],
  },
  {
    title: 'Remove All Adjacent Duplicates in String',
    slug: 'remove-all-adjacent-duplicates-in-string',
    description:
      'Remove adjacent duplicate characters repeatedly until no more adjacent duplicates exist.',
    problemStatement: `Given a string <code>s</code>, repeatedly remove all adjacent duplicates in the string until no adjacent duplicates remain.

Return the final string after all such duplicate removals have been performed.

<pre><code>Input: s = "abbaca"
Output: "ca"
Explanation:
- "abbaca" → remove "bb" → "aaca"
- "aaca" → remove "aa" → "ca"

Input: s = "azxxzy"
Output: "ay"
</code></pre>

<ul>
  <li>1 ≤ s.length ≤ 10<sup>5</sup></li>
  <li><code>s</code> consists of lowercase English letters.</li>
</ul>

Pro Tip: Use a stack or simulate a stack with a list/array to remove adjacent pairs efficiently.`,
    sampleTestCases: [
      { input: 'abbaca', expected: 'ca' },
      { input: 'azxxzy', expected: 'ay' },
      { input: 'a', expected: 'a' },
    ],
    testCases: [
      { input: 'aa', expected: '' },
      { input: 'abba', expected: '' },
      { input: 'abc', expected: 'abc' },
      { input: 'aabbaa', expected: '' },
      { input: 'mississippi', expected: 'm' },
      { input: 'abccba', expected: '' },
      { input: 'aabbccddeeff', expected: '' },
      { input: 'abcddcba', expected: '' },
      { input: 'abcdddcba', expected: 'a' },
      { input: 'aabbccddeeffgg', expected: '' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're building a text cleanup tool for WhatsApp to remove adjacent repeated characters automatically while a user types. Can you implement a function that processes this efficiently?",
    difficulty: 'easy',
    frequency: 91,
    tags: ['stack', 'string', 'simulation'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Meta', logoUrl: '' },
    ],
    hints: [
      'Use a stack to track the characters.',
      'Pop when the top of the stack equals the current character.',
      'Push when characters do not match.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const s = fs.readFileSync(0, "utf-8").trim();
  console.log(removeDuplicates(s));
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    s = sys.stdin.read().strip()
    print(remove_duplicates(s))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String s = sc.nextLine();
    System.out.println(DuplicateRemover.removeDuplicates(s));
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
using namespace std;
int main() {
    string s;
    getline(cin, s);
    cout << removeDuplicates(s);
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function removeDuplicates(s) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def remove_duplicates(s):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class DuplicateRemover {
  public static String removeDuplicates(String s) {
    // write code here
    return "";
  }
}`,
      },
      {
        language: 'cpp',
        code: `string removeDuplicates(const string &s) {
    // write code here
    return "";
}`,
      },
    ],
  },
  {
    title: 'Custom Sort String',
    slug: 'custom-sort-string',
    description:
      'Sort the characters of a string based on the order defined by another string.',
    problemStatement: `You are given two strings <code>order</code> and <code>s</code>. All characters of <code>order</code> are unique and were sorted in some custom order previously.

Rearrange the characters of <code>s</code> so that they match the custom order in <code>order</code>. Characters not present in <code>order</code> can be placed anywhere in the result.

<pre><code>Input: order = "cba", s = "abcd"
Output: "cbad"

Input: order = "kqep", s = "pekeq"
Output: "kqeep"

Input: order = "xyz", s = "abcd"
Output: "abcd"
</code></pre>

<ul>
  <li>1 ≤ order.length ≤ 26</li>
  <li>1 ≤ s.length ≤ 200</li>
  <li>Both <code>order</code> and <code>s</code> consist of lowercase English letters.</li>
  <li>All characters of <code>order</code> are unique.</li>
</ul>

Pro Tip: Count the frequency of each character in <code>s</code>, then build the result using the custom order followed by remaining characters.`,
    sampleTestCases: [
      { input: 'cba\nabcd', expected: 'cbad' },
      { input: 'kqep\npekeq', expected: 'kqeep' },
      { input: 'xyz\nabcd', expected: 'abcd' },
    ],
    testCases: [
      { input: 'abc\nabcabc', expected: 'aabbcc' },
      { input: 'bca\nabcabc', expected: 'bbccaa' },
      { input: 'xyz\nzyx', expected: 'zyx' },
      { input: 'a\nbcdef', expected: 'bcdef' },
      { input: 'bac\ncabbad', expected: 'bbaaccd' },
      { input: 'hgfedcba\nabcdefgh', expected: 'hgfedcba' },
      { input: 'a\n', expected: '' },
      { input: 'x\nyyy', expected: 'yyy' },
      { input: 'edcba\nabcde', expected: 'edcba' },
      { input: 'qwerty\nqweerty', expected: 'qweerty' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're designing a product listing page for Amazon where the products need to be shown in a custom priority order. Can you reorder a given list of items (string) to match a preferred ordering (custom string)?",
    difficulty: 'medium',
    frequency: 70,
    tags: ['string', 'hash map', 'sorting', 'custom order'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Count how many times each character occurs in s.',
      'Build the result starting with characters in order using their counts.',
      'Append remaining characters not in order at the end.',
    ],
    optimalComplexity: {
      time: 'O(n + m)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const order = input[0];
  const s = input[1];
  const result = customSortString(order, s);
  console.log(result);
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    lines = sys.stdin.read().split("\\n")
    order = lines[0]
    s = lines[1]
    print(custom_sort_string(order, s))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String order = sc.nextLine();
    String s = sc.nextLine();
    System.out.println(Sorter.customSortString(order, s));
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
using namespace std;
int main() {
    string order, s;
    getline(cin, order);
    getline(cin, s);
    cout << customSortString(order, s);
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function customSortString(order, s) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def custom_sort_string(order, s):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class Sorter {
  public static String customSortString(String order, String s) {
    // write code here
    return "";
  }
}`,
      },
      {
        language: 'cpp',
        code: `string customSortString(const string &order, const string &s) {
    // write code here
    return "";
}`,
      },
    ],
  },
  {
    title: 'Frequency Sort Characters',
    slug: 'frequency-sort-characters',
    description: 'Sort characters in a string by decreasing frequency.',
    problemStatement: `Given a string <code>s</code>, sort it in decreasing order based on the frequency of characters, and return the sorted string. If multiple characters have the same frequency, they can be ordered arbitrarily.

<pre><code>Input: s = "tree"
Output: "eert" or "eetr"

Input: s = "cccaaa"
Output: "cccaaa" or "aaaccc"

Input: s = "Aabb"
Output: "bbAa" or "bbaA"
</code></pre>

<ul>
  <li>1 ≤ s.length ≤ 5 × 10<sup>5</sup></li>
  <li><code>s</code> consists of uppercase and lowercase English letters and digits.</li>
</ul>

Pro Tip: Count the frequency of characters, then use a max-heap or sort to arrange them by frequency.`,
    sampleTestCases: [
      { input: 'tree', expected: 'eert' },
      { input: 'cccaaa', expected: 'cccaaa' },
      { input: 'Aabb', expected: 'bbaA' },
    ],
    testCases: [
      { input: 'a', expected: 'a' },
      { input: 'bbbaaa', expected: 'aaabbb' },
      { input: 'xyz', expected: 'xyz' },
      { input: 'zzzzaaabb', expected: 'zzzaaabb' },
      { input: '112233', expected: '112233' },
      { input: 'abcabcabc', expected: 'aaabbbccc' },
      { input: 'eeeeeeee', expected: 'eeeeeeee' },
      { input: 'aabbccddeeff', expected: 'aabbccddeeff' },
      { input: 'xyxyxy', expected: 'xxxyyy' },
      { input: 'abAB', expected: 'abAB' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re designing a frequency analyzer for a text compression system at Adobe. You need to sort characters by how frequently they occur. Can you implement it efficiently?',
    difficulty: 'medium',
    frequency: 74,
    tags: ['heap', 'hash map', 'string', 'sorting', 'frequency count'],
    companies: [
      { name: 'Adobe', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use a hash map to count frequencies of each character.',
      'Sort the characters by frequency in descending order.',
      'Build the result by repeating characters based on their counts.',
    ],
    optimalComplexity: {
      time: 'O(n log k)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const s = fs.readFileSync(0, "utf-8").trim();
  console.log(frequencySort(s));
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    s = sys.stdin.read().strip()
    print(frequency_sort(s))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String s = sc.nextLine();
    System.out.println(Sorter.frequencySort(s));
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
using namespace std;
int main() {
    string s;
    getline(cin, s);
    cout << frequencySort(s);
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function frequencySort(s) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def frequency_sort(s):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class Sorter {
  public static String frequencySort(String s) {
    // write code here
    return "";
  }
}`,
      },
      {
        language: 'cpp',
        code: `string frequencySort(const string &s) {
    // write code here
    return "";
}`,
      },
    ],
  },
  {
    title: 'Reorganize String',
    slug: 'reorganize-string',
    description:
      'Rearrange characters in a string so that no two adjacent characters are the same.',
    problemStatement: `Given a string <code>s</code>, rearrange the characters so that no two adjacent characters are the same. If it is not possible to do so, return an empty string.

<pre><code>Input: s = "aab"
Output: "aba"

Input: s = "aaab"
Output: ""

Input: s = "vvvlo"
Output: "vlvov"
</code></pre>

<ul>
  <li>1 ≤ s.length ≤ 500</li>
  <li><code>s</code> consists of lowercase English letters.</li>
</ul>

Pro Tip: Use a max heap (priority queue) to always choose the character with the highest remaining frequency that’s different from the last placed character.`,
    sampleTestCases: [
      { input: 'aab', expected: 'aba' },
      { input: 'aaab', expected: '' },
      { input: 'vvvlo', expected: 'vlvov' },
    ],
    testCases: [
      { input: 'a', expected: 'a' },
      { input: 'aa', expected: '' },
      { input: 'abc', expected: 'abc' },
      { input: 'aabb', expected: 'abab' },
      { input: 'aaabc', expected: 'abaca' },
      { input: 'aaaabc', expected: '' },
      { input: 'aabbcc', expected: 'abcabc' },
      { input: 'aaabbc', expected: 'ababac' },
      { input: 'aabbccddee', expected: 'abcdeabcde' },
      { input: 'zzzzzzaa', expected: '' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're building an autocomplete engine for Apple where suggestions should not repeat letters consecutively for better readability. Can you rearrange a string so that no two adjacent letters are the same?",
    difficulty: 'medium',
    frequency: 87,
    tags: ['heap', 'string', 'greedy', 'priority queue'],
    companies: [
      { name: 'Apple', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Count frequency of each character.',
      'Use a max-heap to always place the most frequent available character.',
      "Store the previous character temporarily to ensure it's not reused back-to-back.",
    ],
    optimalComplexity: {
      time: 'O(n log k)',
      space: 'O(k)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const s = fs.readFileSync(0, "utf-8").trim();
  const result = reorganizeString(s);
  console.log(result);
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    s = sys.stdin.read().strip()
    print(reorganize_string(s))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String s = sc.nextLine();
    System.out.println(Reorganizer.reorganizeString(s));
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
using namespace std;
int main() {
    string s;
    getline(cin, s);
    cout << reorganizeString(s);
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function reorganizeString(s) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def reorganize_string(s):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class Reorganizer {
  public static String reorganizeString(String s) {
    // write code here
    return "";
  }
}`,
      },
      {
        language: 'cpp',
        code: `string reorganizeString(const string &s) {
    // write code here
    return "";
}`,
      },
    ],
  },
  {
    title: 'Remove Duplicate Letters',
    slug: 'remove-duplicate-letters',
    description:
      'Remove duplicate letters from a string so that every letter appears once and the result is the smallest in lexicographical order.',
    problemStatement: `Given a string <code>s</code>, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.

<pre><code>Input: s = "bcabc"
Output: "abc"

Input: s = "cbacdcbc"
Output: "acdb"

Input: s = "cdadabcc"
Output: "adbc"
</code></pre>

<ul>
  <li>1 ≤ s.length ≤ 10<sup>4</sup></li>
  <li><code>s</code> consists of lowercase English letters.</li>
</ul>

Pro Tip: Use a stack, a set to track seen characters, and a counter to track remaining frequencies. Remove characters from the stack if the current character is smaller and they appear later again.`,
    sampleTestCases: [
      { input: 'bcabc', expected: 'abc' },
      { input: 'cbacdcbc', expected: 'acdb' },
      { input: 'cdadabcc', expected: 'adbc' },
    ],
    testCases: [
      { input: 'a', expected: 'a' },
      { input: 'aa', expected: 'a' },
      { input: 'abc', expected: 'abc' },
      { input: 'abacb', expected: 'abc' },
      { input: 'ecbacba', expected: 'eacb' },
      { input: 'leetcode', expected: 'letcod' },
      { input: 'bbcaac', expected: 'bac' },
      { input: 'cbacdcbc', expected: 'acdb' },
      { input: 'abcdabcd', expected: 'abcd' },
      {
        input: 'thesphinxofblackquartzjudge',
        expected: 'abcdfghijklmnopqrstuvxz',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re building a compiler at Microsoft and need to process variable names such that each character is unique and ordered lexicographically smallest. How would you ensure no duplicate characters while preserving the smallest order?',
    difficulty: 'hard',
    frequency: 78,
    tags: ['stack', 'greedy', 'string', 'lexicographical', 'monotonic stack'],
    companies: [
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use a stack to build the answer.',
      'Pop from the stack if the current character is smaller and the top of the stack character occurs again later.',
      'Use a set to avoid duplicates and a counter to track future characters.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const s = fs.readFileSync(0, "utf-8").trim();
  const result = removeDuplicateLetters(s);
  console.log(result);
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    s = sys.stdin.read().strip()
    print(remove_duplicate_letters(s))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String s = sc.nextLine();
    System.out.println(Deduplicator.removeDuplicateLetters(s));
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
using namespace std;
int main() {
    string s;
    getline(cin, s);
    cout << removeDuplicateLetters(s);
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function removeDuplicateLetters(s) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def remove_duplicate_letters(s):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class Deduplicator {
  public static String removeDuplicateLetters(String s) {
    // write code here
    return "";
  }
}`,
      },
      {
        language: 'cpp',
        code: `string removeDuplicateLetters(const string &s) {
    // write code here
    return "";
}`,
      },
    ],
  },
  {
    title: 'Edit Distance',
    slug: 'edit-distance',
    description:
      'Find the minimum number of operations required to convert one string to another.',
    problemStatement: `Given two strings <code>word1</code> and <code>word2</code>, return the minimum number of operations required to convert <code>word1</code> to <code>word2</code>.

You are allowed to perform the following three operations on a word:
<ul>
  <li>Insert a character</li>
  <li>Delete a character</li>
  <li>Replace a character</li>
</ul>

<pre><code>Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation:
horse → rorse (replace 'h' with 'r')
rorse → rose (remove 'r')
rose → ros (remove 'e')

Input: word1 = "intention", word2 = "execution"
Output: 5
</code></pre>

<ul>
  <li>0 ≤ word1.length, word2.length ≤ 500</li>
  <li><code>word1</code> and <code>word2</code> consist of lowercase English letters.</li>
</ul>

Pro Tip: Use dynamic programming where dp[i][j] represents the edit distance between the first i characters of word1 and the first j characters of word2.`,
    sampleTestCases: [
      { input: 'horse\nros', expected: '3' },
      { input: 'intention\nexecution', expected: '5' },
      { input: 'abc\nabc', expected: '0' },
    ],
    testCases: [
      { input: 'a\na', expected: '0' },
      { input: 'a\nb', expected: '1' },
      { input: 'abc\ndef', expected: '3' },
      { input: 'abc\nabcd', expected: '1' },
      { input: 'abcde\nabfde', expected: '1' },
      { input: 'ab\n', expected: '2' },
      { input: '\nab', expected: '2' },
      { input: 'kitten\nsitting', expected: '3' },
      { input: 'teacher\ncheater', expected: '2' },
      { input: 'distance\nediting', expected: '5' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're working on a version control system at GitHub. To compute changes between file versions, you must calculate how many edits are needed to transform one file into another. Can you solve this efficiently?",
    difficulty: 'hard',
    frequency: 82,
    tags: ['dynamic programming', 'string', 'dp table', 'matrix'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use a 2D dp array where dp[i][j] represents the edit distance between word1[0..i-1] and word2[0..j-1].',
      'Base case: empty strings require insertions or deletions.',
      'Transition: if characters match, move diagonally; otherwise, take min of insert, delete, or replace.',
    ],
    optimalComplexity: {
      time: 'O(m × n)',
      space: 'O(m × n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const [word1, word2] = fs.readFileSync(0, "utf-8").trim().split("\\n");
  console.log(minDistance(word1, word2));
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    word1, word2 = sys.stdin.read().split("\\n")
    print(min_distance(word1, word2))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String word1 = sc.nextLine();
    String word2 = sc.nextLine();
    System.out.println(Edit.minDistance(word1, word2));
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
using namespace std;
int main() {
    string word1, word2;
    getline(cin, word1);
    getline(cin, word2);
    cout << minDistance(word1, word2);
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function minDistance(word1, word2) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def min_distance(word1, word2):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class Edit {
  public static int minDistance(String word1, String word2) {
    // write code here
    return 0;
  }
}`,
      },
      {
        language: 'cpp',
        code: `int minDistance(const string &word1, const string &word2) {
    // write code here
    return 0;
}`,
      },
    ],
  },
  {
    title: 'Longest Common Subsequence',
    slug: 'longest-common-subsequence',
    description:
      'Find the length of the longest common subsequence between two strings.',
    problemStatement: `Given two strings <code>text1</code> and <code>text2</code>, return the length of their longest common subsequence.

A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous. The longest common subsequence (LCS) is the longest sequence that exists in both strings.

<pre><code>Input: text1 = "abcde", text2 = "ace"
Output: 3
Explanation: The LCS is "ace".

Input: text1 = "abc", text2 = "abc"
Output: 3

Input: text1 = "abc", text2 = "def"
Output: 0
</code></pre>

<ul>
  <li>1 ≤ text1.length, text2.length ≤ 1000</li>
  <li><code>text1</code> and <code>text2</code> consist of only lowercase English characters.</li>
</ul>

Pro Tip: Use a DP table where dp[i][j] represents the length of LCS of the first i characters of text1 and first j characters of text2.`,
    sampleTestCases: [
      { input: 'abcde\nace', expected: '3' },
      { input: 'abc\nabc', expected: '3' },
      { input: 'abc\ndef', expected: '0' },
    ],
    testCases: [
      { input: 'a\na', expected: '1' },
      { input: 'a\nb', expected: '0' },
      { input: 'abcde\nfghij', expected: '0' },
      { input: 'abcdef\nafzdef', expected: '5' },
      { input: 'axbycz\naaybzz', expected: '4' },
      { input: 'abcde\nabcde', expected: '5' },
      { input: 'abcabcaa\nacbacba', expected: '5' },
      { input: 'aaaa\naa', expected: '2' },
      { input: 'acebdf\nabcdef', expected: '4' },
      { input: 'longest\nstrongest', expected: '7' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re designing a diff tool at GitHub. To highlight similarities between file versions, you need to compute the longest common subsequence between the two. Can you do this efficiently?',
    difficulty: 'medium',
    frequency: 85,
    tags: ['dynamic programming', 'string', '2D array'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Meta', logoUrl: '' },
    ],
    hints: [
      'Use a 2D dp array where dp[i][j] is the LCS length of text1[0..i-1] and text2[0..j-1].',
      'If characters match, take diagonal value +1.',
      'Otherwise, take max of left and top values in the dp table.',
    ],
    optimalComplexity: {
      time: 'O(m × n)',
      space: 'O(m × n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const [text1, text2] = fs.readFileSync(0, "utf-8").trim().split("\\n");
  console.log(longestCommonSubsequence(text1, text2));
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    text1, text2 = sys.stdin.read().strip().split("\\n")
    print(longest_common_subsequence(text1, text2))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String text1 = sc.nextLine();
    String text2 = sc.nextLine();
    System.out.println(LCS.longestCommonSubsequence(text1, text2));
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
using namespace std;
int main() {
    string text1, text2;
    getline(cin, text1);
    getline(cin, text2);
    cout << longestCommonSubsequence(text1, text2);
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function longestCommonSubsequence(text1, text2) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def longest_common_subsequence(text1, text2):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class LCS {
  public static int longestCommonSubsequence(String text1, String text2) {
    // write code here
    return 0;
  }
}`,
      },
      {
        language: 'cpp',
        code: `int longestCommonSubsequence(const string &text1, const string &text2) {
    // write code here
    return 0;
}`,
      },
    ],
  },
  {
    title: 'Longest Palindromic Subsequence',
    slug: 'longest-palindromic-subsequence',
    description:
      'Find the length of the longest palindromic subsequence in a string.',
    problemStatement: `Given a string <code>s</code>, return the length of the longest palindromic subsequence in <code>s</code>.

A subsequence is a sequence that appears in the same relative order but not necessarily contiguous. A palindrome is a sequence that reads the same backward as forward.

<pre><code>Input: s = "bbbab"
Output: 4
Explanation: The longest palindromic subsequence is "bbbb".

Input: s = "cbbd"
Output: 2
Explanation: The longest palindromic subsequence is "bb".
</code></pre>

<ul>
  <li>1 ≤ s.length ≤ 1000</li>
  <li><code>s</code> consists only of lowercase English letters.</li>
</ul>

Pro Tip: Use dynamic programming. Let dp[i][j] represent the length of the longest palindromic subsequence in s[i..j].`,
    sampleTestCases: [
      { input: 'bbbab', expected: '4' },
      { input: 'cbbd', expected: '2' },
      { input: 'a', expected: '1' },
    ],
    testCases: [
      { input: 'a', expected: '1' },
      { input: 'aa', expected: '2' },
      { input: 'abc', expected: '1' },
      { input: 'aba', expected: '3' },
      { input: 'abcdba', expected: '5' },
      { input: 'agbdba', expected: '5' },
      { input: 'aaaa', expected: '4' },
      { input: 'abcba', expected: '5' },
      { input: 'abacdfgdcaba', expected: '5' },
      { input: 'character', expected: '5' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're designing a bioinformatics tool at Roche to analyze DNA sequences. You need to detect the longest palindromic subsequences in genetic strings. Can you compute it efficiently?",
    difficulty: 'medium',
    frequency: 79,
    tags: ['dynamic programming', 'string', '2D DP', 'palindrome'],
    companies: [
      { name: 'Roche', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Meta', logoUrl: '' },
    ],
    hints: [
      'Use a 2D dp array where dp[i][j] is the length of LPS between indices i and j.',
      'If s[i] == s[j], then dp[i][j] = 2 + dp[i+1][j-1].',
      'Else, dp[i][j] = max(dp[i+1][j], dp[i][j-1]).',
    ],
    optimalComplexity: {
      time: 'O(n^2)',
      space: 'O(n^2)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const s = fs.readFileSync(0, "utf-8").trim();
  console.log(longestPalindromeSubseq(s));
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    s = sys.stdin.read().strip()
    print(longest_palindrome_subseq(s))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String s = sc.nextLine();
    System.out.println(Palindrome.longestPalindromeSubseq(s));
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
using namespace std;
int main() {
    string s;
    getline(cin, s);
    cout << longestPalindromeSubseq(s);
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function longestPalindromeSubseq(s) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def longest_palindrome_subseq(s):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class Palindrome {
  public static int longestPalindromeSubseq(String s) {
    // write code here
    return 0;
  }
}`,
      },
      {
        language: 'cpp',
        code: `int longestPalindromeSubseq(const string &s) {
    // write code here
    return 0;
}`,
      },
    ],
  },
  {
    title: 'Count Palindromic Subsequences',
    slug: 'count-palindromic-subsequences',
    description:
      'Count all distinct non-empty palindromic subsequences in a given string.',
    problemStatement: `Given a string <code>s</code>, return the number of **distinct** non-empty palindromic subsequences in <code>s</code>. Since the answer may be very large, return it modulo <code>10^9 + 7</code>.

<pre><code>Input: s = "bccb"
Output: 6
Explanation: The 6 different palindromic subsequences are "b", "c", "bb", "cc", "bcb", "bccb".

Input: s = "abcd"
Output: 4
Explanation: All characters are unique so each character is a palindromic subsequence.
</code></pre>

<ul>
  <li>1 ≤ s.length ≤ 1000</li>
  <li><code>s</code> consists only of lowercase English letters.</li>
</ul>

Pro Tip: Use dynamic programming with memoization to count subsequences between indices. For each character, consider its first and last occurrence within a range.`,
    sampleTestCases: [
      { input: 'bccb', expected: '6' },
      { input: 'abcd', expected: '4' },
      { input: 'aaa', expected: '3' },
    ],
    testCases: [
      { input: 'a', expected: '1' },
      { input: 'aa', expected: '2' },
      { input: 'aba', expected: '4' },
      { input: 'abba', expected: '6' },
      { input: 'abca', expected: '6' },
      { input: 'abcdedcba', expected: '25' },
      { input: 'aaaaa', expected: '5' },
      { input: 'abcba', expected: '13' },
      { input: 'abcbabcba', expected: '43' },
      { input: 'aabbaa', expected: '15' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re developing a DNA analysis tool at a genomics company. Your task is to count all unique palindromic subsequences within a given sequence. Efficiency is key — can you implement a scalable approach?',
    difficulty: 'hard',
    frequency: 73,
    tags: [
      'dynamic programming',
      'palindrome',
      'memoization',
      'string',
      'counting',
    ],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Meta', logoUrl: '' },
    ],
    hints: [
      'Use a 3D or 2D DP table to store results of substrings.',
      'For each substring s[i..j], check first and last occurrence of s[i] within range.',
      'Add results from inner subsequences while avoiding duplicates.',
    ],
    optimalComplexity: {
      time: 'O(n^2)',
      space: 'O(n^2)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
const MOD = 1e9 + 7;
function main() {
  const s = fs.readFileSync(0, "utf-8").trim();
  console.log(countPalindromicSubsequences(s));
}
main();`,
      },
      {
        language: 'python',
        code: `MOD = 10**9 + 7
def main():
    import sys
    s = sys.stdin.read().strip()
    print(count_palindromic_subsequences(s))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  static final int MOD = 1_000_000_007;
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String s = sc.nextLine();
    System.out.println(PalCounter.countPalindromicSubsequences(s));
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
using namespace std;
const int MOD = 1e9 + 7;
int main() {
    string s;
    getline(cin, s);
    cout << countPalindromicSubsequences(s);
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function countPalindromicSubsequences(s) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def count_palindromic_subsequences(s):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class PalCounter {
  public static int countPalindromicSubsequences(String s) {
    // write code here
    return 0;
  }
}`,
      },
      {
        language: 'cpp',
        code: `int countPalindromicSubsequences(const string &s) {
    // write code here
    return 0;
}`,
      },
    ],
  },
  {
    title: 'Word Break',
    slug: 'word-break',
    description:
      'Check if a string can be segmented into a space-separated sequence of dictionary words.',
    problemStatement: `Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.

Note: The same word in the dictionary may be reused multiple times.

<pre><code>Input: s = "leetcode", wordDict = ["leet","code"]
Output: true

Input: s = "applepenapple", wordDict = ["apple","pen"]
Output: true

Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: false
</code></pre>

<ul>
  <li>1 ≤ s.length ≤ 300</li>
  <li>1 ≤ wordDict.length ≤ 1000</li>
  <li>1 ≤ wordDict[i].length ≤ 20</li>
  <li><code>s</code> and <code>wordDict[i]</code] consist of only lowercase English letters.</li>
  <li>All the strings of <code>wordDict</code> are unique.</li>
</ul>

Pro Tip: Use a dynamic programming array <code>dp[i]</code> where <code>dp[i]</code> is true if <code>s[0..i)</code> can be segmented.`,
    sampleTestCases: [
      { input: 'leetcode\nleet code', expected: 'true' },
      { input: 'applepenapple\napple pen', expected: 'true' },
      { input: 'catsandog\ncats dog sand and cat', expected: 'false' },
    ],
    testCases: [
      { input: 'a\na', expected: 'true' },
      { input: 'a\nb', expected: 'false' },
      { input: 'catsanddog\ncat cats and dog', expected: 'true' },
      {
        input: 'pineapplepenapple\napple pen applepen pineapple pine',
        expected: 'true',
      },
      { input: 'aaaaaaa\naaa aa', expected: 'true' },
      { input: 'aaaaaaa\naaaa aaaa', expected: 'false' },
      { input: 'abcde\nab abc abcd de', expected: 'true' },
      { input: 'applepen\napple pen', expected: 'true' },
      { input: 'enteraplanet\nenter plan net planet', expected: 'true' },
      { input: 'abcdefg\nabc def gh', expected: 'false' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're building a message parser at WhatsApp and need to split an incoming compressed string into valid words from a dictionary. Can you determine if the string can be segmented accordingly?",
    difficulty: 'medium',
    frequency: 92,
    tags: ['dynamic programming', 'hash set', 'string', 'recursion', 'trie'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use a boolean dp array where dp[i] means s[0..i) is breakable.',
      'Try every word and see if the suffix can be segmented recursively or iteratively.',
      'Convert the dictionary to a Set for O(1) lookups.',
    ],
    optimalComplexity: {
      time: 'O(n^2)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const s = input[0];
  const wordDict = input[1].split(" ");
  console.log(wordBreak(s, wordDict));
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    s, words = sys.stdin.read().strip().split("\\n")
    word_dict = words.split(" ")
    print(word_break(s, word_dict))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String s = sc.nextLine();
    String[] words = sc.nextLine().split(" ");
    List<String> wordDict = Arrays.asList(words);
    System.out.println(WordBreaker.wordBreak(s, wordDict));
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
#include <sstream>
#include <vector>
using namespace std;

int main() {
    string s, line;
    getline(cin, s);
    getline(cin, line);
    istringstream iss(line);
    vector<string> wordDict;
    string word;
    while (iss >> word) wordDict.push_back(word);
    cout << (wordBreak(s, wordDict) ? "true" : "false");
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function wordBreak(s, wordDict) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def word_break(s, word_dict):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class WordBreaker {
  public static boolean wordBreak(String s, List<String> wordDict) {
    // write code here
    return false;
  }
}`,
      },
      {
        language: 'cpp',
        code: `bool wordBreak(const string &s, const vector<string> &wordDict) {
    // write code here
    return false;
}`,
      },
    ],
  },
  {
    title: 'Word Wrap Problem',
    slug: 'word-wrap-problem',
    description:
      'Minimize the total cost of wrapping words into lines without exceeding the line width.',
    problemStatement: `Given an array of words represented by their lengths and a line width <code>maxWidth</code>, place the words in such a way that minimizes the total cost. The cost of a line is the square of the number of extra spaces at the end of the line (except the last line).

Return the minimum total cost to wrap the words.

<pre><code>Input: words = [3, 2, 2, 5], maxWidth = 6
Output: 10
Explanation:
Line 1: words[0,1] = 3 + 1 + 2 = 6 => 0 extra space → cost = 0
Line 2: words[2] = 2 => 4 extra spaces → cost = 4^2 = 16
Line 3: words[3] = 5 => 1 extra space → cost = 1^2 = 1
Total cost = 0 + 16 + 1 = 17

However, better wrap:
Line 1: words[0] = 3 => 3 extra → 9
Line 2: words[1,2] = 2 + 1 + 2 = 5 => 1 → 1
Line 3: words[3] = 5 => 1 → 0 (last line, no cost)
Total = 9 + 1 + 0 = 10
</code></pre>

<ul>
  <li>1 ≤ words.length ≤ 500</li>
  <li>1 ≤ words[i] ≤ maxWidth</li>
  <li>1 ≤ maxWidth ≤ 1000</li>
</ul>

Pro Tip: Use dynamic programming with <code>dp[i]</code> storing minimum cost to arrange words from i to end.`,
    sampleTestCases: [
      { input: '4\n3 2 2 5\n6', expected: '10' },
      { input: '3\n3 2 2\n6', expected: '5' },
      { input: '1\n5\n6', expected: '0' },
    ],
    testCases: [
      { input: '1\n1\n1', expected: '0' },
      { input: '2\n1 1\n5', expected: '9' },
      { input: '5\n1 2 3 4 5\n10', expected: '29' },
      { input: '6\n2 2 2 2 2 2\n6', expected: '8' },
      { input: '4\n3 2 2 5\n10', expected: '0' },
      { input: '5\n3 1 2 1 1\n5', expected: '7' },
      { input: '6\n4 2 2 2 2 1\n6', expected: '13' },
      { input: '4\n2 2 2 2\n6', expected: '5' },
      { input: '3\n5 5 5\n6', expected: '1' },
      { input: '3\n3 3 3\n6', expected: '0' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're designing a text formatting tool at Google Docs. You need to split words into lines so that the text looks good, and the extra space cost is minimized. Can you implement the optimal layout strategy?",
    difficulty: 'hard',
    frequency: 66,
    tags: [
      'dynamic programming',
      'greedy',
      'string formatting',
      'optimization',
    ],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use a dp[i] to represent minimum cost from i to end.',
      'Try placing j words in the current line and recur for the rest.',
      'Skip cost on the last line.',
    ],
    optimalComplexity: {
      time: 'O(n^2)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(input[0]);
  const words = input[1].split(" ").map(Number);
  const maxWidth = parseInt(input[2]);
  console.log(wordWrap(words, maxWidth));
}
main();`,
      },
      {
        language: 'python',
        code: `def main():
    import sys
    lines = sys.stdin.read().splitlines()
    n = int(lines[0])
    words = list(map(int, lines[1].split()))
    max_width = int(lines[2])
    print(word_wrap(words, max_width))

if __name__ == "__main__":
    main()`,
      },
      {
        language: 'java',
        code: `import java.util.*;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = Integer.parseInt(sc.nextLine());
    int[] words = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();
    int maxWidth = Integer.parseInt(sc.nextLine());
    System.out.println(Wrapper.wordWrap(words, maxWidth));
  }
}`,
      },
      {
        language: 'cpp',
        code: `#include <iostream>
using namespace std;
int main() {
    int n, maxWidth;
    cin >> n;
    int words[n];
    for (int i = 0; i < n; i++) cin >> words[i];
    cin >> maxWidth;
    cout << wordWrap(words, n, maxWidth);
    return 0;
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `function wordWrap(words, maxWidth) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `def word_wrap(words, max_width):
    # write code here
    pass`,
      },
      {
        language: 'java',
        code: `class Wrapper {
  public static int wordWrap(int[] words, int maxWidth) {
    // write code here
    return 0;
  }
}`,
      },
      {
        language: 'cpp',
        code: `int wordWrap(int words[], int n, int maxWidth) {
    // write code here
    return 0;
}`,
      },
    ],
  },
  {
    title: 'Scramble String Validation',
    slug: 'scramble-string-validation',
    description: 'Determine if one string is a scrambled version of another.',
    problemStatement:
      'Given two strings `s1` and `s2` of the same length, determine if `s2` is a scrambled version of `s1`.\n\nA scrambled string is defined recursively as follows:\n1. The original string is a scrambled string.\n2. If a string can be split into two non-empty substrings, and either:\n   - the two substrings of one string are a scrambled version of the two substrings of the other string, or\n   - the two substrings of one string are a scrambled version of the swapped substrings of the other string,\nthen it is a scrambled string.\n\nYou need to implement a function to check whether `s2` is a scrambled string of `s1`.\n\nExamples:\n<pre><code>Input: s1 = "great", s2 = "rgeat"\nOutput: true\nExplanation: "great" -> "gr/eat" -> swap -> "rg/eat" -> "rgeat"\n\nInput: s1 = "abcde", s2 = "caebd"\nOutput: false\nExplanation: No valid sequence of swaps can make "abcde" into "caebd".\n</code></pre>\n\n<ul>\n<li>1 &lt;= s1.length &lt;= 30</li>\n<li>s1.length == s2.length</li>\n<li>s1 and s2 consist of lowercase English letters</li>\n</ul>\n\n<b>Pro Tip:</b> Try to use memoization to optimize recursive solutions. Use character frequency maps to prune unnecessary branches early.',
    sampleTestCases: [
      { input: 'great\nrgeat', expected: 'true' },
      { input: 'abcde\ncaebd', expected: 'false' },
    ],
    testCases: [
      { input: 'great\nrgeat', expected: 'true' },
      { input: 'abcde\ncaebd', expected: 'false' },
      { input: 'a\na', expected: 'true' },
      { input: 'abc\nbca', expected: 'true' },
      { input: 'abc\nacb', expected: 'true' },
      { input: 'abcde\neabcd', expected: 'true' },
      { input: 'abcd\ndabc', expected: 'true' },
      { input: 'abcd\nacbd', expected: 'true' },
      { input: 'aaaa\naaaa', expected: 'true' },
      { input: 'abcd\nabcd', expected: 'true' },
      { input: 'abcd\nefgh', expected: 'false' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Imagine you’re working on a text-based encryption algorithm. You’ve scrambled strings using a recursive partitioning and swapping method. Now, we need to verify whether a given string could be a valid scrambled result of another. Can you help us write a function to validate this transformation?',
    categories: ['Recursion', 'String', 'DP'],
    difficulty: 'hard',
    frequency: 88,
    tags: ['string', 'recursion', 'dynamic programming', 'divide and conquer'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use recursion and consider all possible partition positions.',
      'Memoization can help you avoid redundant calculations.',
      'Use a hash to quickly compare character frequencies before deeper checks.',
    ],
    optimalComplexity: {
      time: 'O(n^4)',
      space: 'O(n^3)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const s1 = input[0];\n  const s2 = input[1];\n  console.log(isScramble(s1, s2));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'import sys\nsys.setrecursionlimit(10000)\n\ndef main():\n    input_lines = sys.stdin.read().strip().split("\\n")\n    s1 = input_lines[0]\n    s2 = input_lines[1]\n    print(isScramble(s1, s2))\n\nif __name__ == "__main__":\n    main()',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s1 = sc.nextLine();\n    String s2 = sc.nextLine();\n    System.out.println(isScramble(s1, s2));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint main() {\n  string s1, s2;\n  getline(cin, s1);\n  getline(cin, s2);\n  cout << boolalpha << isScramble(s1, s2) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function isScramble(s1, s2) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def isScramble(s1, s2):\n    # write your code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static boolean isScramble(String s1, String s2) {\n    // write your code here\n}',
      },
      {
        language: 'cpp',
        code: 'bool isScramble(string s1, string s2) {\n    // write your code here\n}',
      },
    ],
  },
  {
    title: 'Interleaving Strings Check',
    slug: 'interleaving-strings-check',
    description:
      'Check whether a string is formed by interleaving two other strings.',
    problemStatement:
      'You are given three strings `s1`, `s2`, and `s3`. Write a function to determine whether `s3` is formed by an interleaving of `s1` and `s2`.\n\nAn interleaving of two strings `s1` and `s2` is a string that contains all the characters of `s1` and `s2`, in a way that maintains the relative order of characters from each string.\n\nExamples:\n<pre><code>Input: s1 = "aab", s2 = "axy", s3 = "aaxaby"\nOutput: true\nExplanation: s3 can be formed by interleaving s1 and s2 while maintaining the character order.\n\nInput: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"\nOutput: false\nExplanation: s3 breaks the character order from s1 and s2.\n</code></pre>\n\n<ul>\n<li>0 &lt;= s1.length, s2.length &lt;= 100</li>\n<li>0 &lt;= s3.length &lt;= 200</li>\n<li>s1.length + s2.length == s3.length</li>\n<li>s1, s2, and s3 consist of lowercase English letters</li>\n</ul>\n\n<b>Pro Tip:</b> Use dynamic programming to check each possible combination of prefixes from s1 and s2 forming s3.',
    sampleTestCases: [
      { input: 'aab\naxy\naaxaby', expected: 'true' },
      { input: 'aabcc\ndbbca\naadbbbaccc', expected: 'false' },
    ],
    testCases: [
      { input: 'aab\naxy\naaxaby', expected: 'true' },
      { input: 'aabcc\ndbbca\naadbbcbcac', expected: 'true' },
      { input: 'aabcc\ndbbca\naadbbbaccc', expected: 'false' },
      { input: 'abc\n\nabc', expected: 'true' },
      { input: 'abc\nxyz\naxbycz', expected: 'true' },
      { input: 'abc\nxyz\nabxcyz', expected: 'false' },
      { input: 'abc\nxyz\nabcxyz', expected: 'true' },
      { input: 'abc\nxyz\nabxyzc', expected: 'true' },
      { input: 'abc\nxyz\nabxzyc', expected: 'false' },
      { input: 'abc\nxyz\naxbycz', expected: 'true' },
      { input: 'a\nb\nab', expected: 'true' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're working on a text parser that merges two input sources into a single coherent stream. You now need a validator to confirm whether the merged result is a valid interleaving of the original streams. How would you implement such a function?",
    categories: ['Dynamic Programming', 'String'],
    difficulty: 'medium',
    frequency: 81,
    tags: ['string', 'dynamic programming', '2D dp'],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use a 2D DP table where dp[i][j] is true if s3[0..i+j-1] is formed by interleaving s1[0..i-1] and s2[0..j-1].',
      'Base case: dp[0][0] = true.',
      'Check character matches from s1 and s2 to s3 as you fill the table.',
    ],
    optimalComplexity: {
      time: 'O(n * m)',
      space: 'O(n * m)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const s1 = input[0];\n  const s2 = input[1];\n  const s3 = input[2];\n  console.log(isInterleave(s1, s2, s3));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'import sys\n\ndef main():\n    input_lines = sys.stdin.read().strip().split("\\n")\n    s1 = input_lines[0]\n    s2 = input_lines[1]\n    s3 = input_lines[2]\n    print(isInterleave(s1, s2, s3))\n\nif __name__ == "__main__":\n    main()',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s1 = sc.nextLine();\n    String s2 = sc.nextLine();\n    String s3 = sc.nextLine();\n    System.out.println(isInterleave(s1, s2, s3));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint main() {\n  string s1, s2, s3;\n  getline(cin, s1);\n  getline(cin, s2);\n  getline(cin, s3);\n  cout << boolalpha << isInterleave(s1, s2, s3) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function isInterleave(s1, s2, s3) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def isInterleave(s1, s2, s3):\n    # write your code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static boolean isInterleave(String s1, String s2, String s3) {\n    // write your code here\n}',
      },
      {
        language: 'cpp',
        code: 'bool isInterleave(string s1, string s2, string s3) {\n    // write your code here\n}',
      },
    ],
  },
  {
    title: 'Count Distinct Subsequences',
    slug: 'count-distinct-subsequences',
    description:
      'Given two strings, count the number of distinct subsequences of the first string which equals the second.',
    problemStatement:
      'You are given two strings `s` and `t`. Write a function to return the number of distinct subsequences of `s` which equals `t`.\n\nA subsequence of a string is a new string generated from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.\n\nThe answer can be large, so return it modulo 10^9 + 7.\n\nExamples:\n<pre><code>Input: s = "rabbbit", t = "rabbit"\nOutput: 3\nExplanation: There are 3 ways to delete a character from s to form t: \n1. rab[b]bit\n2. rabb[bi]t\n3. rabbb[i]t\n\nInput: s = "babgbag", t = "bag"\nOutput: 5\nExplanation: Possible subsequences: bag, ba[g]bag, bab[g]bag, babg[ba]g, etc.\n</code></pre>\n\n<ul>\n<li>1 &lt;= s.length, t.length &lt;= 1000</li>\n<li>`s` and `t` consist of lowercase English letters</li>\n</ul>\n\n<b>Pro Tip:</b> This problem is best solved using 2D dynamic programming. Let dp[i][j] be the number of ways to form t[0..j-1] from s[0..i-1].',
    sampleTestCases: [
      { input: 'rabbbit\nrabbit', expected: '3' },
      { input: 'babgbag\nbag', expected: '5' },
    ],
    testCases: [
      { input: 'rabbbit\nrabbit', expected: '3' },
      { input: 'babgbag\nbag', expected: '5' },
      { input: 'abcde\nace', expected: '1' },
      { input: 'aaaaa\naa', expected: '10' },
      { input: 'abcdefg\nabc', expected: '1' },
      { input: 'abcabcabc\nabc', expected: '10' },
      { input: 'abcabcabcabc\nabc', expected: '20' },
      { input: 'aaaabbbbcccc\naabbcc', expected: '400' },
      { input: 'a\nb', expected: '0' },
      { input: 'a\na', expected: '1' },
      { input: 'longstringwithrandomcharacters\nrandom', expected: '3' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're working on a system that checks how many ways a query pattern could match a document, only by deleting characters. Can you figure out how many distinct ways a pattern string appears in a source string as a subsequence?",
    categories: ['Dynamic Programming', 'String'],
    difficulty: 'hard',
    frequency: 84,
    tags: ['dynamic programming', '2D dp', 'string', 'subsequence'],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use 2D dynamic programming with dimensions (len(s)+1) x (len(t)+1).',
      'If s[i-1] == t[j-1], include both using and skipping current char.',
      'Remember to take modulo 1e9 + 7 to avoid overflow.',
    ],
    optimalComplexity: {
      time: 'O(n * m)',
      space: 'O(n * m)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const MOD = 1e9 + 7;\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const s = input[0];\n  const t = input[1];\n  console.log(numDistinct(s, t));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'MOD = 10**9 + 7\n\ndef main():\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    s = input_lines[0]\n    t = input_lines[1]\n    print(numDistinct(s, t))\n\nif __name__ == "__main__":\n    main()',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  static final int MOD = 1_000_000_007;\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    String t = sc.nextLine();\n    System.out.println(numDistinct(s, t));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nint main() {\n  string s, t;\n  getline(cin, s);\n  getline(cin, t);\n  cout << numDistinct(s, t) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function numDistinct(s, t) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def numDistinct(s, t):\n    # write your code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int numDistinct(String s, String t) {\n    // write your code here\n}',
      },
      {
        language: 'cpp',
        code: 'int numDistinct(string s, string t) {\n    // write your code here\n}',
      },
    ],
  },
  {
    title: 'Regular Expression Matching',
    slug: 'regular-expression-matching',
    description:
      "Implement regular expression matching with support for '.' and '*'.",
    problemStatement:
      'Implement regular expression matching with support for `.` and `*`.\n\nGiven an input string `s` and a pattern `p`, return `true` if `s` matches the pattern `p`, where:\n- `.` Matches any single character.\n- `*` Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\nExamples:\n<pre><code>Input: s = "aa", p = "a"\nOutput: false\nExplanation: "a" does not match the entire string "aa".\n\nInput: s = "aa", p = "a*"\nOutput: true\nExplanation: \'*\' means zero or more of the preceding \'a\'.\n\nInput: s = "ab", p = ".*"\nOutput: true\nExplanation: \'.*\' means any character repeated any number of times.\n</code></pre>\n\n<ul>\n<li>1 &lt;= s.length &lt;= 20</li>\n<li>1 &lt;= p.length &lt;= 30</li>\n<li>s and p consist of lowercase English letters, \'.\', and \'*\'</li>\n<li>It is guaranteed that for every \'*\', there is a valid preceding element</li>\n</ul>\n\n<b>Pro Tip:</b> Use dynamic programming or recursion with memoization. Handle `*` by considering zero or more repetitions of the preceding character.',
    sampleTestCases: [
      { input: 'aa\na', expected: 'false' },
      { input: 'aa\na*', expected: 'true' },
      { input: 'ab\n.*', expected: 'true' },
    ],
    testCases: [
      { input: 'aa\na', expected: 'false' },
      { input: 'aa\na*', expected: 'true' },
      { input: 'ab\n.*', expected: 'true' },
      { input: 'aab\nc*a*b', expected: 'true' },
      { input: 'mississippi\nmis*is*p*.', expected: 'false' },
      { input: 'mississippi\nmis*is*ip*.', expected: 'true' },
      { input: 'abc\nabc', expected: 'true' },
      { input: 'abc\n.*c', expected: 'true' },
      { input: 'abc\n.*d', expected: 'false' },
      { input: 'a\nab*', expected: 'true' },
      { input: 'ab\n.*c', expected: 'false' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Suppose you’re implementing a search engine that supports basic regex patterns. Can you write a function that evaluates whether a given string fully matches a pattern that includes '.' and '*' wildcards?",
    categories: ['String', 'Recursion', 'DP'],
    difficulty: 'hard',
    frequency: 89,
    tags: ['string', 'dynamic programming', 'recursion', 'regex'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use recursion or DP to explore all valid match paths.',
      "For '*' check both 0 and more occurrences of preceding character.",
      'Use memoization to cache results of subproblems.',
    ],
    optimalComplexity: {
      time: 'O(n * m)',
      space: 'O(n * m)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const s = input[0];\n  const p = input[1];\n  console.log(isMatch(s, p));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'def main():\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    s = input_lines[0]\n    p = input_lines[1]\n    print(isMatch(s, p))\n\nif __name__ == "__main__":\n    main()',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    String p = sc.nextLine();\n    System.out.println(isMatch(s, p));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint main() {\n  string s, p;\n  getline(cin, s);\n  getline(cin, p);\n  cout << boolalpha << isMatch(s, p) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function isMatch(s, p) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def isMatch(s, p):\n    # write your code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static boolean isMatch(String s, String p) {\n    // write your code here\n}',
      },
      {
        language: 'cpp',
        code: 'bool isMatch(string s, string p) {\n    // write your code here\n}',
      },
    ],
  },
  {
    title: 'Create a Linked List from Array',
    slug: 'create-linked-list-from-array',
    description: 'Convert an array of integers into a singly linked list.',
    problemStatement:
      'You are given an array of integers. Create a singly linked list from the array where each node contains a value from the array in order.\n\nThe output should be a list where each node points to the next one corresponding to the array sequence.\n\nExamples:\n<pre><code>Input: [1, 2, 3, 4]\nOutput: 1 2 3 4\nExplanation: The linked list will be: 1 -> 2 -> 3 -> 4\n\nInput: []\nOutput: \nExplanation: An empty list should return nothing.\n</code></pre>\n\n<ul>\n<li>0 &lt;= arr.length &lt;= 1000</li>\n<li>-10^4 &lt;= arr[i] &lt;= 10^4</li>\n</ul>\n\n<b>Pro Tip:</b> Use a dummy head node to simplify the list construction.',
    sampleTestCases: [
      { input: '4\n1 2 3 4', expected: '1 2 3 4' },
      { input: '0\n', expected: '' },
    ],
    testCases: [
      { input: '4\n1 2 3 4', expected: '1 2 3 4' },
      { input: '0\n', expected: '' },
      { input: '1\n5', expected: '5' },
      { input: '3\n-1 0 1', expected: '-1 0 1' },
      { input: '2\n100 -100', expected: '100 -100' },
      { input: '6\n9 8 7 6 5 4', expected: '9 8 7 6 5 4' },
      { input: '5\n0 0 0 0 0', expected: '0 0 0 0 0' },
      { input: '7\n1 2 2 3 3 3 4', expected: '1 2 2 3 3 3 4' },
      { input: '1\n-9999', expected: '-9999' },
      { input: '10\n1 2 3 4 5 6 7 8 9 10', expected: '1 2 3 4 5 6 7 8 9 10' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Let's say you're working on a new data structure module. As a starting point, you need to write a utility that takes an array and converts it into a singly linked list. How would you do that?",
    categories: ['Linked List', 'Data Structures'],
    difficulty: 'easy',
    frequency: 72,
    tags: ['linked list', 'array', 'constructors'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use a dummy node to help link nodes easily.',
      'Iterate through the array and attach each value to the next node.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  const dummy = new ListNode(0);\n  let current = dummy;\n  for (let val of arr) {\n    current.next = new ListNode(val);\n    current = current.next;\n  }\n  return dummy.next;\n}\n\nfunction linkedListToArray(head) {\n  const result = [];\n  while (head) {\n    result.push(head.val);\n    head = head.next;\n  }\n  return result;\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = n > 0 ? input[1].split(" ").map(Number) : [];\n  const head = buildLinkedList(arr);\n  console.log(linkedListToArray(head).join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_linked_list(values):\n    dummy = ListNode(0)\n    current = dummy\n    for val in values:\n        current.next = ListNode(val)\n        current = current.next\n    return dummy.next\n\ndef linked_list_to_list(head):\n    result = []\n    while head:\n        result.append(str(head.val))\n        head = head.next\n    return result\n\nif __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    sz = int(input_lines[0])\n    values = list(map(int, input_lines[1].split())) if sz > 0 else []\n    head = build_linked_list(values)\n    print(" ".join(linked_list_to_list(head)))',
      },
      {
        language: 'java',
        code: 'class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        java.util.Scanner sc = new java.util.Scanner(System.in);\n        int n = Integer.parseInt(sc.nextLine());\n        int[] arr = new int[n];\n        if (n > 0) {\n            String[] parts = sc.nextLine().split(" ");\n            for (int i = 0; i < n; i++) arr[i] = Integer.parseInt(parts[i]);\n        }\n        ListNode head = buildLinkedList(arr);\n        printList(head);\n    }\n\n    public static ListNode buildLinkedList(int[] arr) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        for (int num : arr) {\n            current.next = new ListNode(num);\n            current = current.next;\n        }\n        return dummy.next;\n    }\n\n    public static void printList(ListNode head) {\n        while (head != null) {\n            System.out.print(head.val);\n            if (head.next != null) System.out.print(" ");\n            head = head.next;\n        }\n    }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nListNode* buildLinkedList(const vector<int>& arr) {\n    ListNode* dummy = new ListNode(0);\n    ListNode* current = dummy;\n    for (int val : arr) {\n        current->next = new ListNode(val);\n        current = current->next;\n    }\n    return dummy->next;\n}\n\nvoid printList(ListNode* head) {\n    while (head) {\n        cout << head->val;\n        if (head->next) cout << " ";\n        head = head->next;\n    }\n    cout << endl;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) cin >> arr[i];\n    ListNode* head = buildLinkedList(arr);\n    printList(head);\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_linked_list(values):\n    # write your code here\n    pass',
      },
      {
        language: 'java',
        code: 'class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\npublic static ListNode buildLinkedList(int[] arr) {\n    // write your code here\n}',
      },
      {
        language: 'cpp',
        code: 'struct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nListNode* buildLinkedList(const vector<int>& arr) {\n    // write your code here\n}',
      },
    ],
  },
  {
    title: 'Insert Node at Head of Linked List',
    slug: 'insert-node-at-head-of-linked-list',
    description: 'Insert a new node at the beginning of a singly linked list.',
    problemStatement:
      'You are given the head of a singly linked list and an integer value `val`. Write a function to insert a new node with value `val` at the head (beginning) of the list, and return the new head.\n\nExamples:\n<pre><code>Input: head = [2, 3, 4], val = 1\nOutput: 1 2 3 4\nExplanation: New node 1 is inserted at the beginning.\n\nInput: head = [], val = 5\nOutput: 5\nExplanation: The new node becomes the only node in the list.\n</code></pre>\n\n<ul>\n<li>0 &lt;= length of linked list &lt;= 1000</li>\n<li>-10^4 &lt;= val &lt;= 10^4</li>\n</ul>\n\n<b>Pro Tip:</b> Create a new node, point its `next` to the current head, then return it as the new head.',
    sampleTestCases: [
      { input: '3\n2 3 4\n1', expected: '1 2 3 4' },
      { input: '0\n\n5', expected: '5' },
    ],
    testCases: [
      { input: '3\n2 3 4\n1', expected: '1 2 3 4' },
      { input: '0\n\n5', expected: '5' },
      { input: '1\n10\n0', expected: '0 10' },
      { input: '2\n5 6\n4', expected: '4 5 6' },
      { input: '1\n-10\n-20', expected: '-20 -10' },
      { input: '5\n1 2 3 4 5\n0', expected: '0 1 2 3 4 5' },
      { input: '4\n7 8 9 10\n6', expected: '6 7 8 9 10' },
      { input: '1\n100\n200', expected: '200 100' },
      { input: '1\n0\n0', expected: '0 0' },
      {
        input: '10\n1 2 3 4 5 6 7 8 9 10\n-1',
        expected: '-1 1 2 3 4 5 6 7 8 9 10',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Let’s say you’re maintaining a linked list for fast insertions. Can you write a method to insert a new value at the beginning of the list?',
    categories: ['Linked List', 'Insertion'],
    difficulty: 'easy',
    frequency: 67,
    tags: ['linked list', 'pointer manipulation'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Create a new node with the given value.',
      'Point its next to the current head.',
      'Return the new node as the new head.',
    ],
    optimalComplexity: {
      time: 'O(1)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  let head = null, tail = null;\n  for (let val of arr) {\n    let node = new ListNode(val);\n    if (!head) head = tail = node;\n    else tail = tail.next = node;\n  }\n  return head;\n}\n\nfunction linkedListToArray(head) {\n  const result = [];\n  while (head) {\n    result.push(head.val);\n    head = head.next;\n  }\n  return result;\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const values = n > 0 ? input[1].split(" ").map(Number) : [];\n  const val = parseInt(input[2]);\n  const head = buildLinkedList(values);\n  const newHead = insertAtHead(head, val);\n  console.log(linkedListToArray(newHead).join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_linked_list(values):\n    head = None\n    tail = None\n    for val in values:\n        node = ListNode(val)\n        if not head:\n            head = tail = node\n        else:\n            tail.next = node\n            tail = node\n    return head\n\ndef linked_list_to_list(head):\n    result = []\n    while head:\n        result.append(str(head.val))\n        head = head.next\n    return result\n\nif __name__ == "__main__":\n    import sys\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    values = list(map(int, lines[1].split())) if n > 0 else []\n    val = int(lines[2])\n    head = build_linked_list(values)\n    new_head = insert_at_head(head, val)\n    print(" ".join(linked_list_to_list(new_head)))',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function insertAtHead(head, val) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def insert_at_head(head, val):\n    # write your code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static ListNode insertAtHead(ListNode head, int val) {\n    // write your code here\n}',
      },
      {
        language: 'cpp',
        code: 'ListNode* insertAtHead(ListNode* head, int val) {\n    // write your code here\n}',
      },
    ],
  },
  {
    title: 'Insert Node at Head of Linked List',
    slug: 'insert-node-at-head-of-linked-list',
    description:
      'Insert a new node at the head (beginning) of a singly linked list.',
    problemStatement:
      'You are given a singly linked list and an integer value. Your task is to insert a new node containing the given value at the head (beginning) of the linked list and return the updated head of the list.<br><br>For example, if the linked list is `2 → 3 → 4` and the new value is `1`, then the updated linked list should be `1 → 2 → 3 → 4`.<br><br><b>Examples</b><br><br><pre><code>Input:\n3\n2 3 4\n1\nOutput:\n1 2 3 4</code></pre><br>Explanation: The new node with value 1 is inserted at the head of the linked list.<br><br><pre><code>Input:\n0\n\n5\nOutput:\n5</code></pre><br>Explanation: The list was empty, so the new node becomes the head.<br><br><b>Constraints</b><ul><li>0 ≤ number of nodes ≤ 10^5</li><li>-10^9 ≤ node value ≤ 10^9</li><li>-10^9 ≤ new value ≤ 10^9</li></ul><br><b>Pro Tip:</b> Remember that inserting at the head means creating a new node and pointing it to the old head, then updating the head reference.',
    sampleTestCases: [
      { input: '3\n2 3 4\n1', expected: '1 2 3 4' },
      { input: '0\n\n5', expected: '5' },
    ],
    testCases: [
      { input: '3\n2 3 4\n1', expected: '1 2 3 4' },
      { input: '0\n\n5', expected: '5' },
      { input: '5\n10 20 30 40 50\n100', expected: '100 10 20 30 40 50' },
      { input: '1\n7\n9', expected: '9 7' },
      { input: '2\n-5 15\n0', expected: '0 -5 15' },
      { input: '4\n100 200 300 400\n500', expected: '500 100 200 300 400' },
      { input: '6\n1 2 3 4 5 6\n-1', expected: '-1 1 2 3 4 5 6' },
      { input: '3\n9 9 9\n9', expected: '9 9 9 9' },
      {
        input: '1\n1000000000\n-1000000000',
        expected: '-1000000000 1000000000',
      },
      { input: '2\n42 43\n44', expected: '44 42 43' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Interviewer: Imagine you are working with a linked list and you need to insert a new element at the very beginning. How would you update the head pointer? Let’s try implementing this.',
    difficulty: 'easy',
    frequency: 70,
    tags: ['linked list', 'insertion'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Coding Ninjas', logoUrl: '' },
    ],
    hints: [
      'Think about how the new node should connect to the existing head.',
      'The new node’s next pointer should point to the old head.',
      'Finally, update the head to this new node.',
    ],
    optimalComplexity: { time: 'O(1)', space: 'O(1)' },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  const dummy = new ListNode(0);\n  let current = dummy;\n  for (let val of arr) {\n    current.next = new ListNode(val);\n    current = current.next;\n  }\n  return dummy.next;\n}\n\nfunction linkedListToArray(head) {\n  const result = [];\n  while (head) {\n    result.push(head.val);\n    head = head.next;\n  }\n  return result;\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const values = n > 0 ? input[1].split(" ").map(Number) : [];\n  const newVal = parseInt(input[2]);\n  let head = buildLinkedList(values);\n  head = insertAtHead(head, newVal);\n  console.log(linkedListToArray(head).join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_linked_list(values):\n    dummy = ListNode(0)\n    current = dummy\n    for val in values:\n        current.next = ListNode(val)\n        current = current.next\n    return dummy.next\n\ndef linked_list_to_list(head):\n    result = []\n    while head:\n        result.append(str(head.val))\n        head = head.next\n    return result\n\nif __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    values = list(map(int, input_lines[1].split())) if n > 0 else []\n    new_val = int(input_lines[2])\n    head = build_linked_list(values)\n    head = insertAtHead(head, new_val)\n    print(" ".join(linked_list_to_list(head)))',
      },
      {
        language: 'java',
        code: 'class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n}\n\nimport java.util.*;\nclass Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        for(int i=0;i<n;i++) {\n            curr.next = new ListNode(sc.nextInt());\n            curr = curr.next;\n        }\n        int newVal = sc.nextInt();\n        ListNode head = insertAtHead(dummy.next, newVal);\n        while(head != null) {\n            System.out.print(head.val + (head.next!=null ? " " : ""));\n            head = head.next;\n        }\n    }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* buildLinkedList(vector<int>& arr) {\n    ListNode* dummy = new ListNode(0);\n    ListNode* curr = dummy;\n    for (int val : arr) {\n        curr->next = new ListNode(val);\n        curr = curr->next;\n    }\n    return dummy->next;\n}\n\nvoid printList(ListNode* head) {\n    while (head) {\n        cout << head->val;\n        if (head->next) cout << " ";\n        head = head->next;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n; cin >> n;\n    vector<int> arr(n);\n    for (int i=0;i<n;i++) cin >> arr[i];\n    int newVal; cin >> newVal;\n    ListNode* head = buildLinkedList(arr);\n    head = insertAtHead(head, newVal);\n    printList(head);\n    return 0;\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct ListNode {\n    int val;\n    struct ListNode* next;\n} ListNode;\n\nListNode* createNode(int val) {\n    ListNode* node = (ListNode*)malloc(sizeof(ListNode));\n    node->val = val;\n    node->next = NULL;\n    return node;\n}\n\nListNode* buildLinkedList(int arr[], int n) {\n    ListNode* dummy = createNode(0);\n    ListNode* curr = dummy;\n    for (int i = 0; i < n; i++) {\n        curr->next = createNode(arr[i]);\n        curr = curr->next;\n    }\n    return dummy->next;\n}\n\nvoid printList(ListNode* head) {\n    while (head) {\n        printf("%d", head->val);\n        if (head->next) printf(" ");\n        head = head->next;\n    }\n}\n\nint main() {\n    int n; scanf("%d", &n);\n    int arr[n];\n    for (int i=0;i<n;i++) scanf("%d", &arr[i]);\n    int newVal; scanf("%d", &newVal);\n    ListNode* head = buildLinkedList(arr, n);\n    head = insertAtHead(head, newVal);\n    printList(head);\n    return 0;\n}',
      },
      {
        language: 'go',
        code: 'package main\nimport (\n    "fmt"\n)\n\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc buildLinkedList(arr []int) *ListNode {\n    dummy := &ListNode{}\n    curr := dummy\n    for _, v := range arr {\n        curr.Next = &ListNode{Val: v}\n        curr = curr.Next\n    }\n    return dummy.Next\n}\n\nfunc printList(head *ListNode) {\n    for head != nil {\n        fmt.Print(head.Val)\n        if head.Next != nil {\n            fmt.Print(" ")\n        }\n        head = head.Next\n    }\n}\n\nfunc main() {\n    var n int\n    fmt.Scan(&n)\n    arr := make([]int, n)\n    for i := 0; i < n; i++ {\n        fmt.Scan(&arr[i])\n    }\n    var newVal int\n    fmt.Scan(&newVal)\n    head := buildLinkedList(arr)\n    head = insertAtHead(head, newVal)\n    printList(head)\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction insertAtHead(head, val) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef insertAtHead(head, val):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; }\n}\n\nclass Solution {\n    public static ListNode insertAtHead(ListNode head, int val) {\n        // write code here\n        return null;\n    }\n}',
      },
      {
        language: 'cpp',
        code: 'struct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* insertAtHead(ListNode* head, int val) {\n    // write code here\n    return NULL;\n}',
      },
      {
        language: 'c',
        code: 'typedef struct ListNode {\n    int val;\n    struct ListNode* next;\n} ListNode;\n\nListNode* insertAtHead(ListNode* head, int val) {\n    // write code here\n    return NULL;\n}',
      },
      {
        language: 'go',
        code: 'type ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc insertAtHead(head *ListNode, val int) *ListNode {\n    // write code here\n    return nil\n}',
      },
    ],
  },
  {
    title: 'Insert Node at Tail of Linked List',
    slug: 'insert-node-at-tail-of-linked-list',
    description:
      'Given a singly linked list and an integer value, insert a new node with that value at the tail (end) of the list and return the head.',
    problemStatement:
      'You are given the head of a singly linked list and an integer value. Insert a new node containing the given value at the tail (end) of the linked list. If the list is empty (i.e., head is null), the new node becomes the head.<br><br>' +
      '<b>Examples</b><br>' +
      '<pre><code>Input:\n3\n2 3 4\n5\nOutput:\n2 3 4 5</code></pre><br>' +
      'If the linked list is 2 → 3 → 4 and the value is 5, after insertion it becomes 2 → 3 → 4 → 5.<br><br>' +
      '<pre><code>Input:\n0\n\n1\nOutput:\n1</code></pre><br>' +
      'If the list is empty and the value is 1, the result is just 1.<br><br>' +
      '<b>Constraints</b><ul><li>0 ≤ number of nodes ≤ 10⁵</li><li>−10⁹ ≤ node values, new value ≤ 10⁹</li></ul><br>' +
      '<b>Pro Tip:</b> Don’t forget to handle the case when the list is empty separately.',
    sampleTestCases: [
      { input: '3\n2 3 4\n5', expected: '2 3 4 5' },
      { input: '0\n\n1', expected: '1' },
    ],
    testCases: [
      { input: '3\n2 3 4\n5', expected: '2 3 4 5' },
      { input: '0\n\n1', expected: '1' },
      { input: '1\n7\n8', expected: '7 8' },
      { input: '5\n10 20 30 40 50\n60', expected: '10 20 30 40 50 60' },
      { input: '2\n-5 15\n0', expected: '-5 15 0' },
      { input: '4\n100 200 300 400\n500', expected: '100 200 300 400 500' },
      { input: '6\n1 2 3 4 5 6\n7', expected: '1 2 3 4 5 6 7' },
      { input: '3\n9 9 9\n9', expected: '9 9 9 9' },
      {
        input: '1\n1000000000\n-1000000000',
        expected: '1000000000 -1000000000',
      },
      { input: '2\n42 43\n44', expected: '42 43 44' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Interviewer: You have a linked list that may even be empty, and you need to append a value at the end. How would you approach this while keeping the implementation clean and handling edge cases?',
    difficulty: 'easy',
    frequency: 65,
    tags: ['linked list', 'insertion'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'TCS', logoUrl: '' },
      { name: 'Coding Ninjas', logoUrl: '' },
    ],
    hints: [
      'If the head is null, the new node simply becomes the head.',
      "Otherwise, traverse till the last node and link the new node to its 'next'.",
    ],
    optimalComplexity: { time: 'O(n)', space: 'O(1)' },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'c',
        code: '#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct ListNode {\n    int val;\n    struct ListNode* next;\n} ListNode;\n\nListNode* createNode(int val) {\n    ListNode* node = malloc(sizeof(ListNode));\n    node->val = val;\n    node->next = NULL;\n    return node;\n}\n\nListNode* buildLinkedList(int arr[], int n) {\n    ListNode* dummy = createNode(0);\n    ListNode* curr = dummy;\n    for (int i = 0; i < n; i++) {\n        curr->next = createNode(arr[i]);\n        curr = curr->next;\n    }\n    return dummy->next;\n}\n\nvoid printList(ListNode* head) {\n    while (head) {\n        printf("%d", head->val);\n        if (head->next) printf(" ");\n        head = head->next;\n    }\n}\n\nListNode* insertAtTail(ListNode* head, int val); // to implement\n\nint main() {\n    int n; scanf("%d", &n);\n    int arr[n]; for (int i = 0; i < n; i++) scanf("%d", &arr[i]);\n    int newVal; scanf("%d", &newVal);\n    ListNode* head = buildLinkedList(arr, n);\n    head = insertAtTail(head, newVal);\n    printList(head);\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nListNode* buildLinkedList(int arr[], int n) {\n    ListNode* dummy = new ListNode(0);\n    ListNode* curr = dummy;\n    for (int i = 0; i < n; i++) {\n        curr->next = new ListNode(arr[i]);\n        curr = curr->next;\n    }\n    return dummy->next;\n}\n\nvoid printList(ListNode* head) {\n    while (head) {\n        cout << head->val;\n        if (head->next) cout << " ";\n        head = head->next;\n    }\n}\n\nListNode* insertAtTail(ListNode* head, int val); // to implement\n\nint main() {\n    int n; cin >> n;\n    int arr[n]; for (int i = 0; i < n; i++) cin >> arr[i];\n    int newVal; cin >> newVal;\n    ListNode* head = buildLinkedList(arr, n);\n    head = insertAtTail(head, newVal);\n    printList(head);\n    return 0;\n}',
      },
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  const dummy = new ListNode();\n  let curr = dummy;\n  for (let v of arr) {\n    curr.next = new ListNode(v);\n    curr = curr.next;\n  }\n  return dummy.next;\n}\n\nfunction linkedListToArray(head) {\n  const res = [];\n  while (head) {\n    res.push(head.val);\n    head = head.next;\n  }\n  return res;\n}\n\nfunction insertAtTail(head, val) {\n  // to implement\n}\n\nfunction main(input) {\n  const lines = input.trim().split("\\n");\n  const n = parseInt(lines[0]);\n  const arr = n > 0 ? lines[1].split(" ").map(Number) : [];\n  const newVal = parseInt(lines[2]);\n  let head = buildLinkedList(arr);\n  head = insertAtTail(head, newVal);\n  console.log(linkedListToArray(head).join(" "));\n}',
      },
      {
        language: 'python',
        code: 'import sys\n\ndef build_linked_list(values):\n    class ListNode:\n        def __init__(self, val=0, next=None):\n            self.val = val\n            self.next = next\n    dummy = ListNode(0)\n    curr = dummy\n    for v in values:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next, ListNode\n\ninput_data = sys.stdin.read().strip().split()\nn = int(input_data[0])\nvalues = list(map(int, input_data[1:1+n]))\nnew_val = int(input_data[1+n])\nhead, ListNode = build_linked_list(values)\n\ndef insertAtTail(head, val):\n    # to implement\n    return head\n\nhead = insertAtTail(head, new_val)\ncurr = head\nres = []\nwhile curr:\n    res.append(str(curr.val))\n    curr = curr.next\nprint(" ".join(res))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int v) { this.val = v; }\n}\n\npublic class Solution {\n    public static ListNode buildLinkedList(int[] arr) {\n        ListNode dummy = new ListNode(0), curr = dummy;\n        for (int v : arr) {\n            curr.next = new ListNode(v);\n            curr = curr.next;\n        }\n        return dummy.next;\n    }\n\n    public static void printList(ListNode head) {\n        ListNode curr = head;\n        StringJoiner sj = new StringJoiner(" ");\n        while (curr != null) {\n            sj.add(String.valueOf(curr.val));\n            curr = curr.next;\n        }\n        System.out.println(sj);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) arr[i] = sc.nextInt();\n        int newVal = sc.nextInt();\n        ListNode head = buildLinkedList(arr);\n        head = insertAtTail(head, newVal);\n        printList(head);\n    }\n\n    public static ListNode insertAtTail(ListNode head, int val) {\n        // to implement\n        return head;\n    }\n}',
      },
    ],
    starterCode: [
      {
        language: 'c',
        code: 'ListNode* insertAtTail(ListNode* head, int val) {\n    // Write your implementation here\n    return head;\n}',
      },
      {
        language: 'cpp',
        code: 'ListNode* insertAtTail(ListNode* head, int val) {\n    // Write your implementation here\n    return head;\n}',
      },
      {
        language: 'javascript',
        code: 'function insertAtTail(head, val) {\n    // Write your implementation here\n    return head;\n}',
      },
      {
        language: 'python',
        code: 'def insertAtTail(head, val):\n    # Write your implementation here\n    return head',
      },
      {
        language: 'java',
        code: 'public static ListNode insertAtTail(ListNode head, int val) {\n    // Write your implementation here\n    return head;\n}',
      },
    ],
  },
  {
    title: 'Search Element in Linked List',
    slug: 'search-element-in-linked-list',
    description: 'Find whether a given element exists in a singly linked list.',
    problemStatement: `
Given a singly linked list and an integer \`target\`, your task is to determine whether the target exists in the list. Return \`true\` if found, otherwise return \`false\`.

You must traverse the linked list from head to tail and search for the target value.

Examples:

<pre><code>Input:
5
1 2 3 4 5
3

Output:
true</code></pre>
Explanation: The value 3 exists in the linked list.

<pre><code>Input:
4
10 20 30 40
25

Output:
false</code></pre>
Explanation: The value 25 does not exist in the linked list.

<ul>
<li>1 ≤ n ≤ 10<sup>5</sup></li>
<li>-10<sup>9</sup> ≤ node values, target ≤ 10<sup>9</sup></li>
</ul>

Pro Tip: Try traversing the linked list node by node and comparing each value with the target.
  `,
    sampleTestCases: [
      { input: '5\n1 2 3 4 5\n3', expected: 'true' },
      { input: '4\n10 20 30 40\n25', expected: 'false' },
    ],
    testCases: [
      { input: '1\n7\n7', expected: 'true' },
      { input: '1\n7\n3', expected: 'false' },
      { input: '6\n1 3 5 7 9 11\n11', expected: 'true' },
      { input: '6\n1 3 5 7 9 11\n1', expected: 'true' },
      { input: '6\n1 3 5 7 9 11\n6', expected: 'false' },
      { input: '3\n-5 -2 -3\n-3', expected: 'true' },
      { input: '3\n-5 -2 -3\n0', expected: 'false' },
      { input: '10\n1 1 1 1 1 1 1 1 1 1\n1', expected: 'true' },
      { input: '10\n2 4 6 8 10 12 14 16 18 20\n15', expected: 'false' },
      {
        input: '100000\n' + Array(99999).fill('1').join(' ') + ' 2\n2',
        expected: 'true',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're building a search system in a chain of nodes—like a treasure hunt across connected maps. You have a number and you want to know if it exists somewhere in the list. How would you do that efficiently?",
    difficulty: 'easy',
    frequency: 82,
    tags: ['linked list', 'search'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Infosys', logoUrl: '' },
    ],
    hints: [
      'Use a simple loop to walk through each node and compare the value with the target.',
      'Stop as soon as the value is found to avoid unnecessary checks.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode(0);
  let current = dummy;
  for (let val of arr) {
    current.next = new ListNode(val);
    current = current.next;
  }
  return dummy.next;
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(input[0]);
  const values = input[1].split(" ").map(Number);
  const target = parseInt(input[2]);
  const head = buildLinkedList(values);
  const result = searchElement(head, target);
  console.log(result);
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode(0)
    current = dummy
    for val in values:
        current.next = ListNode(val)
        current = current.next
    return dummy.next

if __name__ == "__main__":
    import sys
    input_lines = sys.stdin.read().strip().split("\\n")
    n = int(input_lines[0])
    values = list(map(int, input_lines[1].split()))
    target = int(input_lines[2])
    head = build_linked_list(values)
    result = searchElement(head, target)
    print(result)
`,
      },
      {
        language: 'java',
        code: `
import java.util.*;
class ListNode {
  int val;
  ListNode next;
  ListNode(int x) { val = x; }
}
public class Main {
  public static ListNode buildLinkedList(int[] arr) {
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    for (int val : arr) {
      current.next = new ListNode(val);
      current = current.next;
    }
    return dummy.next;
  }

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = Integer.parseInt(sc.nextLine());
    String[] parts = sc.nextLine().split(" ");
    int[] values = new int[n];
    for (int i = 0; i < n; i++) {
      values[i] = Integer.parseInt(parts[i]);
    }
    int target = Integer.parseInt(sc.nextLine());
    ListNode head = buildLinkedList(values);
    boolean result = searchElement(head, target);
    System.out.println(result);
  }
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function searchElement(head, target) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def searchElement(head, target):
    # write code here
    pass
`,
      },
      {
        language: 'java',
        code: `
class ListNode {
  int val;
  ListNode next;
  ListNode(int x) { val = x; }
}

public class Solution {
  public static boolean searchElement(ListNode head, int target) {
    // write code here
    return false;
  }
}
`,
      },
    ],
  },
  {
    title: 'Find Middle of Linked List',
    slug: 'find-middle-of-linked-list',
    description: 'Find the middle node of a singly linked list.',
    problemStatement: `
Given a singly linked list, return the value of the middle node. If there are two middle nodes (i.e., the list has an even number of nodes), return the second one.

You are not allowed to modify the original list. You must determine the middle node efficiently.

Examples:

<pre><code>Input:
5
1 2 3 4 5

Output:
3</code></pre>
Explanation: The middle node is 3, as it's the 3rd node in a 5-node list.

<pre><code>Input:
6
10 20 30 40 50 60

Output:
40</code></pre>
Explanation: The list has two middle nodes (30 and 40). By the rule, return the second one: 40.

<ul>
<li>1 ≤ n ≤ 10<sup>5</sup></li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
</ul>

Pro Tip: Try solving this using the slow and fast pointer technique in a single pass.
  `,
    sampleTestCases: [
      { input: '5\n1 2 3 4 5', expected: '3' },
      { input: '6\n10 20 30 40 50 60', expected: '40' },
    ],
    testCases: [
      { input: '1\n7', expected: '7' },
      { input: '2\n4 5', expected: '5' },
      { input: '3\n1 2 3', expected: '2' },
      { input: '4\n1 2 3 4', expected: '3' },
      { input: '7\n1 2 3 4 5 6 7', expected: '4' },
      { input: '8\n8 6 4 2 0 -2 -4 -6', expected: '0' },
      { input: '9\n9 8 7 6 5 4 3 2 1', expected: '5' },
      { input: '10\n1 1 1 1 1 1 1 1 1 1', expected: '6' },
      {
        input:
          '100000\n' +
          Array.from({ length: 100000 }, (_, i) => i + 1).join(' '),
        expected: '50001',
      },
      { input: '6\n-5 -4 -3 -2 -1 0', expected: '-2' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're given a chain of numbered boxes. Your goal? Quickly find the middle box. But there's a catch—you can only walk through them once. How would you do it efficiently?",
    difficulty: 'easy',
    frequency: 90,
    tags: ['linked list', 'two pointer', 'fast and slow pointer'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use two pointers: move one one step at a time and the other two steps.',
      'When the fast pointer reaches the end, the slow one will be in the middle.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode(0);
  let current = dummy;
  for (let val of arr) {
    current.next = new ListNode(val);
    current = current.next;
  }
  return dummy.next;
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(input[0]);
  const values = input[1].split(" ").map(Number);
  const head = buildLinkedList(values);
  const result = findMiddleNode(head);
  console.log(result);
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode(0)
    current = dummy
    for val in values:
        current.next = ListNode(val)
        current = current.next
    return dummy.next

if __name__ == "__main__":
    import sys
    input_lines = sys.stdin.read().strip().split("\\n")
    n = int(input_lines[0])
    values = list(map(int, input_lines[1].split()))
    head = build_linked_list(values)
    result = findMiddleNode(head)
    print(result)
`,
      },
      {
        language: 'java',
        code: `
import java.util.*;
class ListNode {
  int val;
  ListNode next;
  ListNode(int x) { val = x; }
}
public class Main {
  public static ListNode buildLinkedList(int[] arr) {
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    for (int val : arr) {
      current.next = new ListNode(val);
      current = current.next;
    }
    return dummy.next;
  }

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = Integer.parseInt(sc.nextLine());
    String[] parts = sc.nextLine().split(" ");
    int[] values = new int[n];
    for (int i = 0; i < n; i++) {
      values[i] = Integer.parseInt(parts[i]);
    }
    ListNode head = buildLinkedList(values);
    int result = findMiddleNode(head);
    System.out.println(result);
  }
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function findMiddleNode(head) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def findMiddleNode(head):
    # write code here
    pass
`,
      },
      {
        language: 'java',
        code: `
class ListNode {
  int val;
  ListNode next;
  ListNode(int x) { val = x; }
}

public class Solution {
  public static int findMiddleNode(ListNode head) {
    // write code here
    return -1;
  }
}
`,
      },
    ],
  },
  {
    title: 'Reverse a Linked List (Iterative)',
    slug: 'reverse-a-linked-list-iterative',
    description: 'Reverse a singly linked list using an iterative approach.',
    problemStatement: `
You are given the head of a singly linked list. Your task is to reverse the list using an iterative method and return the new head.

Do not use recursion. You must reverse the links between the nodes, not just the values.

Examples:

<pre><code>Input:
5
1 2 3 4 5

Output:
5 4 3 2 1</code></pre>
Explanation: After reversing the list, the order of nodes is reversed.

<pre><code>Input:
3
10 20 30

Output:
30 20 10</code></pre>
Explanation: The reversed list has elements in opposite order.

<ul>
<li>0 ≤ n ≤ 10<sup>5</sup></li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
</ul>

Pro Tip: Keep track of the previous node while iterating and adjust pointers as you go. 
  `,
    sampleTestCases: [
      { input: '5\n1 2 3 4 5', expected: '5 4 3 2 1' },
      { input: '3\n10 20 30', expected: '30 20 10' },
    ],
    testCases: [
      { input: '0\n', expected: '' },
      { input: '1\n42', expected: '42' },
      { input: '2\n9 8', expected: '8 9' },
      { input: '4\n1 3 5 7', expected: '7 5 3 1' },
      { input: '6\n6 5 4 3 2 1', expected: '1 2 3 4 5 6' },
      { input: '3\n-1 0 1', expected: '1 0 -1' },
      { input: '5\n5 5 5 5 5', expected: '5 5 5 5 5' },
      { input: '10\n1 2 3 4 5 6 7 8 9 10', expected: '10 9 8 7 6 5 4 3 2 1' },
      {
        input:
          '100000\n' +
          Array.from({ length: 100000 }, (_, i) => i + 1).join(' '),
        expected: Array.from({ length: 100000 }, (_, i) => 100000 - i).join(
          ' ',
        ),
      },
      { input: '7\n11 22 33 44 55 66 77', expected: '77 66 55 44 33 22 11' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Let’s say you're working with data stored sequentially in memory, but you want to access it in the reverse order. How would you reverse a singly linked list, node by node, without recursion?",
    difficulty: 'easy',
    frequency: 88,
    tags: ['linked list', 'iterative', 'pointer manipulation'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Flipkart', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use three pointers: prev, current, and next.',
      "Iteratively reverse the current node's pointer to the previous node.",
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode(0);
  let current = dummy;
  for (let val of arr) {
    current.next = new ListNode(val);
    current = current.next;
  }
  return dummy.next;
}

function linkedListToArray(head) {
  const result = [];
  while (head) {
    result.push(head.val);
    head = head.next;
  }
  return result;
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(input[0]);
  const values = n === 0 ? [] : input[1].split(" ").map(Number);
  const head = buildLinkedList(values);
  const newHead = reverseList(head);
  const output = linkedListToArray(newHead);
  console.log(output.join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode(0)
    current = dummy
    for val in values:
        current.next = ListNode(val)
        current = current.next
    return dummy.next

def linked_list_to_list(head):
    result = []
    while head:
        result.append(str(head.val))
        head = head.next
    return result

if __name__ == "__main__":
    import sys
    input_lines = sys.stdin.read().strip().split("\\n")
    n = int(input_lines[0])
    values = list(map(int, input_lines[1].split())) if n > 0 else []
    head = build_linked_list(values)
    new_head = reverseList(head)
    print(" ".join(linked_list_to_list(new_head)))
`,
      },
      {
        language: 'java',
        code: `
import java.util.*;
class ListNode {
  int val;
  ListNode next;
  ListNode(int x) { val = x; }
}
public class Main {
  public static ListNode buildLinkedList(int[] arr) {
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    for (int val : arr) {
      current.next = new ListNode(val);
      current = current.next;
    }
    return dummy.next;
  }

  public static List<Integer> linkedListToArray(ListNode head) {
    List<Integer> list = new ArrayList<>();
    while (head != null) {
      list.add(head.val);
      head = head.next;
    }
    return list;
  }

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = Integer.parseInt(sc.nextLine());
    int[] values = new int[n];
    if (n > 0) {
      String[] parts = sc.nextLine().split(" ");
      for (int i = 0; i < n; i++) {
        values[i] = Integer.parseInt(parts[i]);
      }
    }
    ListNode head = buildLinkedList(values);
    ListNode newHead = reverseList(head);
    List<Integer> output = linkedListToArray(newHead);
    for (int val : output) {
      System.out.print(val + " ");
    }
  }
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function reverseList(head) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    # write code here
    pass
`,
      },
      {
        language: 'java',
        code: `
class ListNode {
  int val;
  ListNode next;
  ListNode(int x) { val = x; }
}

public class Solution {
  public static ListNode reverseList(ListNode head) {
    // write code here
    return null;
  }
}
`,
      },
    ],
  },
  {
    title: 'Reverse a Linked List (Recursive)',
    slug: 'reverse-a-linked-list-recursive',
    description: 'Reverse a singly linked list using a recursive approach.',
    problemStatement: `
You are given the head of a singly linked list. Your task is to reverse the list using a recursive method and return the new head.

Do not use iteration. You must reverse the links between the nodes using recursion only.

Examples:

<pre><code>Input:
5
1 2 3 4 5

Output:
5 4 3 2 1</code></pre>
Explanation: The list is reversed recursively.

<pre><code>Input:
3
10 20 30

Output:
30 20 10</code></pre>
Explanation: The list is reversed by changing the links between nodes recursively.

<ul>
<li>0 ≤ n ≤ 10<sup>5</sup></li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
</ul>

Pro Tip: Think of reversing the rest of the list and then fixing the current node's pointer.
  `,
    sampleTestCases: [
      { input: '5\n1 2 3 4 5', expected: '5 4 3 2 1' },
      { input: '3\n10 20 30', expected: '30 20 10' },
    ],
    testCases: [
      { input: '0\n', expected: '' },
      { input: '1\n42', expected: '42' },
      { input: '2\n9 8', expected: '8 9' },
      { input: '4\n1 3 5 7', expected: '7 5 3 1' },
      { input: '6\n6 5 4 3 2 1', expected: '1 2 3 4 5 6' },
      { input: '3\n-1 0 1', expected: '1 0 -1' },
      { input: '5\n5 5 5 5 5', expected: '5 5 5 5 5' },
      { input: '10\n1 2 3 4 5 6 7 8 9 10', expected: '10 9 8 7 6 5 4 3 2 1' },
      { input: '6\n11 22 33 44 55 66', expected: '66 55 44 33 22 11' },
      { input: '7\n0 -1 -2 -3 -4 -5 -6', expected: '-6 -5 -4 -3 -2 -1 0' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Imagine you’re walking through a maze of connected rooms. Instead of retracing your steps, you flip the connections as you go back. How would you reverse a linked list using recursion?',
    difficulty: 'medium',
    frequency: 76,
    tags: ['linked list', 'recursion'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
      { name: 'Flipkart', logoUrl: '' },
    ],
    hints: [
      'Use a helper function to reverse the rest of the list first.',
      'Then adjust the current node’s next pointer after the recursive call.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode(0);
  let current = dummy;
  for (let val of arr) {
    current.next = new ListNode(val);
    current = current.next;
  }
  return dummy.next;
}

function linkedListToArray(head) {
  const result = [];
  while (head) {
    result.push(head.val);
    head = head.next;
  }
  return result;
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(input[0]);
  const values = n === 0 ? [] : input[1].split(" ").map(Number);
  const head = buildLinkedList(values);
  const newHead = reverseListRecursive(head);
  const output = linkedListToArray(newHead);
  console.log(output.join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode(0)
    current = dummy
    for val in values:
        current.next = ListNode(val)
        current = current.next
    return dummy.next

def linked_list_to_list(head):
    result = []
    while head:
        result.append(str(head.val))
        head = head.next
    return result

if __name__ == "__main__":
    import sys
    input_lines = sys.stdin.read().strip().split("\\n")
    n = int(input_lines[0])
    values = list(map(int, input_lines[1].split())) if n > 0 else []
    head = build_linked_list(values)
    new_head = reverseListRecursive(head)
    print(" ".join(linked_list_to_list(new_head)))
`,
      },
      {
        language: 'java',
        code: `
import java.util.*;
class ListNode {
  int val;
  ListNode next;
  ListNode(int x) { val = x; }
}
public class Main {
  public static ListNode buildLinkedList(int[] arr) {
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    for (int val : arr) {
      current.next = new ListNode(val);
      current = current.next;
    }
    return dummy.next;
  }

  public static List<Integer> linkedListToArray(ListNode head) {
    List<Integer> list = new ArrayList<>();
    while (head != null) {
      list.add(head.val);
      head = head.next;
    }
    return list;
  }

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = Integer.parseInt(sc.nextLine());
    int[] values = new int[n];
    if (n > 0) {
      String[] parts = sc.nextLine().split(" ");
      for (int i = 0; i < n; i++) {
        values[i] = Integer.parseInt(parts[i]);
      }
    }
    ListNode head = buildLinkedList(values);
    ListNode newHead = reverseListRecursive(head);
    List<Integer> output = linkedListToArray(newHead);
    for (int val : output) {
      System.out.print(val + " ");
    }
  }
}`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function reverseListRecursive(head) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseListRecursive(head):
    # write code here
    pass
`,
      },
      {
        language: 'java',
        code: `
class ListNode {
  int val;
  ListNode next;
  ListNode(int x) { val = x; }
}

public class Solution {
  public static ListNode reverseListRecursive(ListNode head) {
    // write code here
    return null;
  }
}
`,
      },
    ],
  },
  {
    title: 'Check if Linked List is Palindrome',
    slug: 'check-if-linked-list-is-palindrome',
    description: 'Determine whether a singly linked list is a palindrome.',
    problemStatement: `
Given the head of a singly linked list, return **true** if the list is a palindrome, otherwise return **false**. A palindrome reads the same forward and backward.

Examples:

<pre><code>Input:
1 2 2 1

Output:
true</code></pre>
Explanation: The linked list reads the same forwards and backwards.

<pre><code>Input:
1 2 3 2 1

Output:
true</code></pre>
Explanation: It is symmetric around its center node.

<pre><code>Input:
1 2 3

Output:
false</code></pre>
Explanation: 1->2->3 does not read the same backwards.

<ul>
<li>You must solve the problem in <strong>O(n)</strong> time and <strong>O(1)</strong> extra space (excluding input).</li>
<li>You're allowed to modify the list temporarily but should restore it if needed.</li>
</ul>

Pro Tip: Use the fast-and-slow pointer technique to find the midpoint, reverse the second half in place, compare the two halves, then (optionally) restore the original list.
  `,
    sampleTestCases: [
      { input: '4\n1 2 2 1', expected: 'true' },
      { input: '5\n1 2 3 2 1', expected: 'true' },
      { input: '3\n1 2 3', expected: 'false' },
    ],
    testCases: [
      { input: '0\n', expected: 'true' },
      { input: '1\n5', expected: 'true' },
      { input: '2\n7 7', expected: 'true' },
      { input: '2\n7 8', expected: 'false' },
      { input: '3\n1 2 1', expected: 'true' },
      { input: '4\n1 2 3 1', expected: 'false' },
      { input: '6\n1 2 3 3 2 1', expected: 'true' },
      { input: '6\n1 2 3 4 2 1', expected: 'false' },
      { input: '7\n1 0 -1 0 1 0 1', expected: 'false' },
      {
        input: '100000\n' + Array.from({ length: 100000 }, () => '1').join(' '),
        expected: 'true',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Imagine you have a sequence of widgets arranged in a line. You want to check if the sequence reads the same forwards and backwards. How would you do that in one pass with constant space?',
    difficulty: 'easy',
    frequency: 85,
    tags: ['linked list', 'two pointers', 'in‑place reversal', 'palindrome'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Find the mid‑point using slow and fast pointers.',
      'Reverse the second half in place and then compare the two halves.',
      'Optionally restore the list by reversing the second half back.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode(0);
  let cur = dummy;
  for (let v of arr) {
    cur.next = new ListNode(v);
    cur = cur.next;
  }
  return dummy.next;
}

function linkedListToArray(head) {
  const ans = [];
  while (head) {
    ans.push(head.val);
    head = head.next;
  }
  return ans;
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(input[0] || "0");
  const values = n > 0 ? input[1].split(" ").map(Number) : [];
  const head = buildLinkedList(values);
  const result = isPalindrome(head);
  console.log(result);
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(vals):
    dummy = ListNode()
    cur = dummy
    for v in vals:
        cur.next = ListNode(v)
        cur = cur.next
    return dummy.next

def linked_list_to_list(head):
    res = []
    while head:
        res.append(str(head.val))
        head = head.next
    return res

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0]) if lines else 0
    vals = list(map(int, lines[1].split())) if n > 0 else []
    head = build_linked_list(vals)
    print(isPalindrome(head))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function isPalindrome(head) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def isPalindrome(head):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Detect Loop in Linked List',
    slug: 'detect-loop-in-linked-list',
    description: 'Check if a singly linked list contains a cycle (loop).',
    problemStatement: `
Given the head of a singly linked list, determine if the linked list contains a cycle.

A cycle occurs when a node's next pointer points back to a previous node in the list. Return **true** if there is a cycle in the list, otherwise return **false**.

Note: You must solve this in **O(n)** time and **O(1)** space.

Examples:

<pre><code>Input:
5
1 2 3 4 5
2

Output:
true</code></pre>
Explanation: A cycle is formed by connecting the next pointer of the last node to the node at index 2 (0-based).

<pre><code>Input:
4
1 2 3 4
-1

Output:
false</code></pre>
Explanation: No cycle, as the last node does not point to any previous node.

<ul>
<li>0 ≤ n ≤ 10<sup>5</sup></li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
<li>The cycle index (if any) is within 0 ≤ index &lt; n or -1 if no cycle.</li>
</ul>

Pro Tip: Use Floyd's Cycle Detection Algorithm (slow and fast pointer technique).
  `,
    sampleTestCases: [
      { input: '5\n1 2 3 4 5\n2', expected: 'true' },
      { input: '4\n1 2 3 4\n-1', expected: 'false' },
    ],
    testCases: [
      { input: '0\n\n-1', expected: 'false' },
      { input: '1\n99\n-1', expected: 'false' },
      { input: '2\n7 8\n0', expected: 'true' },
      { input: '2\n7 8\n-1', expected: 'false' },
      { input: '3\n1 2 3\n1', expected: 'true' },
      { input: '4\n10 20 30 40\n2', expected: 'true' },
      { input: '4\n10 20 30 40\n-1', expected: 'false' },
      { input: '6\n1 2 3 4 5 6\n0', expected: 'true' },
      { input: '6\n1 2 3 4 5 6\n-1', expected: 'false' },
      {
        input: '100000\n' + Array(100000).fill('1').join(' ') + '\n0',
        expected: 'true',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're traversing a chain of rooms, each leading to the next. You need to find out if you're going in circles. Can you detect a loop efficiently?",
    difficulty: 'medium',
    frequency: 92,
    tags: ['linked list', 'floyd cycle detection', 'two pointer'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use two pointers moving at different speeds.',
      'If they ever meet, a cycle exists.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedListWithCycle(arr, pos) {
  const dummy = new ListNode(0);
  let current = dummy;
  let cycleNode = null;

  arr.forEach((val, index) => {
    current.next = new ListNode(val);
    current = current.next;
    if (index === pos) cycleNode = current;
  });

  if (pos !== -1) current.next = cycleNode;
  return dummy.next;
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(input[0]);
  const values = n ? input[1].split(" ").map(Number) : [];
  const cycleIndex = parseInt(input[2]);
  const head = buildLinkedListWithCycle(values, cycleIndex);
  const result = hasCycle(head);
  console.log(result);
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list_with_cycle(values, pos):
    dummy = ListNode(0)
    current = dummy
    cycle_node = None
    for idx, val in enumerate(values):
        current.next = ListNode(val)
        current = current.next
        if idx == pos:
            cycle_node = current
    if pos != -1:
        current.next = cycle_node
    return dummy.next

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0])
    values = list(map(int, lines[1].split())) if n else []
    pos = int(lines[2])
    head = build_linked_list_with_cycle(values, pos)
    print(hasCycle(head))
`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function hasCycle(head) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def hasCycle(head):
    # write code here
    pass
`,
      },
    ],
  },
  {
    title: 'Detect and Remove Loop in Linked List',
    slug: 'detect-and-remove-loop-in-linked-list',
    description:
      'Detect and remove a cycle from a singly linked list, if it exists.',
    problemStatement: `
Given the head of a singly linked list, detect whether a cycle exists. If it does, remove the cycle and return the head of the updated list.

You must use O(n) time and O(1) space.

Examples:

<pre><code>Input:
6
1 2 3 4 5 6
2

Output:
1 2 3 4 5 6</code></pre>
Explanation: A loop is created from node 6 to node 3. After removal, the list becomes linear.

<pre><code>Input:
4
10 20 30 40
-1

Output:
10 20 30 40</code></pre>
Explanation: No loop exists. List remains unchanged.

<ul>
<li>0 ≤ n ≤ 10<sup>5</sup></li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
<li>Loop position is 0-based index or -1 if no loop.</li>
</ul>

Pro Tip: Use Floyd's Cycle Detection to find a loop. To remove it, find the start of the cycle and set the previous node’s next to null.
  `,
    sampleTestCases: [
      { input: '6\n1 2 3 4 5 6\n2', expected: '1 2 3 4 5 6' },
      { input: '4\n10 20 30 40\n-1', expected: '10 20 30 40' },
    ],
    testCases: [
      { input: '0\n\n-1', expected: '' },
      { input: '1\n7\n0', expected: '7' },
      { input: '1\n7\n-1', expected: '7' },
      { input: '2\n1 2\n0', expected: '1 2' },
      { input: '5\n1 2 3 4 5\n1', expected: '1 2 3 4 5' },
      { input: '7\n9 8 7 6 5 4 3\n3', expected: '9 8 7 6 5 4 3' },
      { input: '8\n1 2 3 4 5 6 7 8\n-1', expected: '1 2 3 4 5 6 7 8' },
      { input: '6\n10 20 30 40 50 60\n0', expected: '10 20 30 40 50 60' },
      {
        input: '10\n1 2 3 4 5 6 7 8 9 10\n4',
        expected: '1 2 3 4 5 6 7 8 9 10',
      },
      {
        input: '100000\n' + Array(100000).fill('1').join(' ') + '\n0',
        expected: Array(100000).fill('1').join(' '),
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're tracking connections in a network. If something loops back creating a cycle, you need to find and break it cleanly. Can you do that efficiently?",
    difficulty: 'medium',
    frequency: 89,
    tags: ['linked list', 'cycle detection', 'floyd', 'two pointer'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Detect the cycle using slow and fast pointers.',
      'To remove, find the node just before the start of the loop and set its next to null.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedListWithCycle(arr, pos) {
  const dummy = new ListNode(0);
  let current = dummy;
  let cycleNode = null;

  arr.forEach((val, index) => {
    current.next = new ListNode(val);
    current = current.next;
    if (index === pos) cycleNode = current;
  });

  if (pos !== -1) current.next = cycleNode;
  return dummy.next;
}

function linkedListToArray(head) {
  const result = [];
  const visited = new Set();
  while (head && !visited.has(head)) {
    visited.add(head);
    result.push(head.val);
    head = head.next;
  }
  return result;
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(input[0]);
  const values = n ? input[1].split(" ").map(Number) : [];
  const cycleIndex = parseInt(input[2]);
  const head = buildLinkedListWithCycle(values, cycleIndex);
  const fixedHead = removeLoop(head);
  console.log(linkedListToArray(fixedHead).join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list_with_cycle(values, pos):
    dummy = ListNode(0)
    current = dummy
    cycle_node = None
    for i, val in enumerate(values):
        current.next = ListNode(val)
        current = current.next
        if i == pos:
            cycle_node = current
    if pos != -1:
        current.next = cycle_node
    return dummy.next

def linked_list_to_list(head):
    result = []
    seen = set()
    while head and head not in seen:
        result.append(str(head.val))
        seen.add(head)
        head = head.next
    return result

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0])
    values = list(map(int, lines[1].split())) if n else []
    pos = int(lines[2])
    head = build_linked_list_with_cycle(values, pos)
    head = removeLoop(head)
    print(" ".join(linked_list_to_list(head)))
`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function removeLoop(head) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def removeLoop(head):
    # write code here
    pass
`,
      },
    ],
  },
  {
    title: 'Find the Starting Point of Cycle',
    slug: 'find-starting-point-of-cycle',
    description:
      'Identify the node where a cycle begins in a linked list, if a cycle exists.',
    problemStatement: `
Given the head of a singly linked list, return the node where the cycle begins. If there is no cycle, return null.

You must solve it using O(n) time and O(1) space.

Examples:

<pre><code>Input:
6
1 2 3 4 5 6
2

Output:
3</code></pre>
Explanation: A cycle starts at node with value 3 (index 2). The function returns that node’s value.

<pre><code>Input:
4
10 20 30 40
-1

Output:
null</code></pre>
Explanation: No cycle exists.

<ul>
<li>0 ≤ n ≤ 10<sup>5</sup></li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
<li>Loop position is the index in input, or -1 if no loop</li>
</ul>

Pro Tip: Use Floyd’s cycle detection to find intersection, then move one pointer to head and find the entry point of the loop.
  `,
    sampleTestCases: [
      { input: '6\n1 2 3 4 5 6\n2', expected: '3' },
      { input: '4\n10 20 30 40\n-1', expected: 'null' },
    ],
    testCases: [
      { input: '0\n\n-1', expected: 'null' },
      { input: '1\n7\n0', expected: '7' },
      { input: '1\n7\n-1', expected: 'null' },
      { input: '2\n5 6\n0', expected: '5' },
      { input: '5\n1 2 3 4 5\n2', expected: '3' },
      { input: '7\n9 8 7 6 5 4 3\n3', expected: '6' },
      { input: '6\n10 20 30 40 50 60\n-1', expected: 'null' },
      { input: '10\n1 2 3 4 5 6 7 8 9 10\n4', expected: '5' },
      {
        input: '100000\n' + Array(100000).fill('1').join(' ') + '\n0',
        expected: '1',
      },
      { input: '4\n11 12 13 14\n1', expected: '12' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Suppose you're following a track in a game and realize you're looping. Can you identify the exact point where the loop starts?",
    difficulty: 'medium',
    frequency: 93,
    tags: ['linked list', 'cycle detection', 'floyd', 'two pointer'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use the slow and fast pointer to detect a cycle.',
      'Then reset one pointer to the head and move both one step at a time.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedListWithCycle(arr, pos) {
  const dummy = new ListNode(0);
  let current = dummy;
  let cycleNode = null;

  arr.forEach((val, idx) => {
    current.next = new ListNode(val);
    current = current.next;
    if (idx === pos) cycleNode = current;
  });

  if (pos !== -1) current.next = cycleNode;
  return dummy.next;
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(input[0]);
  const values = n ? input[1].split(" ").map(Number) : [];
  const cycleIndex = parseInt(input[2]);
  const head = buildLinkedListWithCycle(values, cycleIndex);
  const result = detectCycleStart(head);
  console.log(result ? result.val : "null");
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list_with_cycle(values, pos):
    dummy = ListNode(0)
    current = dummy
    cycle_node = None
    for i, val in enumerate(values):
        current.next = ListNode(val)
        current = current.next
        if i == pos:
            cycle_node = current
    if pos != -1:
        current.next = cycle_node
    return dummy.next

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0])
    values = list(map(int, lines[1].split())) if n else []
    pos = int(lines[2])
    head = build_linked_list_with_cycle(values, pos)
    node = detectCycleStart(head)
    print(node.val if node else "null")`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function detectCycleStart(head) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def detectCycleStart(head):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Length of Loop in Linked List',
    slug: 'length-of-loop-in-linked-list',
    description:
      'Find the number of nodes in the cycle of a singly linked list.',
    problemStatement: `
Given the head of a singly linked list, return the length of the cycle if a cycle is present. If there is no cycle, return 0.

You must solve this in **O(n)** time and **O(1)** space.

Examples:

<pre><code>Input:
6
1 2 3 4 5 6
2

Output:
4</code></pre>
Explanation: A cycle is formed starting at node 3. The loop includes nodes 3 → 4 → 5 → 6 → 3, so the length is 4.

<pre><code>Input:
4
10 20 30 40
-1

Output:
0</code></pre>
Explanation: No cycle exists in the list.

<ul>
<li>0 ≤ n ≤ 10<sup>5</sup></li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
<li>Loop index is the 0-based position or -1 for no loop.</li>
</ul>

Pro Tip: Use Floyd's cycle detection. Once a loop is detected, keep one pointer fixed and move the other until they meet again to count the cycle length.
  `,
    sampleTestCases: [
      { input: '6\n1 2 3 4 5 6\n2', expected: '4' },
      { input: '4\n10 20 30 40\n-1', expected: '0' },
    ],
    testCases: [
      { input: '0\n\n-1', expected: '0' },
      { input: '1\n7\n0', expected: '1' },
      { input: '1\n7\n-1', expected: '0' },
      { input: '2\n1 2\n0', expected: '2' },
      { input: '5\n1 2 3 4 5\n2', expected: '3' },
      { input: '7\n9 8 7 6 5 4 3\n3', expected: '4' },
      { input: '6\n10 20 30 40 50 60\n-1', expected: '0' },
      { input: '10\n1 2 3 4 5 6 7 8 9 10\n4', expected: '6' },
      {
        input: '100000\n' + Array(100000).fill('1').join(' ') + '\n0',
        expected: '100000',
      },
      { input: '4\n11 12 13 14\n1', expected: '3' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You know a loop exists, but how big is it? Imagine running in circles—can you count the number of steps it takes to return to your starting point?',
    difficulty: 'medium',
    frequency: 80,
    tags: ['linked list', 'floyd', 'cycle detection'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      "Use Floyd's cycle detection to confirm the loop.",
      'After detecting the cycle, use a single pointer to count the number of unique nodes in the cycle.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedListWithCycle(arr, pos) {
  const dummy = new ListNode(0);
  let current = dummy;
  let cycleNode = null;

  arr.forEach((val, idx) => {
    current.next = new ListNode(val);
    current = current.next;
    if (idx === pos) cycleNode = current;
  });

  if (pos !== -1) current.next = cycleNode;
  return dummy.next;
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(input[0]);
  const values = n ? input[1].split(" ").map(Number) : [];
  const pos = parseInt(input[2]);
  const head = buildLinkedListWithCycle(values, pos);
  const result = cycleLength(head);
  console.log(result);
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list_with_cycle(values, pos):
    dummy = ListNode(0)
    current = dummy
    cycle_node = None
    for i, val in enumerate(values):
        current.next = ListNode(val)
        current = current.next
        if i == pos:
            cycle_node = current
    if pos != -1:
        current.next = cycle_node
    return dummy.next

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0])
    values = list(map(int, lines[1].split())) if n else []
    pos = int(lines[2])
    head = build_linked_list_with_cycle(values, pos)
    print(cycleLength(head))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function cycleLength(head) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def cycleLength(head):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Happy Number (Linked List Cycle Variation)',
    slug: 'happy-number-linked-list-cycle-variation',
    description:
      'Determine if a number is a happy number using cycle detection logic.',
    problemStatement: `
A **happy number** is a number defined by the following process:

Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number either equals 1 (where it will stay), or it loops endlessly in a cycle that does not include 1.

Those numbers for which this process ends in 1 are happy numbers.

Return **true** if the input number is a happy number, and **false** if it loops endlessly.

Examples:

<pre><code>Input:
19

Output:
true</code></pre>
Explanation: 1² + 9² = 82 → 8² + 2² = 68 → 6² + 8² = 100 → 1² + 0² + 0² = 1

<pre><code>Input:
2

Output:
false</code></pre>
Explanation: 2 → 4 → 16 → 37 → ... enters a loop and never reaches 1

<ul>
<li>1 ≤ n ≤ 2<sup>31</sup> - 1</li>
</ul>

Pro Tip: Use Floyd’s cycle detection to detect loops without storing the history.
  `,
    sampleTestCases: [
      { input: '19', expected: 'true' },
      { input: '2', expected: 'false' },
    ],
    testCases: [
      { input: '1', expected: 'true' },
      { input: '7', expected: 'true' },
      { input: '4', expected: 'false' },
      { input: '10', expected: 'true' },
      { input: '100', expected: 'true' },
      { input: '116', expected: 'false' },
      { input: '145', expected: 'false' },
      { input: '989', expected: 'true' },
      { input: '444', expected: 'false' },
      { input: '9999', expected: 'false' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re asked to analyze a process that transforms a number by squaring its digits repeatedly. Can you detect whether it falls into a cycle?',
    difficulty: 'easy',
    frequency: 78,
    tags: ['math', 'linked list', 'cycle detection', 'floyd'],
    companies: [
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Treat each new number as a node in a process like a linked list.',
      'Use the slow and fast pointer approach to detect cycles.',
    ],
    optimalComplexity: {
      time: 'O(log n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
const fs = require("fs");
function main() {
  const n = parseInt(fs.readFileSync(0, "utf-8").trim());
  console.log(isHappy(n));
}
main();`,
      },
      {
        language: 'python',
        code: `
if __name__ == "__main__":
    import sys
    n = int(sys.stdin.read().strip())
    print(isHappy(n))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function isHappy(n) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def isHappy(n):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Find Intersection Point of Two Linked Lists',
    slug: 'find-intersection-point-of-two-linked-lists',
    description:
      'Return the node where two singly linked lists intersect, or null if no intersection exists.',
    problemStatement: `
Given the heads of two singly linked lists \`headA\` and \`headB\`, return the node where the two lists intersect. If the two linked lists have no intersection at all, return \`null\`.

Note:
- The intersection is defined based on reference, not value. That is, if the kth node of both lists is the same by reference, then they intersect there.
- You must solve it in O(n) time and O(1) space.

Examples:

<pre><code>Input:
3
4 1 8
4
5 6 1 8
2

Output:
8</code></pre>
Explanation: The lists intersect at the node with value 8 (position 2 in list A and 3 in list B).

<pre><code>Input:
2
2 6
3
1 5 9
-1

Output:
null</code></pre>
Explanation: No intersection exists.

<ul>
<li>0 ≤ length of each list ≤ 10<sup>5</sup></li>
<li>Intersection index: -1 if no intersection, otherwise valid index in list A</li>
</ul>

Pro Tip: Use the two-pointer switching approach to align pointers at the same distance from the end of both lists.
  `,
    sampleTestCases: [
      { input: '3\n4 1 8\n4\n5 6 1 8\n2', expected: '8' },
      { input: '2\n2 6\n3\n1 5 9\n-1', expected: 'null' },
    ],
    testCases: [
      { input: '0\n\n0\n\n-1', expected: 'null' },
      { input: '1\n7\n1\n7\n0', expected: '7' },
      { input: '1\n7\n1\n8\n-1', expected: 'null' },
      { input: '2\n9 10\n3\n1 2 10\n1', expected: '10' },
      { input: '3\n3 4 5\n2\n2 5\n2', expected: '5' },
      { input: '5\n1 2 3 4 5\n3\n9 8 7\n2', expected: '4' },
      { input: '5\n5 6 7 8 9\n1\n0\n3', expected: '8' },
      { input: '3\n1 2 3\n3\n4 5 6\n-1', expected: 'null' },
      { input: '3\n1 2 3\n3\n1 2 3\n2', expected: '3' },
      { input: '4\n10 20 30 40\n4\n1 2 3 40\n3', expected: '40' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're given two linked lists that may converge at a node. Can you find the first intersecting point efficiently?",
    difficulty: 'medium',
    frequency: 94,
    tags: ['linked list', 'intersection', 'two pointers'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Use two pointers and traverse both lists.',
      'Switch heads when reaching the end to align both pointers.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedLists(aVals, bVals, intersectIndex) {
  let shared = null;
  let dummyA = new ListNode(0), dummyB = new ListNode(0);
  let curA = dummyA, curB = dummyB;

  aVals.forEach((val, idx) => {
    const newNode = new ListNode(val);
    curA.next = newNode;
    curA = curA.next;
    if (idx === intersectIndex) shared = newNode;
  });

  bVals.forEach((val, idx) => {
    if (idx === bVals.length - 1 && shared) {
      curB.next = shared;
    } else {
      curB.next = new ListNode(val);
      curB = curB.next;
    }
  });

  return [dummyA.next, dummyB.next];
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const na = parseInt(input[0]);
  const aVals = na ? input[1].split(" ").map(Number) : [];
  const nb = parseInt(input[2]);
  const bVals = nb ? input[3].split(" ").map(Number) : [];
  const intersectIndex = parseInt(input[4]);

  const [headA, headB] = buildLinkedLists(aVals, bVals, intersectIndex);
  const node = getIntersectionNode(headA, headB);
  console.log(node ? node.val : "null");
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_lists(a_vals, b_vals, ix):
    shared = None
    dummyA = ListNode()
    dummyB = ListNode()
    curA = dummyA
    curB = dummyB
    for i, v in enumerate(a_vals):
        curA.next = ListNode(v)
        curA = curA.next
        if i == ix:
            shared = curA
    for i, v in enumerate(b_vals):
        if i == len(b_vals) - 1 and shared:
            curB.next = shared
        else:
            curB.next = ListNode(v)
            curB = curB.next
    return dummyA.next, dummyB.next

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    na = int(lines[0])
    a_vals = list(map(int, lines[1].split())) if na else []
    nb = int(lines[2])
    b_vals = list(map(int, lines[3].split())) if nb else []
    ix = int(lines[4])
    headA, headB = build_linked_lists(a_vals, b_vals, ix)
    node = getIntersectionNode(headA, headB)
    print(node.val if node else "null")`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function getIntersectionNode(headA, headB) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def getIntersectionNode(headA, headB):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Check if Two Linked Lists Merge',
    slug: 'check-if-two-linked-lists-merge',
    description: 'Determine whether two singly linked lists merge at any node.',
    problemStatement: `
Given the heads of two singly linked lists \`headA\` and \`headB\`, determine whether the two lists merge at some node.

Two linked lists merge if they share a common node by reference (not just value). Return **true** if they merge, otherwise **false**.

You must do this in O(n) time and O(1) space.

Examples:

<pre><code>Input:
3
4 1 8
4
5 6 1 8
2

Output:
true</code></pre>
Explanation: Lists merge at node with value 8.

<pre><code>Input:
2
1 2
2
3 4
-1

Output:
false</code></pre>
Explanation: The two lists are separate and do not merge.

<ul>
<li>0 ≤ length of each list ≤ 10<sup>5</sup></li>
<li>Intersection index: -1 if no merge, otherwise valid index in list A</li>
</ul>

Pro Tip: You can reuse the tail checking logic — if the tails of both lists are the same by reference, they must merge.
  `,
    sampleTestCases: [
      { input: '3\n4 1 8\n4\n5 6 1 8\n2', expected: 'true' },
      { input: '2\n1 2\n2\n3 4\n-1', expected: 'false' },
    ],
    testCases: [
      { input: '0\n\n0\n\n-1', expected: 'false' },
      { input: '1\n7\n1\n7\n0', expected: 'true' },
      { input: '1\n7\n1\n8\n-1', expected: 'false' },
      { input: '2\n9 10\n3\n1 2 10\n1', expected: 'true' },
      { input: '5\n1 2 3 4 5\n3\n6 7 5\n4', expected: 'true' },
      { input: '4\n5 6 7 8\n2\n9 10\n3', expected: 'true' },
      { input: '3\n1 2 3\n3\n4 5 6\n-1', expected: 'false' },
      { input: '6\n1 2 3 4 5 6\n6\n6 5 4 3 2 1\n-1', expected: 'false' },
      { input: '3\n1 2 3\n3\n1 2 3\n2', expected: 'true' },
      { input: '4\n10 20 30 40\n4\n1 2 3 40\n3', expected: 'true' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re given two paths, and you need to check if they ever merge at some point. Can you detect it without using extra memory?',
    difficulty: 'easy',
    frequency: 84,
    tags: ['linked list', 'intersection'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Walmart', logoUrl: '' },
    ],
    hints: [
      'Two lists that merge will have the same tail node.',
      'Compare the tails of both lists by traversing them.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedLists(aVals, bVals, intersectIndex) {
  let shared = null;
  let dummyA = new ListNode(0), dummyB = new ListNode(0);
  let curA = dummyA, curB = dummyB;

  aVals.forEach((val, idx) => {
    const newNode = new ListNode(val);
    curA.next = newNode;
    curA = curA.next;
    if (idx === intersectIndex) shared = newNode;
  });

  bVals.forEach((val, idx) => {
    if (idx === bVals.length - 1 && shared) {
      curB.next = shared;
    } else {
      curB.next = new ListNode(val);
      curB = curB.next;
    }
  });

  return [dummyA.next, dummyB.next];
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const na = parseInt(input[0]);
  const aVals = na ? input[1].split(" ").map(Number) : [];
  const nb = parseInt(input[2]);
  const bVals = nb ? input[3].split(" ").map(Number) : [];
  const intersectIndex = parseInt(input[4]);

  const [headA, headB] = buildLinkedLists(aVals, bVals, intersectIndex);
  const result = doListsMerge(headA, headB);
  console.log(result);
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_lists(a_vals, b_vals, ix):
    shared = None
    dummyA = ListNode()
    dummyB = ListNode()
    curA = dummyA
    curB = dummyB
    for i, v in enumerate(a_vals):
        curA.next = ListNode(v)
        curA = curA.next
        if i == ix:
            shared = curA
    for i, v in enumerate(b_vals):
        if i == len(b_vals) - 1 and shared:
            curB.next = shared
        else:
            curB.next = ListNode(v)
            curB = curB.next
    return dummyA.next, dummyB.next

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    na = int(lines[0])
    a_vals = list(map(int, lines[1].split())) if na else []
    nb = int(lines[2])
    b_vals = list(map(int, lines[3].split())) if nb else []
    ix = int(lines[4])
    headA, headB = build_linked_lists(a_vals, b_vals, ix)
    print(doListsMerge(headA, headB))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function doListsMerge(headA, headB) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def doListsMerge(headA, headB):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Get Intersection Node (Y-shaped)',
    slug: 'get-intersection-node-y-shaped',
    description:
      'Find the node at which two singly linked lists intersect, forming a Y-shape.',
    problemStatement: `
Given the heads of two singly linked lists that form a Y-shaped structure (they merge at a node and continue as one), return the intersecting node. If they do not intersect, return null.

The intersection is defined by reference, not value.

You must solve this in O(n) time and O(1) space.

Examples:

<pre><code>Input:
3
10 20 30
2
5 6
1

Output:
30</code></pre>
Explanation: The lists merge at node 30.

<pre><code>Input:
3
1 2 3
3
4 5 6
-1

Output:
null</code></pre>
Explanation: The lists are separate and do not merge.

<ul>
<li>0 ≤ length of each list ≤ 10<sup>5</sup></li>
<li>Intersection index: -1 if no intersection, otherwise valid index in list A</li>
</ul>

Pro Tip: Try aligning the tail ends using pointer switching.
  `,
    sampleTestCases: [
      { input: '3\n10 20 30\n2\n5 6\n1', expected: '30' },
      { input: '3\n1 2 3\n3\n4 5 6\n-1', expected: 'null' },
    ],
    testCases: [
      { input: '0\n\n0\n\n-1', expected: 'null' },
      { input: '1\n9\n1\n9\n0', expected: '9' },
      { input: '2\n1 2\n2\n3 2\n1', expected: '2' },
      { input: '4\n1 2 3 4\n1\n0\n3', expected: '4' },
      { input: '5\n1 2 3 4 5\n2\n10 11\n2', expected: '3' },
      { input: '3\n1 1 1\n2\n9 8\n2', expected: '1' },
      { input: '4\n10 20 30 40\n3\n99 98 97\n3', expected: '40' },
      { input: '6\n1 2 3 4 5 6\n5\n6 5 4 3 2\n-1', expected: 'null' },
      { input: '3\n1 2 3\n3\n1 2 3\n2', expected: '3' },
      { input: '2\n100 200\n1\n99\n1', expected: '200' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Picture two roads merging into one. You're asked to find the exact merging point. How would you approach it in code efficiently?",
    difficulty: 'medium',
    frequency: 91,
    tags: ['linked list', 'intersection', 'two pointers'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Traverse both lists. When one ends, switch to the other’s head.',
      'If they intersect, the pointers will eventually meet.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedLists(aVals, bVals, intersectIndex) {
  let shared = null;
  let dummyA = new ListNode(0), dummyB = new ListNode(0);
  let curA = dummyA, curB = dummyB;

  aVals.forEach((val, idx) => {
    const newNode = new ListNode(val);
    curA.next = newNode;
    curA = curA.next;
    if (idx === intersectIndex) shared = newNode;
  });

  bVals.forEach((val, idx) => {
    if (idx === bVals.length - 1 && shared) {
      curB.next = shared;
    } else {
      curB.next = new ListNode(val);
      curB = curB.next;
    }
  });

  return [dummyA.next, dummyB.next];
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const na = parseInt(input[0]);
  const aVals = na ? input[1].split(" ").map(Number) : [];
  const nb = parseInt(input[2]);
  const bVals = nb ? input[3].split(" ").map(Number) : [];
  const ix = parseInt(input[4]);

  const [headA, headB] = buildLinkedLists(aVals, bVals, ix);
  const result = getYIntersectionNode(headA, headB);
  console.log(result ? result.val : "null");
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_lists(a_vals, b_vals, ix):
    shared = None
    dummyA = ListNode()
    dummyB = ListNode()
    curA = dummyA
    curB = dummyB
    for i, v in enumerate(a_vals):
        curA.next = ListNode(v)
        curA = curA.next
        if i == ix:
            shared = curA
    for i, v in enumerate(b_vals):
        if i == len(b_vals) - 1 and shared:
            curB.next = shared
        else:
            curB.next = ListNode(v)
            curB = curB.next
    return dummyA.next, dummyB.next

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    na = int(lines[0])
    a_vals = list(map(int, lines[1].split())) if na else []
    nb = int(lines[2])
    b_vals = list(map(int, lines[3].split())) if nb else []
    ix = int(lines[4])
    headA, headB = build_linked_lists(a_vals, b_vals, ix)
    node = getYIntersectionNode(headA, headB)
    print(node.val if node else "null")`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function getYIntersectionNode(headA, headB) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def getYIntersectionNode(headA, headB):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Merge Two Sorted Linked Lists',
    slug: 'merge-two-sorted-linked-lists',
    description: 'Merge two sorted singly linked lists into one sorted list.',
    problemStatement: `
You are given the heads of two sorted singly linked lists \`l1\` and \`l2\`. Merge them into a single sorted linked list and return the head of the merged list.

The merged list should be made by splicing together the nodes of the first two lists without creating new nodes.

Examples:

<pre><code>Input:
3
1 2 4
3
1 3 4

Output:
1 1 2 3 4 4</code></pre>
Explanation: Both input lists are sorted. The merged result is also sorted.

<pre><code>Input:
2
2 5
2
1 6

Output:
1 2 5 6</code></pre>
<ul>
<li>0 ≤ length of each list ≤ 10<sup>5</sup></li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
</ul>

Pro Tip: Use a dummy node to simplify merging logic.
  `,
    sampleTestCases: [
      { input: '3\n1 2 4\n3\n1 3 4', expected: '1 1 2 3 4 4' },
      { input: '2\n2 5\n2\n1 6', expected: '1 2 5 6' },
    ],
    testCases: [
      { input: '0\n\n0\n', expected: '' },
      { input: '1\n1\n0\n', expected: '1' },
      { input: '0\n\n2\n1 2', expected: '1 2' },
      { input: '2\n1 2\n2\n3 4', expected: '1 2 3 4' },
      { input: '2\n3 4\n2\n1 2', expected: '1 2 3 4' },
      { input: '4\n1 3 5 7\n4\n2 4 6 8', expected: '1 2 3 4 5 6 7 8' },
      { input: '3\n0 5 10\n3\n1 6 11', expected: '0 1 5 6 10 11' },
      { input: '6\n1 1 2 3 3 5\n3\n1 3 4', expected: '1 1 1 2 3 3 3 4 5' },
      { input: '3\n-3 -1 2\n3\n-2 0 3', expected: '-3 -2 -1 0 2 3' },
      {
        input: '5\n1 3 5 7 9\n5\n2 4 6 8 10',
        expected: '1 2 3 4 5 6 7 8 9 10',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Merging two sorted sequences efficiently is a classic task in algorithm design. Now imagine each sequence is a linked list.',
    difficulty: 'easy',
    frequency: 97,
    tags: ['linked list', 'merge', 'two pointer'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use a dummy node to simplify the logic.',
      'Iteratively attach the smaller of the two current nodes and move forward.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode(0);
  let current = dummy;
  for (let val of arr) {
    current.next = new ListNode(val);
    current = current.next;
  }
  return dummy.next;
}

function linkedListToArray(head) {
  const result = [];
  while (head) {
    result.push(head.val);
    head = head.next;
  }
  return result;
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n1 = parseInt(input[0]);
  const l1 = n1 ? buildLinkedList(input[1].split(" ").map(Number)) : null;
  const n2 = parseInt(input[2]);
  const l2 = n2 ? buildLinkedList(input[3].split(" ").map(Number)) : null;
  const merged = mergeTwoLists(l1, l2);
  console.log(linkedListToArray(merged).join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode()
    current = dummy
    for v in values:
        current.next = ListNode(v)
        current = current.next
    return dummy.next

def linked_list_to_list(head):
    result = []
    while head:
        result.append(str(head.val))
        head = head.next
    return result

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n1 = int(lines[0])
    l1 = build_linked_list(list(map(int, lines[1].split()))) if n1 else None
    n2 = int(lines[2])
    l2 = build_linked_list(list(map(int, lines[3].split()))) if n2 else None
    merged = mergeTwoLists(l1, l2)
    print(" ".join(linked_list_to_list(merged)))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function mergeTwoLists(l1, l2) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def mergeTwoLists(l1, l2):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Merge K Sorted Linked Lists (Heap based)',
    slug: 'merge-k-sorted-linked-lists-heap-based',
    description:
      'Merge k sorted linked lists into one sorted list using a priority queue.',
    problemStatement: `
You are given an array of \`k\` singly linked lists, each sorted in ascending order. Merge all the linked lists into one sorted linked list and return the head.

Use a min-heap (priority queue) to achieve efficient merging.

Examples:

<pre><code>Input:
3
1 4 5
1 3 4
2 6

Output:
1 1 2 3 4 4 5 6</code></pre>
Explanation: All k lists are merged into one sorted list.

<pre><code>Input:
2
2
2
1 3

Output:
1 2 3</code></pre>
<ul>
<li>0 ≤ k ≤ 10<sup>4</sup></li>
<li>0 ≤ nodes in each list ≤ 500</li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
</ul>

Pro Tip: Use a min-heap to always select the node with the smallest value across all heads.
  `,
    sampleTestCases: [
      { input: '3\n1 4 5\n1 3 4\n2 6', expected: '1 1 2 3 4 4 5 6' },
      { input: '2\n2\n2\n1 3', expected: '1 2 3' },
    ],
    testCases: [
      { input: '0', expected: '' },
      { input: '1\n', expected: '' },
      { input: '1\n1 2 3', expected: '1 2 3' },
      { input: '2\n1 3 5\n2 4 6', expected: '1 2 3 4 5 6' },
      { input: '3\n1 2 3\n\n4 5', expected: '1 2 3 4 5' },
      { input: '2\n\n\n', expected: '' },
      { input: '3\n10 20\n1 9 11\n2 8', expected: '1 2 8 9 10 11 20' },
      { input: '4\n-10 -5 0\n\n-6 -4\n-9', expected: '-10 -9 -6 -5 -4 0' },
      { input: '5\n1\n1\n1\n1\n1', expected: '1 1 1 1 1' },
      { input: '3\n1 4 5\n1 3 4\n2 6', expected: '1 1 2 3 4 4 5 6' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re asked to combine multiple sorted sequences into one. A heap can help keep track of the minimum across all heads.',
    difficulty: 'hard',
    frequency: 96,
    tags: ['heap', 'linked list', 'priority queue', 'merge'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use a min-heap (priority queue) to track the smallest current node.',
      'Always push the next node of a list into the heap when you pop one.',
    ],
    optimalComplexity: {
      time: 'O(N log k)',
      space: 'O(k)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function parseLinkedLists(lines) {
  const k = parseInt(lines[0]);
  const lists = [];
  for (let i = 1; i <= k; i++) {
    const values = lines[i] ? lines[i].split(" ").map(Number) : [];
    let dummy = new ListNode(0), curr = dummy;
    for (let v of values) {
      curr.next = new ListNode(v);
      curr = curr.next;
    }
    lists.push(dummy.next);
  }
  return lists;
}

function linkedListToArray(head) {
  const res = [];
  while (head) {
    res.push(head.val);
    head = head.next;
  }
  return res;
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const lists = parseLinkedLists(input);
  const result = mergeKLists(lists);
  console.log(linkedListToArray(result).join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
import heapq

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def parse_linked_lists(lines):
    k = int(lines[0])
    lists = []
    for i in range(1, k+1):
        values = list(map(int, lines[i].split())) if lines[i] else []
        dummy = ListNode(0)
        current = dummy
        for v in values:
            current.next = ListNode(v)
            current = current.next
        lists.append(dummy.next)
    return lists

def linked_list_to_list(head):
    result = []
    while head:
        result.append(str(head.val))
        head = head.next
    return result

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    lists = parse_linked_lists(lines)
    result = mergeKLists(lists)
    print(" ".join(linked_list_to_list(result)))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function mergeKLists(lists) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def mergeKLists(lists):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Add Two Numbers (LL Representation of Numbers)',
    slug: 'add-two-numbers-ll-representation',
    description:
      'Add two non-negative integers represented as reversed linked lists.',
    problemStatement: `
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each node contains a single digit.

Add the two numbers and return the sum as a linked list, also in reverse order.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Examples:

<pre><code>Input:
3
2 4 3
3
5 6 4

Output:
7 0 8</code></pre>
Explanation: 342 + 465 = 807 → 7 → 0 → 8 (reversed)

<pre><code>Input:
1
0
1
0

Output:
0</code></pre>
<ul>
<li>1 ≤ length of each list ≤ 100</li>
<li>0 ≤ node values ≤ 9</li>
<li>It is guaranteed that the list represents a valid number</li>
</ul>

Pro Tip: Use a dummy node and carry to simplify the addition.
  `,
    sampleTestCases: [
      { input: '3\n2 4 3\n3\n5 6 4', expected: '7 0 8' },
      { input: '1\n0\n1\n0', expected: '0' },
    ],
    testCases: [
      { input: '2\n5 6\n2\n7 8', expected: '2 5 1' },
      { input: '3\n9 9 9\n1\n1', expected: '0 0 0 1' },
      { input: '4\n1 8 9 3\n2\n5 2', expected: '6 0 0 4' },
      { input: '5\n1 0 0 0 1\n3\n9 9 9', expected: '0 0 0 0 2' },
      { input: '1\n1\n1\n9', expected: '0 1' },
      { input: '2\n9 9\n1\n1', expected: '0 0 1' },
      { input: '3\n1 2 3\n3\n4 5 6', expected: '5 7 9' },
      { input: '3\n0 0 1\n2\n0 9', expected: '0 9 1' },
      { input: '2\n0 1\n2\n0 9', expected: '0 0 1' },
      { input: '3\n2 4 9\n3\n5 6 4', expected: '7 0 4 1' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're building a calculator with linked lists where each digit is a node. Can you perform addition digit-by-digit as in manual math?",
    difficulty: 'medium',
    frequency: 99,
    tags: ['linked list', 'math', 'carry'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Apple', logoUrl: '' },
    ],
    hints: [
      'Use a carry variable to track overflow beyond 9.',
      'Continue until both lists and carry are fully processed.',
    ],
    optimalComplexity: {
      time: 'O(max(m, n))',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode();
  let curr = dummy;
  for (let v of arr) {
    curr.next = new ListNode(v);
    curr = curr.next;
  }
  return dummy.next;
}

function linkedListToArray(head) {
  const out = [];
  while (head) {
    out.push(head.val);
    head = head.next;
  }
  return out;
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n1 = parseInt(input[0]);
  const l1 = buildLinkedList(input[1].split(" ").map(Number));
  const n2 = parseInt(input[2]);
  const l2 = buildLinkedList(input[3].split(" ").map(Number));
  const result = addTwoNumbers(l1, l2);
  console.log(linkedListToArray(result).join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode()
    curr = dummy
    for v in values:
        curr.next = ListNode(v)
        curr = curr.next
    return dummy.next

def linked_list_to_list(head):
    out = []
    while head:
        out.append(str(head.val))
        head = head.next
    return out

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n1 = int(lines[0])
    l1 = build_linked_list(list(map(int, lines[1].split())))
    n2 = int(lines[2])
    l2 = build_linked_list(list(map(int, lines[3].split())))
    result = addTwoNumbers(l1, l2)
    print(" ".join(linked_list_to_list(result)))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function addTwoNumbers(l1, l2) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def addTwoNumbers(l1, l2):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Remove Duplicates from Sorted List',
    slug: 'remove-duplicates-from-sorted-list',
    description:
      'Remove all duplicates from a sorted linked list such that each element appears only once.',
    problemStatement: `
You are given the head of a sorted singly linked list. Remove all duplicates such that each element appears only once. Return the head of the modified linked list.

You must do this in-place with O(1) space.

Examples:

<pre><code>Input:
5
1 1 2 3 3

Output:
1 2 3</code></pre>

<pre><code>Input:
3
1 1 1

Output:
1</code></pre>

<ul>
<li>0 ≤ n ≤ 10<sup>5</sup></li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
<li>The list is sorted in non-decreasing order</li>
</ul>

Pro Tip: Use a single pointer to traverse and skip duplicate nodes by comparing current with next.
  `,
    sampleTestCases: [
      { input: '5\n1 1 2 3 3', expected: '1 2 3' },
      { input: '3\n1 1 1', expected: '1' },
    ],
    testCases: [
      { input: '0\n', expected: '' },
      { input: '1\n10', expected: '10' },
      { input: '2\n5 5', expected: '5' },
      { input: '3\n1 2 3', expected: '1 2 3' },
      { input: '4\n4 4 4 4', expected: '4' },
      { input: '6\n1 1 2 2 3 3', expected: '1 2 3' },
      { input: '7\n1 1 1 2 3 3 4', expected: '1 2 3 4' },
      { input: '5\n-1 0 0 1 1', expected: '-1 0 1' },
      { input: '10\n1 1 2 3 3 4 4 5 5 5', expected: '1 2 3 4 5' },
      { input: '6\n6 7 7 8 9 9', expected: '6 7 8 9' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're given a sorted list of data with some duplicates. Can you filter it in-place to keep only unique entries?",
    difficulty: 'easy',
    frequency: 88,
    tags: ['linked list', 'in-place', 'duplicates'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Apple', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Compare current node with the next and skip if values match.',
      'Since the list is sorted, duplicates will be adjacent.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode();
  let curr = dummy;
  for (let val of arr) {
    curr.next = new ListNode(val);
    curr = curr.next;
  }
  return dummy.next;
}

function linkedListToArray(head) {
  const res = [];
  while (head) {
    res.push(head.val);
    head = head.next;
  }
  return res;
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(input[0]);
  const arr = n ? input[1].split(" ").map(Number) : [];
  const head = buildLinkedList(arr);
  const newHead = deleteDuplicates(head);
  console.log(linkedListToArray(newHead).join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode()
    curr = dummy
    for v in values:
        curr.next = ListNode(v)
        curr = curr.next
    return dummy.next

def linked_list_to_list(head):
    res = []
    while head:
        res.append(str(head.val))
        head = head.next
    return res

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0])
    values = list(map(int, lines[1].split())) if n else []
    head = build_linked_list(values)
    new_head = deleteDuplicates(head)
    print(" ".join(linked_list_to_list(new_head)))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function deleteDuplicates(head) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def deleteDuplicates(head):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Remove Duplicates from Unsorted List',
    slug: 'remove-duplicates-from-unsorted-list',
    description: 'Remove all duplicates from an unsorted singly linked list.',
    problemStatement: `
Given the head of an unsorted singly linked list, remove all duplicate nodes such that each element appears only once. Return the head of the updated list.

You should do it in-place using O(n) time and O(n) extra space.

Examples:

<pre><code>Input:
6
1 2 3 2 4 1

Output:
1 2 3 4</code></pre>

<pre><code>Input:
5
1 1 1 1 1

Output:
1</code></pre>

<ul>
<li>0 ≤ n ≤ 10<sup>5</sup></li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
</ul>

Pro Tip: Use a HashSet to keep track of seen values while traversing.
  `,
    sampleTestCases: [
      { input: '6\n1 2 3 2 4 1', expected: '1 2 3 4' },
      { input: '5\n1 1 1 1 1', expected: '1' },
    ],
    testCases: [
      { input: '0\n', expected: '' },
      { input: '1\n5', expected: '5' },
      { input: '3\n5 5 5', expected: '5' },
      { input: '4\n1 2 3 4', expected: '1 2 3 4' },
      { input: '5\n2 3 2 4 3', expected: '2 3 4' },
      { input: '6\n10 20 10 30 20 40', expected: '10 20 30 40' },
      { input: '7\n-1 -2 -3 -1 -2 -4 -5', expected: '-1 -2 -3 -4 -5' },
      { input: '8\n1 2 1 2 3 3 4 4', expected: '1 2 3 4' },
      { input: '5\n5 4 3 2 1', expected: '5 4 3 2 1' },
      { input: '10\n1 2 3 4 5 6 7 8 9 1', expected: '1 2 3 4 5 6 7 8 9' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You have a list with repeating values scattered throughout. Your goal is to keep only the first occurrence of each unique value.',
    difficulty: 'medium',
    frequency: 87,
    tags: ['linked list', 'hash set', 'deduplication'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Flipkart', logoUrl: '' },
    ],
    hints: [
      'Use a HashSet to track already seen values.',
      'Skip nodes with duplicate values by adjusting next pointers.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode();
  let curr = dummy;
  for (let v of arr) {
    curr.next = new ListNode(v);
    curr = curr.next;
  }
  return dummy.next;
}

function linkedListToArray(head) {
  const res = [];
  while (head) {
    res.push(head.val);
    head = head.next;
  }
  return res;
}

const fs = require("fs");
function main() {
  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(input[0]);
  const values = n ? input[1].split(" ").map(Number) : [];
  const head = buildLinkedList(values);
  const newHead = removeDuplicates(head);
  console.log(linkedListToArray(newHead).join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode()
    curr = dummy
    for v in values:
        curr.next = ListNode(v)
        curr = curr.next
    return dummy.next

def linked_list_to_list(head):
    res = []
    while head:
        res.append(str(head.val))
        head = head.next
    return res

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0])
    values = list(map(int, lines[1].split())) if n else []
    head = build_linked_list(values)
    new_head = removeDuplicates(head)
    print(" ".join(linked_list_to_list(new_head)))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function removeDuplicates(head) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def removeDuplicates(head):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Rearrange Linked List in Zig-Zag Fashion',
    slug: 'rearrange-linked-list-zig-zag',
    description:
      'Rearrange a singly linked list in zig-zag order by modifying node values.',
    problemStatement: `
Given a singly linked list, rearrange its node values in zig-zag fashion such that the linked list becomes:
\`a < b > c < d > e < f ...\`

Note: You may not swap node positions, but you are allowed to swap their values.

Examples:

<pre><code>Input:
6
4 3 7 8 6 2

Output:
3 7 4 8 2 6</code></pre>
Explanation: Swapping values to satisfy zig-zag pattern: 3 < 7 > 4 < 8 > 2 < 6.

<pre><code>Input:
5
11 15 20 5 10

Output:
11 20 15 10 5</code></pre>

<ul>
<li>1 ≤ n ≤ 10<sup>5</sup></li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
</ul>

Pro Tip: Traverse once and alternate between \`<\` and \`>\` expectations by using a boolean flag.
  `,
    sampleTestCases: [
      { input: '6\n4 3 7 8 6 2', expected: '3 7 4 8 2 6' },
      { input: '5\n11 15 20 5 10', expected: '11 20 15 10 5' },
    ],
    testCases: [
      { input: '1\n5', expected: '5' },
      { input: '2\n5 3', expected: '3 5' },
      { input: '3\n1 2 3', expected: '1 3 2' },
      { input: '4\n1 4 3 2', expected: '1 4 2 3' },
      { input: '5\n10 20 30 40 50', expected: '10 30 20 50 40' },
      { input: '6\n5 4 3 2 1 0', expected: '4 5 2 3 0 1' },
      { input: '7\n9 6 8 3 7 2 1', expected: '6 9 3 8 2 7 1' },
      { input: '3\n1 3 2', expected: '1 3 2' },
      { input: '4\n3 4 2 1', expected: '3 4 1 2' },
      { input: '6\n1 1 1 1 1 1', expected: '1 1 1 1 1 1' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You need to shuffle values of a linked list in alternating less-than and greater-than pattern. How can you do this efficiently in one pass?',
    difficulty: 'medium',
    frequency: 75,
    tags: ['linked list', 'zigzag', 'rearrangement'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Walmart', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use a flag to determine whether to expect < or > at each node.',
      'Swap values, not nodes, if the condition is violated.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode();
  let current = dummy;
  for (let v of arr) {
    current.next = new ListNode(v);
    current = current.next;
  }
  return dummy.next;
}

function linkedListToArray(head) {
  const result = [];
  while (head) {
    result.push(head.val);
    head = head.next;
  }
  return result;
}

const fs = require("fs");
function main() {
  const lines = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(lines[0]);
  const values = lines[1].split(" ").map(Number);
  const head = buildLinkedList(values);
  zigZagList(head);
  console.log(linkedListToArray(head).join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode()
    cur = dummy
    for v in values:
        cur.next = ListNode(v)
        cur = cur.next
    return dummy.next

def linked_list_to_list(head):
    result = []
    while head:
        result.append(str(head.val))
        head = head.next
    return result

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0])
    values = list(map(int, lines[1].split()))
    head = build_linked_list(values)
    zigZagList(head)
    print(" ".join(linked_list_to_list(head)))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function zigZagList(head) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def zigZagList(head):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Rearrange Nodes in Odd-Even Position',
    slug: 'rearrange-nodes-odd-even-position',
    description:
      'Group all nodes at odd positions followed by nodes at even positions in a linked list.',
    problemStatement: `
Given the head of a singly linked list, group all nodes positioned at odd indices followed by the nodes at even indices, and return the rearranged list.

The relative order inside the odd and even groups should remain the same.

Note: The indexing starts from 1 (head is position 1).

Examples:

<pre><code>Input:
5
1 2 3 4 5

Output:
1 3 5 2 4</code></pre>

<pre><code>Input:
6
2 1 3 5 6 4

Output:
2 3 6 1 5 4</code></pre>

<ul>
<li>0 ≤ n ≤ 10<sup>5</sup></li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
</ul>

Pro Tip: Use two pointers — one for odd and one for even — and rearrange them by pointer manipulation.
  `,
    sampleTestCases: [
      { input: '5\n1 2 3 4 5', expected: '1 3 5 2 4' },
      { input: '6\n2 1 3 5 6 4', expected: '2 3 6 1 5 4' },
    ],
    testCases: [
      { input: '0\n', expected: '' },
      { input: '1\n7', expected: '7' },
      { input: '2\n1 2', expected: '1 2' },
      { input: '3\n1 2 3', expected: '1 3 2' },
      { input: '4\n1 2 3 4', expected: '1 3 2 4' },
      { input: '5\n10 20 30 40 50', expected: '10 30 50 20 40' },
      { input: '6\n1 1 1 2 2 2', expected: '1 1 2 1 2 2' },
      { input: '7\n9 8 7 6 5 4 3', expected: '9 7 5 3 8 6 4' },
      { input: '8\n1 3 5 7 2 4 6 8', expected: '1 5 2 6 3 7 4 8' },
      {
        input: '10\n10 20 30 40 50 60 70 80 90 100',
        expected: '10 30 50 70 90 20 40 60 80 100',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Rearranging based on position, not value, requires pointer juggling. Can you split and reconnect odd and even indexed nodes efficiently?',
    difficulty: 'medium',
    frequency: 90,
    tags: ['linked list', 'odd-even', 'in-place'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use separate odd and even pointers.',
      "Don't lose track of the even head — you'll need to connect it at the end.",
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode();
  let curr = dummy;
  for (let v of arr) {
    curr.next = new ListNode(v);
    curr = curr.next;
  }
  return dummy.next;
}

function linkedListToArray(head) {
  const res = [];
  while (head) {
    res.push(head.val);
    head = head.next;
  }
  return res;
}

const fs = require("fs");
function main() {
  const lines = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(lines[0]);
  const values = n ? lines[1].split(" ").map(Number) : [];
  const head = buildLinkedList(values);
  const newHead = oddEvenList(head);
  console.log(linkedListToArray(newHead).join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode()
    curr = dummy
    for v in values:
        curr.next = ListNode(v)
        curr = curr.next
    return dummy.next

def linked_list_to_list(head):
    result = []
    while head:
        result.append(str(head.val))
        head = head.next
    return result

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0])
    values = list(map(int, lines[1].split())) if n else []
    head = build_linked_list(values)
    new_head = oddEvenList(head)
    print(" ".join(linked_list_to_list(new_head)))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function oddEvenList(head) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def oddEvenList(head):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Swap Kth Node from Start and End',
    slug: 'swap-kth-node-from-start-and-end',
    description:
      'Swap the values of the k-th node from the beginning and the k-th node from the end in a singly linked list.',
    problemStatement: `
You are given the head of a singly linked list and an integer \`k\`. Swap the values of the k-th node from the beginning and the k-th node from the end, and return the head of the list.

The indexing starts at 1. You may not swap nodes, only their values.

Examples:

<pre><code>Input:
5
1 2 3 4 5
2

Output:
1 4 3 2 5</code></pre>

<pre><code>Input:
6
7 9 6 5 8 3
3

Output:
7 9 8 5 6 3</code></pre>

<ul>
<li>1 ≤ n ≤ 10<sup>5</sup></li>
<li>1 ≤ k ≤ n</li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
</ul>

Pro Tip: Find the k-th node from the start and the k-th node from the end with two traversals or a single pass with two pointers.
  `,
    sampleTestCases: [
      { input: '5\n1 2 3 4 5\n2', expected: '1 4 3 2 5' },
      { input: '6\n7 9 6 5 8 3\n3', expected: '7 9 8 5 6 3' },
    ],
    testCases: [
      { input: '1\n100\n1', expected: '100' },
      { input: '2\n1 2\n1', expected: '2 1' },
      { input: '3\n1 2 3\n1', expected: '3 2 1' },
      { input: '4\n10 20 30 40\n2', expected: '10 30 20 40' },
      { input: '5\n5 4 3 2 1\n3', expected: '5 4 3 2 1' },
      { input: '6\n1 2 3 4 5 6\n1', expected: '6 2 3 4 5 1' },
      { input: '6\n1 2 3 4 5 6\n2', expected: '1 5 3 4 2 6' },
      { input: '7\n9 8 7 6 5 4 3\n4', expected: '9 8 7 6 5 4 3' },
      {
        input: '8\n11 22 33 44 55 66 77 88\n3',
        expected: '11 22 55 44 33 66 77 88',
      },
      {
        input: '9\n1 3 5 7 9 11 13 15 17\n5',
        expected: '1 3 5 7 9 11 13 15 17',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You need to swap nodes symmetrically from the start and end. Think of using length or two pointers to identify the correct nodes.',
    difficulty: 'medium',
    frequency: 85,
    tags: ['linked list', 'two pointers', 'indexing'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Samsung', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use a first pass to count total nodes if needed.',
      'Or use two pointers where one is k steps ahead to find both nodes.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode();
  let curr = dummy;
  for (let v of arr) {
    curr.next = new ListNode(v);
    curr = curr.next;
  }
  return dummy.next;
}

function linkedListToArray(head) {
  const res = [];
  while (head) {
    res.push(head.val);
    head = head.next;
  }
  return res;
}

const fs = require("fs");
function main() {
  const lines = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(lines[0]);
  const values = lines[1].split(" ").map(Number);
  const k = parseInt(lines[2]);
  const head = buildLinkedList(values);
  const newHead = swapKthNode(head, k);
  console.log(linkedListToArray(newHead).join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode()
    curr = dummy
    for v in values:
        curr.next = ListNode(v)
        curr = curr.next
    return dummy.next

def linked_list_to_list(head):
    result = []
    while head:
        result.append(str(head.val))
        head = head.next
    return result

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0])
    values = list(map(int, lines[1].split()))
    k = int(lines[2])
    head = build_linked_list(values)
    new_head = swapKthNode(head, k)
    print(" ".join(linked_list_to_list(new_head)))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function swapKthNode(head, k) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def swapKthNode(head, k):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Reverse Nodes in K Group',
    slug: 'reverse-nodes-in-k-group',
    description:
      'Reverse every k-sized group of nodes in a singly linked list.',
    problemStatement: `
Given the head of a singly linked list, reverse the nodes of the list \`k\` at a time, and return the modified list.

Nodes that are left out (less than k) at the end should remain as is.

You may not alter the values, only pointers.

Examples:

<pre><code>Input:
8
1 2 3 4 5 6 7 8
3

Output:
3 2 1 6 5 4 7 8</code></pre>

<pre><code>Input:
5
1 2 3 4 5
2

Output:
2 1 4 3 5</code></pre>

<ul>
<li>1 ≤ n ≤ 10<sup>5</sup></li>
<li>1 ≤ k ≤ n</li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
</ul>

Pro Tip: Use a helper to reverse each k-sized segment in-place and reconnect appropriately.
  `,
    sampleTestCases: [
      { input: '8\n1 2 3 4 5 6 7 8\n3', expected: '3 2 1 6 5 4 7 8' },
      { input: '5\n1 2 3 4 5\n2', expected: '2 1 4 3 5' },
    ],
    testCases: [
      { input: '1\n9\n1', expected: '9' },
      { input: '4\n1 2 3 4\n2', expected: '2 1 4 3' },
      { input: '6\n1 2 3 4 5 6\n3', expected: '3 2 1 6 5 4' },
      { input: '5\n1 2 3 4 5\n5', expected: '5 4 3 2 1' },
      { input: '6\n1 2 3 4 5 6\n4', expected: '4 3 2 1 5 6' },
      { input: '7\n10 20 30 40 50 60 70\n3', expected: '30 20 10 60 50 40 70' },
      { input: '9\n1 2 3 4 5 6 7 8 9\n3', expected: '3 2 1 6 5 4 9 8 7' },
      { input: '3\n1 2 3\n4', expected: '1 2 3' },
      { input: '4\n1 2 3 4\n4', expected: '4 3 2 1' },
      {
        input: '10\n1 2 3 4 5 6 7 8 9 10\n5',
        expected: '5 4 3 2 1 10 9 8 7 6',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Imagine reversing parts of a train, k cars at a time. You must do this carefully, modifying connections only—not the contents of each car.',
    difficulty: 'hard',
    frequency: 91,
    tags: ['linked list', 'recursion', 'group reversal'],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Count k nodes first before reversal to avoid breaking partial groups.',
      'Use a helper function to reverse k nodes and reconnect.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode();
  let curr = dummy;
  for (let v of arr) {
    curr.next = new ListNode(v);
    curr = curr.next;
  }
  return dummy.next;
}

function linkedListToArray(head) {
  const res = [];
  while (head) {
    res.push(head.val);
    head = head.next;
  }
  return res;
}

const fs = require("fs");
function main() {
  const lines = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(lines[0]);
  const values = lines[1].split(" ").map(Number);
  const k = parseInt(lines[2]);
  const head = buildLinkedList(values);
  const newHead = reverseKGroup(head, k);
  console.log(linkedListToArray(newHead).join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode()
    curr = dummy
    for v in values:
        curr.next = ListNode(v)
        curr = curr.next
    return dummy.next

def linked_list_to_list(head):
    result = []
    while head:
        result.append(str(head.val))
        head = head.next
    return result

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0])
    values = list(map(int, lines[1].split()))
    k = int(lines[2])
    head = build_linked_list(values)
    new_head = reverseKGroup(head, k)
    print(" ".join(linked_list_to_list(new_head)))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function reverseKGroup(head, k) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def reverseKGroup(head, k):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Reverse Alternate K Nodes',
    slug: 'reverse-alternate-k-nodes',
    description: 'Reverse every alternate k nodes in a singly linked list.',
    problemStatement: `
Given a singly linked list and an integer \`k\`, reverse every alternate group of k nodes in the list and return the modified list.

Start by reversing the first k nodes, skipping the next k nodes, and so on.

Examples:

<pre><code>Input:
8
1 2 3 4 5 6 7 8
2

Output:
2 1 3 4 6 5 7 8</code></pre>

<pre><code>Input:
7
10 20 30 40 50 60 70
3

Output:
30 20 10 40 50 60 70</code></pre>

<ul>
<li>1 ≤ n ≤ 10<sup>5</sup></li>
<li>1 ≤ k ≤ n</li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
</ul>

Pro Tip: Toggle a flag between reversing and skipping groups of k nodes.
  `,
    sampleTestCases: [
      { input: '8\n1 2 3 4 5 6 7 8\n2', expected: '2 1 3 4 6 5 7 8' },
      { input: '7\n10 20 30 40 50 60 70\n3', expected: '30 20 10 40 50 60 70' },
    ],
    testCases: [
      { input: '1\n5\n1', expected: '5' },
      { input: '4\n1 2 3 4\n2', expected: '2 1 3 4' },
      { input: '5\n1 2 3 4 5\n3', expected: '3 2 1 4 5' },
      { input: '6\n1 2 3 4 5 6\n2', expected: '2 1 3 4 6 5' },
      { input: '6\n1 2 3 4 5 6\n3', expected: '3 2 1 4 5 6' },
      { input: '7\n1 2 3 4 5 6 7\n2', expected: '2 1 3 4 6 5 7' },
      { input: '8\n1 2 3 4 5 6 7 8\n3', expected: '3 2 1 4 5 6 8 7' },
      {
        input: '10\n1 2 3 4 5 6 7 8 9 10\n4',
        expected: '4 3 2 1 5 6 7 8 10 9',
      },
      { input: '9\n9 8 7 6 5 4 3 2 1\n3', expected: '7 8 9 6 5 4 1 2 3' },
      { input: '5\n1 2 3 4 5\n5', expected: '5 4 3 2 1' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're alternating between reversing and skipping k-node blocks in a linked list. Can you manage two-phase pointer manipulation in one pass?",
    difficulty: 'medium',
    frequency: 80,
    tags: ['linked list', 'two pointers', 'recursion', 'group reversal'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
      { name: 'VMware', logoUrl: '' },
    ],
    hints: [
      'Use a loop to reverse k nodes, then another loop to skip k nodes.',
      'Maintain previous and current pointers to stitch nodes correctly.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode();
  let curr = dummy;
  for (let v of arr) {
    curr.next = new ListNode(v);
    curr = curr.next;
  }
  return dummy.next;
}

function linkedListToArray(head) {
  const res = [];
  while (head) {
    res.push(head.val);
    head = head.next;
  }
  return res;
}

const fs = require("fs");
function main() {
  const lines = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(lines[0]);
  const values = lines[1].split(" ").map(Number);
  const k = parseInt(lines[2]);
  const head = buildLinkedList(values);
  const newHead = reverseAlternateKNodes(head, k);
  console.log(linkedListToArray(newHead).join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode()
    curr = dummy
    for v in values:
        curr.next = ListNode(v)
        curr = curr.next
    return dummy.next

def linked_list_to_list(head):
    result = []
    while head:
        result.append(str(head.val))
        head = head.next
    return result

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0])
    values = list(map(int, lines[1].split()))
    k = int(lines[2])
    head = build_linked_list(values)
    new_head = reverseAlternateKNodes(head, k)
    print(" ".join(linked_list_to_list(new_head)))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function reverseAlternateKNodes(head, k) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def reverseAlternateKNodes(head, k):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Pairwise Swap Nodes',
    slug: 'pairwise-swap-nodes',
    description:
      'Swap nodes of a linked list pairwise without swapping their values.',
    problemStatement: `
Given a singly linked list, swap every two adjacent nodes and return the modified list.

You must not change the values inside the nodes, only the nodes themselves should be changed.

Examples:

<pre><code>Input:
6
1 2 3 4 5 6

Output:
2 1 4 3 6 5</code></pre>

<pre><code>Input:
5
10 20 30 40 50

Output:
20 10 40 30 50</code></pre>

<ul>
<li>0 ≤ n ≤ 10<sup>5</sup></li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
</ul>

Pro Tip: Use a dummy node and adjust next pointers in pairs during traversal.
  `,
    sampleTestCases: [
      { input: '6\n1 2 3 4 5 6', expected: '2 1 4 3 6 5' },
      { input: '5\n10 20 30 40 50', expected: '20 10 40 30 50' },
    ],
    testCases: [
      { input: '0\n', expected: '' },
      { input: '1\n7', expected: '7' },
      { input: '2\n1 2', expected: '2 1' },
      { input: '3\n1 2 3', expected: '2 1 3' },
      { input: '4\n1 2 3 4', expected: '2 1 4 3' },
      { input: '5\n5 4 3 2 1', expected: '4 5 2 3 1' },
      { input: '6\n6 5 4 3 2 1', expected: '5 6 3 4 1 2' },
      { input: '7\n9 8 7 6 5 4 3', expected: '8 9 6 7 4 5 3' },
      { input: '8\n1 3 5 7 2 4 6 8', expected: '3 1 7 5 4 2 8 6' },
      {
        input: '10\n10 20 30 40 50 60 70 80 90 100',
        expected: '20 10 40 30 60 50 80 70 100 90',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're asked to pair up elements in a linked list by adjusting only the links—not the values. Can you walk through and swap nodes effectively?",
    difficulty: 'medium',
    frequency: 83,
    tags: ['linked list', 'pointer manipulation', 'pairwise swap'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Accenture', logoUrl: '' },
    ],
    hints: [
      'Use a dummy node to simplify swapping at the head.',
      'Update three pointers at each step: prev, first, and second.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode();
  let curr = dummy;
  for (let v of arr) {
    curr.next = new ListNode(v);
    curr = curr.next;
  }
  return dummy.next;
}

function linkedListToArray(head) {
  const res = [];
  while (head) {
    res.push(head.val);
    head = head.next;
  }
  return res;
}

const fs = require("fs");
function main() {
  const lines = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(lines[0]);
  const values = n ? lines[1].split(" ").map(Number) : [];
  const head = buildLinkedList(values);
  const newHead = pairwiseSwap(head);
  console.log(linkedListToArray(newHead).join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode()
    curr = dummy
    for v in values:
        curr.next = ListNode(v)
        curr = curr.next
    return dummy.next

def linked_list_to_list(head):
    result = []
    while head:
        result.append(str(head.val))
        head = head.next
    return result

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0])
    values = list(map(int, lines[1].split())) if n else []
    head = build_linked_list(values)
    new_head = pairwiseSwap(head)
    print(" ".join(linked_list_to_list(new_head)))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function pairwiseSwap(head) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def pairwiseSwap(head):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Rotate Linked List by K Places',
    slug: 'rotate-linked-list-by-k-places',
    description: 'Rotate a singly linked list to the right by k places.',
    problemStatement: `
Given the head of a singly linked list and an integer \`k\`, rotate the list to the right by \`k\` places.

Examples:

<pre><code>Input:
5
1 2 3 4 5
2

Output:
4 5 1 2 3</code></pre>

<pre><code>Input:
6
10 20 30 40 50 60
3

Output:
40 50 60 10 20 30</code></pre>

<ul>
<li>0 ≤ n ≤ 10<sup>5</sup></li>
<li>0 ≤ k ≤ 10<sup>9</sup></li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
</ul>

Pro Tip: Compute the effective rotation as \`k % n\`, make the list circular, and then break it at the right position.
  `,
    sampleTestCases: [
      { input: '5\n1 2 3 4 5\n2', expected: '4 5 1 2 3' },
      { input: '6\n10 20 30 40 50 60\n3', expected: '40 50 60 10 20 30' },
    ],
    testCases: [
      { input: '0\n\n0', expected: '' },
      { input: '1\n7\n0', expected: '7' },
      { input: '1\n7\n1', expected: '7' },
      { input: '2\n1 2\n1', expected: '2 1' },
      { input: '4\n1 2 3 4\n4', expected: '1 2 3 4' },
      { input: '5\n1 2 3 4 5\n0', expected: '1 2 3 4 5' },
      { input: '5\n1 2 3 4 5\n5', expected: '1 2 3 4 5' },
      { input: '5\n1 2 3 4 5\n7', expected: '4 5 1 2 3' },
      { input: '6\n6 5 4 3 2 1\n3', expected: '3 2 1 6 5 4' },
      {
        input: '10\n1 2 3 4 5 6 7 8 9 10\n13',
        expected: '8 9 10 1 2 3 4 5 6 7',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you rotate a linked list efficiently without rebuilding it? Consider treating the list as a ring and breaking it in the right place.',
    difficulty: 'medium',
    frequency: 82,
    tags: ['linked list', 'rotation', 'modulo'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Find the length of the list and use k % length to avoid extra rotations.',
      'Form a circular list and then break it at the right point.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode();
  let curr = dummy;
  for (let v of arr) {
    curr.next = new ListNode(v);
    curr = curr.next;
  }
  return dummy.next;
}

function linkedListToArray(head) {
  const res = [];
  while (head) {
    res.push(head.val);
    head = head.next;
  }
  return res;
}

const fs = require("fs");
function main() {
  const lines = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(lines[0]);
  const values = n ? lines[1].split(" ").map(Number) : [];
  const k = parseInt(lines[2]);
  const head = buildLinkedList(values);
  const newHead = rotateList(head, k);
  console.log(linkedListToArray(newHead).join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode()
    curr = dummy
    for v in values:
        curr.next = ListNode(v)
        curr = curr.next
    return dummy.next

def linked_list_to_list(head):
    result = []
    while head:
        result.append(str(head.val))
        head = head.next
    return result

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0])
    values = list(map(int, lines[1].split())) if n else []
    k = int(lines[2])
    head = build_linked_list(values)
    new_head = rotateList(head, k)
    print(" ".join(linked_list_to_list(new_head)))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function rotateList(head, k) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def rotateList(head, k):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Sort a Linked List (Merge Sort)',
    slug: 'sort-linked-list-merge-sort',
    description:
      'Sort a singly linked list using merge sort algorithm in O(n log n) time and constant space.',
    problemStatement: `
Given the head of a singly linked list, sort it in ascending order using the merge sort algorithm and return the head of the sorted list.

You must perform the sorting in-place without using extra space for arrays or lists.

Examples:

<pre><code>Input:
5
4 2 1 3 5

Output:
1 2 3 4 5</code></pre>

<pre><code>Input:
6
-1 5 3 4 0 2

Output:
-1 0 2 3 4 5</code></pre>

<ul>
<li>0 ≤ n ≤ 10<sup>5</sup></li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
</ul>

Pro Tip: Use the slow and fast pointer technique to split the list and merge sorted halves recursively.
  `,
    sampleTestCases: [
      { input: '5\n4 2 1 3 5', expected: '1 2 3 4 5' },
      { input: '6\n-1 5 3 4 0 2', expected: '-1 0 2 3 4 5' },
    ],
    testCases: [
      { input: '0\n', expected: '' },
      { input: '1\n100', expected: '100' },
      { input: '2\n2 1', expected: '1 2' },
      { input: '3\n3 2 1', expected: '1 2 3' },
      { input: '4\n4 1 3 2', expected: '1 2 3 4' },
      { input: '5\n5 4 3 2 1', expected: '1 2 3 4 5' },
      { input: '6\n6 5 4 3 2 1', expected: '1 2 3 4 5 6' },
      { input: '7\n10 7 3 9 5 1 2', expected: '1 2 3 5 7 9 10' },
      { input: '8\n0 1 0 1 0 1 0 1', expected: '0 0 0 0 1 1 1 1' },
      { input: '10\n10 9 8 7 6 5 4 3 2 1', expected: '1 2 3 4 5 6 7 8 9 10' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Sorting a linked list efficiently requires divide and conquer. Can you implement merge sort with in-place merging of list nodes?',
    difficulty: 'hard',
    frequency: 88,
    tags: ['linked list', 'merge sort', 'recursion', 'divide and conquer'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use fast and slow pointers to split the list into two halves.',
      'Recursively sort each half and merge them using sorted merge.',
    ],
    optimalComplexity: {
      time: 'O(n log n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode();
  let curr = dummy;
  for (let v of arr) {
    curr.next = new ListNode(v);
    curr = curr.next;
  }
  return dummy.next;
}

function linkedListToArray(head) {
  const res = [];
  while (head) {
    res.push(head.val);
    head = head.next;
  }
  return res;
}

const fs = require("fs");
function main() {
  const lines = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(lines[0]);
  const values = n ? lines[1].split(" ").map(Number) : [];
  const head = buildLinkedList(values);
  const newHead = sortList(head);
  console.log(linkedListToArray(newHead).join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode()
    curr = dummy
    for v in values:
        curr.next = ListNode(v)
        curr = curr.next
    return dummy.next

def linked_list_to_list(head):
    result = []
    while head:
        result.append(str(head.val))
        head = head.next
    return result

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0])
    values = list(map(int, lines[1].split())) if n else []
    head = build_linked_list(values)
    new_head = sortList(head)
    print(" ".join(linked_list_to_list(new_head)))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function sortList(head) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def sortList(head):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Insertion Sort for Linked List',
    slug: 'insertion-sort-linked-list',
    description:
      'Sort a singly linked list using the insertion sort algorithm.',
    problemStatement: `
Given the head of a singly linked list, sort the list using the insertion sort algorithm and return its head.

Insertion sort iterates through the list, growing a sorted portion by inserting each element into its correct position.

Examples:

<pre><code>Input:
4
4 2 1 3

Output:
1 2 3 4</code></pre>

<pre><code>Input:
6
-1 5 3 4 0 2

Output:
-1 0 2 3 4 5</code></pre>

<ul>
<li>0 ≤ n ≤ 10<sup>5</sup></li>
<li>-10<sup>9</sup> ≤ node values ≤ 10<sup>9</sup></li>
</ul>

Pro Tip: Use a dummy head to help insert nodes into the sorted portion easily.
  `,
    sampleTestCases: [
      { input: '4\n4 2 1 3', expected: '1 2 3 4' },
      { input: '6\n-1 5 3 4 0 2', expected: '-1 0 2 3 4 5' },
    ],
    testCases: [
      { input: '0\n', expected: '' },
      { input: '1\n42', expected: '42' },
      { input: '2\n2 1', expected: '1 2' },
      { input: '3\n3 2 1', expected: '1 2 3' },
      { input: '4\n1 2 3 4', expected: '1 2 3 4' },
      { input: '5\n5 4 3 2 1', expected: '1 2 3 4 5' },
      { input: '6\n6 3 1 2 5 4', expected: '1 2 3 4 5 6' },
      { input: '7\n10 8 12 7 9 15 5', expected: '5 7 8 9 10 12 15' },
      { input: '8\n3 3 2 2 1 1 0 0', expected: '0 0 1 1 2 2 3 3' },
      { input: '10\n9 8 7 6 5 4 3 2 1 0', expected: '0 1 2 3 4 5 6 7 8 9' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Let's sort a linked list with the classic insertion sort. This one mimics how you might sort playing cards by hand, one node at a time.",
    difficulty: 'medium',
    frequency: 70,
    tags: ['linked list', 'sorting', 'insertion sort'],
    companies: [
      { name: 'Adobe', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use a dummy head and reinsert each node in its proper position.',
      'Maintain a sorted portion and build it as you go.',
    ],
    optimalComplexity: {
      time: 'O(n^2)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: `
class ListNode {
  constructor(val = 0, next = null) {
    this.val = val;
    this.next = next;
  }
}

function buildLinkedList(arr) {
  const dummy = new ListNode();
  let curr = dummy;
  for (let v of arr) {
    curr.next = new ListNode(v);
    curr = curr.next;
  }
  return dummy.next;
}

function linkedListToArray(head) {
  const res = [];
  while (head) {
    res.push(head.val);
    head = head.next;
  }
  return res;
}

const fs = require("fs");
function main() {
  const lines = fs.readFileSync(0, "utf-8").trim().split("\\n");
  const n = parseInt(lines[0]);
  const values = n ? lines[1].split(" ").map(Number) : [];
  const head = buildLinkedList(values);
  const newHead = insertionSortList(head);
  console.log(linkedListToArray(newHead).join(" "));
}
main();`,
      },
      {
        language: 'python',
        code: `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def build_linked_list(values):
    dummy = ListNode()
    curr = dummy
    for v in values:
        curr.next = ListNode(v)
        curr = curr.next
    return dummy.next

def linked_list_to_list(head):
    result = []
    while head:
        result.append(str(head.val))
        head = head.next
    return result

if __name__ == "__main__":
    import sys
    lines = sys.stdin.read().strip().split("\\n")
    n = int(lines[0])
    values = list(map(int, lines[1].split())) if n else []
    head = build_linked_list(values)
    new_head = insertionSortList(head)
    print(" ".join(linked_list_to_list(new_head)))`,
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: `
function insertionSortList(head) {
  // write code here
}`,
      },
      {
        language: 'python',
        code: `
def insertionSortList(head):
    # write code here
    pass`,
      },
    ],
  },
  {
    title: 'Sort 0s, 1s, and 2s in Linked List (Dutch National Flag)',
    slug: 'sort-0s-1s-2s-in-linked-list',
    description:
      'Sort a linked list containing only 0s, 1s, and 2s using the Dutch National Flag algorithm.',
    problemStatement:
      'You are given the head of a singly linked list where each node contains a value that is either 0, 1, or 2. Your task is to sort the linked list so that all nodes with the value 0 come first, followed by nodes with value 1, and then nodes with value 2.\n\nYou are not allowed to use any extra space (i.e., you must do it in-place), and you should not change the values inside the nodes; instead, change the links between nodes.\n\n<pre><code>Input: 6\n1 2 0 1 2 0\nOutput: 0 0 1 1 2 2\n\nInput: 3\n2 1 0\nOutput: 0 1 2</code></pre>\n\nExplanation:\nIn the first example, the linked list is rearranged such that 0s appear first, then 1s, and finally 2s.\n\n<ul>\n<li>1 ≤ n ≤ 10⁵</li>\n<li>Each node contains only values: 0, 1, or 2</li>\n<li>Do not use extra space</li>\n<li>Do not change node values</li>\n</ul>\n\nPro Tip: Think about partitioning the list into three sublists and rejoining them to avoid value swapping.',
    sampleTestCases: [
      {
        input: '6\n1 2 0 1 2 0',
        expected: '0 0 1 1 2 2',
      },
      {
        input: '3\n2 1 0',
        expected: '0 1 2',
      },
    ],
    testCases: [
      {
        input: '5\n0 1 2 0 1',
        expected: '0 0 1 1 2',
      },
      {
        input: '1\n0',
        expected: '0',
      },
      {
        input: '1\n1',
        expected: '1',
      },
      {
        input: '1\n2',
        expected: '2',
      },
      {
        input: '4\n2 2 2 2',
        expected: '2 2 2 2',
      },
      {
        input: '6\n0 0 1 1 2 2',
        expected: '0 0 1 1 2 2',
      },
      {
        input: '3\n1 0 2',
        expected: '0 1 2',
      },
      {
        input: '7\n2 2 1 1 0 0 0',
        expected: '0 0 0 1 1 2 2',
      },
      {
        input: '8\n1 2 1 2 0 1 2 0',
        expected: '0 0 1 1 1 2 2 2',
      },
      {
        input: '9\n0 2 1 0 2 1 0 2 1',
        expected: '0 0 0 1 1 1 2 2 2',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re working with a constrained environment—think embedded systems or memory-restricted devices. Can you sort a linked list containing only 0s, 1s, and 2s efficiently, without modifying the node values and using no extra memory? Let’s go Dutch Flag on this!',
    difficulty: 'medium',
    frequency: 78,
    tags: ['linked list', 'sorting', 'in-place', 'two pointer'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Try creating three dummy nodes for 0s, 1s, and 2s.',
      'Link the tail of each list to the next one in order.',
      'Don’t forget to nullify the last node’s next pointer.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  const dummy = new ListNode(0);\n  let current = dummy;\n  for (let val of arr) {\n    current.next = new ListNode(val);\n    current = current.next;\n  }\n  return dummy.next;\n}\n\nfunction linkedListToArray(head) {\n  const result = [];\n  while (head) {\n    result.push(head.val);\n    head = head.next;\n  }\n  return result;\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const values = input[1].split(" ").map(Number);\n  const head = buildLinkedList(values);\n  const sortedHead = sortList(head);\n  console.log(linkedListToArray(sortedHead).join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_linked_list(values):\n    dummy = ListNode(0)\n    curr = dummy\n    for v in values:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next\n\ndef linked_list_to_list(head):\n    result = []\n    while head:\n        result.append(str(head.val))\n        head = head.next\n    return result\n\nif __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    values = list(map(int, input_lines[1].split()))\n    head = build_linked_list(values)\n    sorted_head = sortList(head)\n    print(" ".join(linked_list_to_list(sorted_head)))',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction sortList(head) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef sortList(head):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Sort 0s, 1s, and 2s in Linked List (Dutch National Flag)',
    slug: 'sort-0s-1s-2s-in-linked-list',
    description:
      'Sort a linked list containing only 0s, 1s, and 2s using the Dutch National Flag algorithm.',
    problemStatement:
      'You are given the head of a singly linked list where each node contains a value that is either 0, 1, or 2. Your task is to sort the linked list so that all nodes with the value 0 come first, followed by nodes with value 1, and then nodes with value 2.\n\nYou are not allowed to use any extra space (i.e., you must do it in-place), and you should not change the values inside the nodes; instead, change the links between nodes.\n\n<pre><code>Input: 6\n1 2 0 1 2 0\nOutput: 0 0 1 1 2 2\n\nInput: 3\n2 1 0\nOutput: 0 1 2</code></pre>\n\nExplanation:\nIn the first example, the linked list is rearranged such that 0s appear first, then 1s, and finally 2s.\n\n<ul>\n<li>1 ≤ n ≤ 10⁵</li>\n<li>Each node contains only values: 0, 1, or 2</li>\n<li>Do not use extra space</li>\n<li>Do not change node values</li>\n</ul>\n\nPro Tip: Think about partitioning the list into three sublists and rejoining them to avoid value swapping.',
    sampleTestCases: [
      {
        input: '6\n1 2 0 1 2 0',
        expected: '0 0 1 1 2 2',
      },
      {
        input: '3\n2 1 0',
        expected: '0 1 2',
      },
    ],
    testCases: [
      {
        input: '5\n0 1 2 0 1',
        expected: '0 0 1 1 2',
      },
      {
        input: '1\n0',
        expected: '0',
      },
      {
        input: '1\n1',
        expected: '1',
      },
      {
        input: '1\n2',
        expected: '2',
      },
      {
        input: '4\n2 2 2 2',
        expected: '2 2 2 2',
      },
      {
        input: '6\n0 0 1 1 2 2',
        expected: '0 0 1 1 2 2',
      },
      {
        input: '3\n1 0 2',
        expected: '0 1 2',
      },
      {
        input: '7\n2 2 1 1 0 0 0',
        expected: '0 0 0 1 1 2 2',
      },
      {
        input: '8\n1 2 1 2 0 1 2 0',
        expected: '0 0 1 1 1 2 2 2',
      },
      {
        input: '9\n0 2 1 0 2 1 0 2 1',
        expected: '0 0 0 1 1 1 2 2 2',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re working with a constrained environment—think embedded systems or memory-restricted devices. Can you sort a linked list containing only 0s, 1s, and 2s efficiently, without modifying the node values and using no extra memory? Let’s go Dutch Flag on this!',
    difficulty: 'medium',
    frequency: 78,
    tags: ['linked list', 'sorting', 'in-place', 'two pointer'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Try creating three dummy nodes for 0s, 1s, and 2s.',
      'Link the tail of each list to the next one in order.',
      'Don’t forget to nullify the last node’s next pointer.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  const dummy = new ListNode(0);\n  let current = dummy;\n  for (let val of arr) {\n    current.next = new ListNode(val);\n    current = current.next;\n  }\n  return dummy.next;\n}\n\nfunction linkedListToArray(head) {\n  const result = [];\n  while (head) {\n    result.push(head.val);\n    head = head.next;\n  }\n  return result;\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const values = input[1].split(" ").map(Number);\n  const head = buildLinkedList(values);\n  const sortedHead = sortList(head);\n  console.log(linkedListToArray(sortedHead).join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_linked_list(values):\n    dummy = ListNode(0)\n    curr = dummy\n    for v in values:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next\n\ndef linked_list_to_list(head):\n    result = []\n    while head:\n        result.append(str(head.val))\n        head = head.next\n    return result\n\nif __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    values = list(map(int, input_lines[1].split()))\n    head = build_linked_list(values)\n    sorted_head = sortList(head)\n    print(" ".join(linked_list_to_list(sorted_head)))',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction sortList(head) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef sortList(head):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Flatten a Multilevel Linked List',
    slug: 'flatten-multilevel-linked-list',
    description:
      'Flatten a multilevel linked list into a single-level singly linked list in-place.',
    problemStatement:
      'You are given a special linked list in which each node has two pointers:\n<ul><li><code>next</code> – points to the next node in the same level</li><li><code>child</code> – may point to a separate linked list (i.e., a sublist)</li></ul>\n\nWrite a function to flatten this multilevel linked list into a single-level singly linked list. The nodes should be arranged in a depth-first, pre-order traversal (i.e., visit the node, then its child list, then the next node).\n\n<pre><code>Input: 1 - 2 - 3\n           |\n           7 - 8\n               |\n               11 - 12\nOutput: 1 2 3 7 8 11 12\n\nInput: 10 - 5\n         |\n         6 - 9\nOutput: 10 5 6 9</code></pre>\n\nExplanation:\nEach child list should be inserted between the node and its next. Continue recursively.\n\n<ul>\n<li>1 ≤ Total nodes ≤ 10⁴</li>\n<li>Each node contains integer values (can be negative)</li>\n<li>No node is shared between multiple parents</li>\n<li>You must flatten the list in-place</li>\n</ul>\n\nPro Tip: Consider a recursive or iterative stack-based traversal to simulate depth-first linking.',
    sampleTestCases: [
      {
        input: '7\n1 -1\n2 -1\n3 4\n4 -1\n7 5\n8 6\n11 -1\n12 -1',
        expected: '1 2 3 7 8 11 12',
      },
      {
        input: '4\n10 -1\n5 2\n6 3\n9 -1',
        expected: '10 5 6 9',
      },
    ],
    testCases: [
      {
        input: '3\n1 -1\n2 -1\n3 -1',
        expected: '1 2 3',
      },
      {
        input: '1\n99 -1',
        expected: '99',
      },
      {
        input: '4\n1 1\n2 -1\n3 -1\n4 -1',
        expected: '1 2',
      },
      {
        input: '5\n1 1\n2 2\n3 -1\n4 -1\n5 -1',
        expected: '1 2 3',
      },
      {
        input: '6\n1 -1\n2 -1\n3 3\n4 4\n5 -1\n6 -1',
        expected: '1 2 3 4 5 6',
      },
      {
        input: '7\n10 -1\n20 2\n30 4\n40 -1\n50 6\n60 -1\n70 -1',
        expected: '10 20 30 50 60 70 40',
      },
      {
        input: '3\n1 1\n2 2\n3 -1',
        expected: '1 2 3',
      },
      {
        input: '5\n1 2\n2 3\n3 4\n4 5\n5 -1',
        expected: '1 2 3 4 5',
      },
      {
        input: '4\n1 1\n2 -1\n3 2\n4 -1',
        expected: '1 2 3 4',
      },
      {
        input: '6\n1 -1\n2 3\n3 -1\n4 -1\n5 5\n6 -1',
        expected: '1 2 4 5 6 3',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're building a visual file explorer where each folder contains files or subfolders. Your data structure uses a multilevel linked list to represent this hierarchy. Flatten it to get a single ordered list of all files, depth-first.",
    difficulty: 'medium',
    frequency: 74,
    tags: ['linked list', 'depth-first search', 'recursion', 'stack'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Uber', logoUrl: '' },
    ],
    hints: [
      'Use a stack or recursion to perform a depth-first traversal.',
      'Always reconnect the last node of a child list to the next node of the parent.',
      'Handle nulls carefully to avoid breaking links.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)', // due to stack in recursion or iterative approach
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class Node {\n  constructor(val, next = null, child = null) {\n    this.val = val;\n    this.next = next;\n    this.child = child;\n  }\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nodes = [];\n  for (let i = 1; i <= n; i++) {\n    const [val, childIdx] = input[i].split(" ").map(Number);\n    nodes.push(new Node(val));\n  }\n  for (let i = 0; i < n - 1; i++) nodes[i].next = nodes[i + 1];\n  for (let i = 1; i <= n; i++) {\n    const [, childIdx] = input[i].split(" ").map(Number);\n    if (childIdx !== -1) nodes[i - 1].child = nodes[childIdx];\n  }\n  const result = flattenList(nodes[0]);\n  const output = [];\n  let curr = result;\n  while (curr) {\n    output.push(curr.val);\n    curr = curr.next;\n  }\n  console.log(output.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class Node:\n    def __init__(self, val, next=None, child=None):\n        self.val = val\n        self.next = next\n        self.child = child\n\nif __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    nodes = []\n    for i in range(1, n + 1):\n        val, child = map(int, input_lines[i].split())\n        nodes.append(Node(val))\n    for i in range(n - 1):\n        nodes[i].next = nodes[i + 1]\n    for i in range(1, n + 1):\n        val, child = map(int, input_lines[i].split())\n        if child != -1:\n            nodes[i - 1].child = nodes[child]\n    head = flattenList(nodes[0])\n    curr = head\n    result = []\n    while curr:\n        result.append(str(curr.val))\n        curr = curr.next\n    print(" ".join(result))',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class Node {\n  constructor(val, next = null, child = null) {\n    this.val = val;\n    this.next = next;\n    this.child = child;\n  }\n}\n\nfunction flattenList(head) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class Node:\n    def __init__(self, val, next=None, child=None):\n        self.val = val\n        self.next = next\n        self.child = child\n\ndef flattenList(head):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Flatten a Linked List of Linked Lists',
    slug: 'flatten-linked-list-of-linked-lists',
    description:
      'Flatten a linked list where each node has a pointer to a sorted sub-linked list, producing a single sorted linked list.',
    problemStatement:
      'You are given a special linked list where each node has two pointers:\n<ul><li><code>next</code> – points to the next main list node</li><li><code>bottom</code> – points to a sorted linked list</li></ul>\n\nEach of these bottom-linked lists is individually sorted. Your task is to flatten the entire structure into a single-level sorted linked list using only the <code>bottom</code> pointers.\n\nReturn the head of the final flattened and sorted linked list.\n\n<pre><code>Input:\n5 -> 10 -> 19 -> 28\n|     |     |     |\n7     20    22    35\n|           |     |\n8           50    40\n|                 |\n30                45\n\nOutput:\n5 7 8 10 19 20 22 28 30 35 40 45 50</code></pre>\n\nExplanation:\nEach node’s bottom list is sorted. You must merge all these into one sorted list by traversing only using the bottom pointers.\n\n<ul>\n<li>1 ≤ total nodes ≤ 5000</li>\n<li>Each bottom list is individually sorted</li>\n<li>Do not use extra space for flattening</li>\n<li>Final list should use only bottom pointers</li>\n</ul>\n\nPro Tip: Think of merging k sorted linked lists using a priority queue or iterative pairwise merge strategy.',
    sampleTestCases: [
      {
        input: '4\n5 7 8 30\n10 20\n19 22 50\n28 35 40 45',
        expected: '5 7 8 10 19 20 22 28 30 35 40 45 50',
      },
      {
        input: '2\n1 3 5\n2 4 6',
        expected: '1 2 3 4 5 6',
      },
    ],
    testCases: [
      {
        input: '1\n1 2 3',
        expected: '1 2 3',
      },
      {
        input: '3\n10\n5 7\n12 15 20',
        expected: '5 7 10 12 15 20',
      },
      {
        input: '4\n1 3 5\n2 4 6\n0\n7 8 9',
        expected: '0 1 2 3 4 5 6 7 8 9',
      },
      {
        input: '2\n100 200\n50 150 300',
        expected: '50 100 150 200 300',
      },
      {
        input: '3\n1\n2\n3',
        expected: '1 2 3',
      },
      {
        input: '2\n5 10 15\n6 9 12',
        expected: '5 6 9 10 12 15',
      },
      {
        input: '3\n7 14 21\n8 16 24\n9 18 27',
        expected: '7 8 9 14 16 18 21 24 27',
      },
      {
        input: '2\n1 3 5 7\n2 4 6 8',
        expected: '1 2 3 4 5 6 7 8',
      },
      {
        input: '1\n9 11 13 15',
        expected: '9 11 13 15',
      },
      {
        input: '4\n1\n3\n2\n4',
        expected: '1 2 3 4',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "At LinkedIn, we use hierarchical messaging threads that are structured like a 'linked list of linked lists'. Can you flatten such a structure into one chronological list using only the bottom links?",
    difficulty: 'medium',
    frequency: 81,
    tags: ['linked list', 'merge', 'heap', 'divide and conquer'],
    companies: [
      { name: 'LinkedIn', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Merge two sorted linked lists at a time using bottom pointers.',
      'Use divide-and-conquer or a heap if you want an efficient flattening.',
      'Always return the head of the newly merged list.',
    ],
    optimalComplexity: {
      time: 'O(n * log k)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n    this.bottom = null;\n  }\n}\n\nfunction buildMultiLevelList(input) {\n  const lines = input.trim().split("\\n");\n  const n = parseInt(lines[0]);\n  const nodes = [];\n  for (let i = 1; i <= n; i++) {\n    const values = lines[i].split(" ").map(Number);\n    let head = new Node(values[0]);\n    let curr = head;\n    for (let j = 1; j < values.length; j++) {\n      curr.bottom = new Node(values[j]);\n      curr = curr.bottom;\n    }\n    nodes.push(head);\n  }\n  for (let i = 0; i < n - 1; i++) nodes[i].next = nodes[i + 1];\n  return nodes[0];\n}\n\nfunction printBottomList(head) {\n  const res = [];\n  while (head) {\n    res.push(head.val);\n    head = head.bottom;\n  }\n  console.log(res.join(" "));\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8");\n  const head = buildMultiLevelList(input);\n  const flat = flattenList(head);\n  printBottomList(flat);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n        self.bottom = None\n\ndef build_multilevel_list(input_lines):\n    n = int(input_lines[0])\n    nodes = []\n    for line in input_lines[1:n+1]:\n        vals = list(map(int, line.split()))\n        head = Node(vals[0])\n        curr = head\n        for v in vals[1:]:\n            curr.bottom = Node(v)\n            curr = curr.bottom\n        nodes.append(head)\n    for i in range(n - 1):\n        nodes[i].next = nodes[i + 1]\n    return nodes[0]\n\ndef print_bottom_list(head):\n    result = []\n    while head:\n        result.append(str(head.val))\n        head = head.bottom\n    print(" ".join(result))\n\nif __name__ == "__main__":\n    import sys\n    lines = sys.stdin.read().strip().split("\\n")\n    head = build_multilevel_list(lines)\n    flat = flattenList(head)\n    print_bottom_list(flat)',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n    this.bottom = null;\n  }\n}\n\nfunction flattenList(head) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n        self.bottom = None\n\ndef flattenList(head):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Merge Two Circular Linked Lists',
    slug: 'merge-two-circular-linked-lists',
    description:
      'Merge two sorted circular singly linked lists into one sorted circular linked list.',
    problemStatement:
      'You are given the heads of two **sorted circular singly linked lists**. Your task is to merge these two lists into a single sorted circular singly linked list.\n\nYou must maintain the circular nature of the list and perform the merge in-place (i.e., without using any extra data structures).\n\n<pre><code>Input:\nList1: 1 -> 3 -> 5 -> back to 1\nList2: 2 -> 4 -> 6 -> back to 2\n\nOutput:\n1 -> 2 -> 3 -> 4 -> 5 -> 6 -> back to 1</code></pre>\n\nExplanation:\nThe two input lists are circular. The merged list is also circular, sorted in ascending order, and starts at the smaller head.\n\n<ul>\n<li>1 ≤ total nodes in each list ≤ 10⁴</li>\n<li>Node values are integers and can be negative</li>\n<li>Both input lists are non-empty and sorted in ascending order</li>\n<li>Return the head of the new merged circular list</li>\n</ul>\n\nPro Tip: Be cautious about infinite loops caused by the circular structure—use condition checks wisely during traversal.',
    sampleTestCases: [
      {
        input: '3\n1 3 5\n3\n2 4 6',
        expected: '1 2 3 4 5 6',
      },
      {
        input: '2\n7 9\n3\n1 2 3',
        expected: '1 2 3 7 9',
      },
    ],
    testCases: [
      {
        input: '1\n1\n1\n2',
        expected: '1 2',
      },
      {
        input: '2\n1 4\n2\n2 3',
        expected: '1 2 3 4',
      },
      {
        input: '3\n5 10 15\n2\n7 20',
        expected: '5 7 10 15 20',
      },
      {
        input: '1\n10\n3\n1 5 6',
        expected: '1 5 6 10',
      },
      {
        input: '3\n-10 -5 0\n3\n-6 -2 2',
        expected: '-10 -6 -5 -2 0 2',
      },
      {
        input: '2\n100 200\n2\n150 250',
        expected: '100 150 200 250',
      },
      {
        input: '4\n1 2 3 4\n4\n5 6 7 8',
        expected: '1 2 3 4 5 6 7 8',
      },
      {
        input: '2\n1 100\n2\n50 150',
        expected: '1 50 100 150',
      },
      {
        input: '3\n3 6 9\n1\n1',
        expected: '1 3 6 9',
      },
      {
        input: '2\n5 10\n1\n0',
        expected: '0 5 10',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're maintaining a real-time priority queue system using circular sorted lists for efficiency. Can you merge two such lists without breaking the circularity?",
    difficulty: 'medium',
    frequency: 65,
    tags: ['linked list', 'circular list', 'merge', 'two pointer'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Bloomberg', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Start with the list that has the smaller head.',
      'While traversing, keep track of the position where nodes need to be inserted.',
      'Break circular links temporarily if necessary, but reestablish them correctly.',
    ],
    optimalComplexity: {
      time: 'O(n + m)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\nfunction buildCircularList(values) {\n  const head = new Node(values[0]);\n  let curr = head;\n  for (let i = 1; i < values.length; i++) {\n    curr.next = new Node(values[i]);\n    curr = curr.next;\n  }\n  curr.next = head;\n  return head;\n}\n\nfunction printCircularList(head) {\n  const res = [];\n  const start = head;\n  do {\n    res.push(head.val);\n    head = head.next;\n  } while (head !== start);\n  console.log(res.join(" "));\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const list1 = input[1].split(" ").map(Number);\n  const m = parseInt(input[2]);\n  const list2 = input[3].split(" ").map(Number);\n  const head1 = buildCircularList(list1);\n  const head2 = buildCircularList(list2);\n  const merged = mergeCircularLists(head1, head2);\n  printCircularList(merged);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\ndef build_circular_list(values):\n    head = Node(values[0])\n    curr = head\n    for val in values[1:]:\n        curr.next = Node(val)\n        curr = curr.next\n    curr.next = head\n    return head\n\ndef print_circular_list(head):\n    result = []\n    start = head\n    while True:\n        result.append(str(head.val))\n        head = head.next\n        if head == start:\n            break\n    print(" ".join(result))\n\nif __name__ == "__main__":\n    import sys\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    list1 = list(map(int, lines[1].split()))\n    m = int(lines[2])\n    list2 = list(map(int, lines[3].split()))\n    head1 = build_circular_list(list1)\n    head2 = build_circular_list(list2)\n    merged = mergeCircularLists(head1, head2)\n    print_circular_list(merged)',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class Node {\n  constructor(val) {\n    this.val = val;\n    this.next = null;\n  }\n}\n\nfunction mergeCircularLists(head1, head2) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\ndef mergeCircularLists(head1, head2):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Convert Binary Number in Linked List to Integer',
    slug: 'convert-binary-linked-list-to-integer',
    description:
      'Convert a binary number represented as a singly linked list to its decimal (integer) equivalent.',
    problemStatement:
      'You are given a singly linked list where each node contains a single digit: either 0 or 1. The entire list represents a binary number in big-endian format (most significant bit comes first).\n\nWrite a function that converts the binary number represented by this linked list to its decimal (base-10) equivalent.\n\n<pre><code>Input: 1 -> 0 -> 1\nOutput: 5\n\nInput: 1 -> 1 -> 1 -> 0\nOutput: 14</code></pre>\n\nExplanation:\nThe first example represents binary 101 = 1×2² + 0×2¹ + 1×2⁰ = 5.\nThe second represents binary 1110 = 14.\n\n<ul>\n<li>1 ≤ number of nodes ≤ 10⁴</li>\n<li>Each node value is either 0 or 1</li>\n<li>Linked list does not contain leading zeros unless the number is 0</li>\n</ul>\n\nPro Tip: You can keep a running result and shift it left by 1 on each step, adding the current digit.',
    sampleTestCases: [
      {
        input: '3\n1 0 1',
        expected: '5',
      },
      {
        input: '4\n1 1 1 0',
        expected: '14',
      },
    ],
    testCases: [
      {
        input: '1\n0',
        expected: '0',
      },
      {
        input: '1\n1',
        expected: '1',
      },
      {
        input: '2\n1 0',
        expected: '2',
      },
      {
        input: '5\n1 0 0 1 1',
        expected: '19',
      },
      {
        input: '6\n1 1 0 1 0 1',
        expected: '53',
      },
      {
        input: '7\n1 0 1 0 1 0 1',
        expected: '85',
      },
      {
        input: '8\n1 1 1 1 1 1 1 1',
        expected: '255',
      },
      {
        input: '4\n0 0 0 1',
        expected: '1',
      },
      {
        input: '9\n1 0 0 0 0 0 0 0 0',
        expected: '256',
      },
      {
        input: '10\n1 0 1 0 1 0 1 0 1 0',
        expected: '682',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're decoding binary messages transmitted over a network, and the bits are coming in as a linked list stream. Can you convert this stream into its numeric value in decimal?",
    difficulty: 'easy',
    frequency: 92,
    tags: ['linked list', 'binary', 'bit manipulation'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Start with result = 0 and for each node, update: result = result * 2 + node.val',
      'Alternatively, bit shift left: result = (result << 1) | node.val',
      'Traverse the list once, updating result each step.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  const dummy = new ListNode();\n  let curr = dummy;\n  for (let val of arr) {\n    curr.next = new ListNode(val);\n    curr = curr.next;\n  }\n  return dummy.next;\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const values = input[1].split(" ").map(Number);\n  const head = buildLinkedList(values);\n  const result = getDecimalValue(head);\n  console.log(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_linked_list(values):\n    dummy = ListNode()\n    current = dummy\n    for v in values:\n        current.next = ListNode(v)\n        current = current.next\n    return dummy.next\n\nif __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    values = list(map(int, input_lines[1].split()))\n    head = build_linked_list(values)\n    result = getDecimalValue(head)\n    print(result)',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction getDecimalValue(head) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef getDecimalValue(head):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Convert Sorted Linked List to Balanced BST',
    slug: 'convert-linked-list-to-balanced-bst',
    description:
      'Convert a sorted singly linked list into a height-balanced binary search tree.',
    problemStatement:
      'You are given the head of a **sorted singly linked list** in ascending order. Your task is to convert this linked list into a height-balanced Binary Search Tree (BST).\n\nA height-balanced BST is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\n\nReturn the root of the BST.\n\n<pre><code>Input: -10 -> -3 -> 0 -> 5 -> 9\nOutput: [0,-3,9,-10,null,5]\n\nInput: 1 -> 3\nOutput: [3,1]</code></pre>\n\nExplanation:\nThe output format is level-order traversal of the resulting tree (null represents absent children).\n\n<ul>\n<li>1 ≤ number of nodes ≤ 10⁴</li>\n<li>List is sorted in strictly increasing order</li>\n<li>Return the tree root in level order (for test comparison)</li>\n</ul>\n\nPro Tip: Use the slow and fast pointer strategy to find the middle node for the root, then recursively construct the left and right subtrees.',
    sampleTestCases: [
      {
        input: '5\n-10 -3 0 5 9',
        expected: '0 -3 9 -10 null 5',
      },
      {
        input: '2\n1 3',
        expected: '3 1',
      },
    ],
    testCases: [
      {
        input: '1\n5',
        expected: '5',
      },
      {
        input: '3\n1 2 3',
        expected: '2 1 3',
      },
      {
        input: '4\n1 2 3 4',
        expected: '3 2 4 1',
      },
      {
        input: '6\n-5 -3 -1 0 2 4',
        expected: '0 -3 2 -5 -1 null 4',
      },
      {
        input: '7\n-10 -5 -3 0 1 3 6',
        expected: '0 -5 3 -10 -3 1 6',
      },
      {
        input: '8\n1 2 3 4 5 6 7 8',
        expected: '5 2 7 1 3 6 8 null null null 4',
      },
      {
        input: '5\n0 1 2 3 4',
        expected: '2 1 4 0 null 3',
      },
      {
        input: '6\n10 20 30 40 50 60',
        expected: '40 20 60 10 30 50',
      },
      {
        input: '7\n-7 -6 -5 -4 -3 -2 -1',
        expected: '-4 -6 -2 -7 -5 -3 -1',
      },
      {
        input: '3\n100 200 300',
        expected: '200 100 300',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're building an auto-suggestion engine that requires a balanced binary search structure for sorted input. Convert the sorted linked list of keywords into a balanced BST.",
    difficulty: 'medium',
    frequency: 80,
    tags: [
      'linked list',
      'binary search tree',
      'recursion',
      'divide and conquer',
    ],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Apple', logoUrl: '' },
    ],
    hints: [
      'Use the slow-fast pointer technique to find the middle of the list.',
      'Recursively build left and right trees from the list halves.',
      'Carefully disconnect the middle node when building left subtree.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(log n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nclass TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  const dummy = new ListNode();\n  let curr = dummy;\n  for (let v of arr) {\n    curr.next = new ListNode(v);\n    curr = curr.next;\n  }\n  return dummy.next;\n}\n\nfunction levelOrder(root) {\n  const queue = [root], res = [];\n  while (queue.length) {\n    const node = queue.shift();\n    if (node) {\n      res.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else res.push("null");\n  }\n  while (res[res.length - 1] === "null") res.pop();\n  console.log(res.join(" "));\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const values = input[1].split(" ").map(Number);\n  const head = buildLinkedList(values);\n  const bstRoot = sortedListToBST(head);\n  levelOrder(bstRoot);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_linked_list(arr):\n    dummy = ListNode()\n    curr = dummy\n    for v in arr:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next\n\ndef level_order(root):\n    from collections import deque\n    q, res = deque([root]), []\n    while q:\n        node = q.popleft()\n        if node:\n            res.append(str(node.val))\n            q.append(node.left)\n            q.append(node.right)\n        else:\n            res.append("null")\n    while res and res[-1] == "null":\n        res.pop()\n    print(" ".join(res))\n\nif __name__ == "__main__":\n    import sys\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    values = list(map(int, lines[1].split()))\n    head = build_linked_list(values)\n    root = sortedListToBST(head)\n    level_order(root)',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nclass TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nfunction sortedListToBST(head) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef sortedListToBST(head):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Copy List with Random Pointer',
    slug: 'copy-list-with-random-pointer',
    description:
      'Deep copy a linked list where each node contains an additional random pointer.',
    problemStatement:
      'You are given a special singly linked list where each node contains:\n<ul><li><code>val</code>: an integer</li><li><code>next</code>: pointer to the next node</li><li><code>random</code>: pointer to any node in the list (or null)</li></ul>\n\nWrite a function that makes a deep copy of the entire list, including both the <code>next</code> and <code>random</code> pointers.\n\nReturn the head of the copied list.\n\n<pre><code>Input:\nNode values: [7,13,11,10,1]\nRandom indices: [-1,0,4,2,0]\nOutput:\n7[null] -> 13[7] -> 11[1] -> 10[11] -> 1[7]</code></pre>\n\nExplanation:\nThe list is represented as two arrays: values and random indices. Each node has a random pointer pointing to the node at the corresponding index (or null if -1).\n\n<ul>\n<li>0 ≤ number of nodes ≤ 1000</li>\n<li>Node values can range from -10⁴ to 10⁴</li>\n<li>Random pointers can point to any node or be null</li>\n<li>You must return a deep copy, not a shallow reference</li>\n</ul>\n\nPro Tip: Consider using a hash map to map original nodes to their copies for random linkage, or interleave the copied nodes in-place to avoid extra space.',
    sampleTestCases: [
      {
        input: '5\n7 13 11 10 1\n-1 0 4 2 0',
        expected: '7[null] 13[7] 11[1] 10[11] 1[7]',
      },
      {
        input: '3\n1 2 3\n2 0 1',
        expected: '1[3] 2[1] 3[2]',
      },
    ],
    testCases: [
      {
        input: '1\n10\n-1',
        expected: '10[null]',
      },
      {
        input: '2\n1 2\n1 0',
        expected: '1[2] 2[1]',
      },
      {
        input: '4\n1 2 3 4\n3 2 1 0',
        expected: '1[4] 2[3] 3[2] 4[1]',
      },
      {
        input: '3\n5 10 15\n-1 -1 -1',
        expected: '5[null] 10[null] 15[null]',
      },
      {
        input: '5\n10 20 30 40 50\n4 3 2 1 0',
        expected: '10[50] 20[40] 30[30] 40[20] 50[10]',
      },
      {
        input: '2\n99 100\n0 -1',
        expected: '99[99] 100[null]',
      },
      {
        input: '3\n3 2 1\n1 0 -1',
        expected: '3[2] 2[3] 1[null]',
      },
      {
        input: '0',
        expected: '',
      },
      {
        input: '6\n1 2 3 4 5 6\n5 4 3 2 1 0',
        expected: '1[6] 2[5] 3[4] 4[3] 5[2] 6[1]',
      },
      {
        input: '3\n1 1 1\n2 0 1',
        expected: '1[1] 1[1] 1[1]',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'This is a classic data structure cloning challenge. Can you design a deep copy function that not only preserves node order but also replicates their random connections accurately?',
    difficulty: 'medium',
    frequency: 93,
    tags: ['linked list', 'hashmap', 'in-place', 'deep copy'],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use a hash map to associate each node with its copy, then set random pointers.',
      'Alternatively, interleave copied nodes with originals and unlink them after linking randoms.',
      'Be careful about circular references and nulls.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)', // with interleaving trick
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class Node {\n  constructor(val, next = null, random = null) {\n    this.val = val;\n    this.next = next;\n    this.random = random;\n  }\n}\n\nfunction buildRandomList(values, randomIndices) {\n  const nodes = values.map(v => new Node(v));\n  for (let i = 0; i < nodes.length - 1; i++) nodes[i].next = nodes[i + 1];\n  for (let i = 0; i < nodes.length; i++)\n    nodes[i].random = randomIndices[i] === -1 ? null : nodes[randomIndices[i]];\n  return nodes[0] || null;\n}\n\nfunction printRandomList(head) {\n  const vals = [], map = new Map(), idxMap = new Map();\n  let i = 0, node = head;\n  while (node) {\n    map.set(node, i);\n    idxMap.set(i, node);\n    vals.push(`${node.val}`);\n    node = node.next;\n    i++;\n  }\n  node = head;\n  let out = [];\n  while (node) {\n    out.push(`${node.val}[${node.random ? node.random.val : "null"}]`);\n    node = node.next;\n  }\n  console.log(out.join(" "));\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  if (!input.length || input[0] === "0") return;\n  const n = parseInt(input[0]);\n  const values = input[1].split(" ").map(Number);\n  const randomIndices = input[2].split(" ").map(Number);\n  const head = buildRandomList(values, randomIndices);\n  const cloned = copyRandomList(head);\n  printRandomList(cloned);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class Node:\n    def __init__(self, val, next=None, random=None):\n        self.val = val\n        self.next = next\n        self.random = random\n\ndef build_random_list(values, random_indices):\n    nodes = [Node(val) for val in values]\n    for i in range(len(nodes) - 1):\n        nodes[i].next = nodes[i+1]\n    for i, idx in enumerate(random_indices):\n        if idx != -1:\n            nodes[i].random = nodes[idx]\n    return nodes[0] if nodes else None\n\ndef print_random_list(head):\n    result = []\n    node = head\n    while node:\n        r = node.random.val if node.random else \'null\'\n        result.append(f"{node.val}[{r}]")\n        node = node.next\n    print(" ".join(result))\n\nif __name__ == "__main__":\n    import sys\n    lines = sys.stdin.read().strip().split("\\n")\n    if not lines or lines[0] == "0":\n        exit()\n    n = int(lines[0])\n    values = list(map(int, lines[1].split()))\n    random_indices = list(map(int, lines[2].split()))\n    head = build_random_list(values, random_indices)\n    cloned = copyRandomList(head)\n    print_random_list(cloned)',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class Node {\n  constructor(val, next = null, random = null) {\n    this.val = val;\n    this.next = next;\n    this.random = random;\n  }\n}\n\nfunction copyRandomList(head) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class Node:\n    def __init__(self, val, next=None, random=None):\n        self.val = val\n        self.next = next\n        self.random = random\n\ndef copyRandomList(head):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Clone Linked List with Next and Random Pointers',
    slug: 'clone-linked-list-random-pointer',
    description:
      'Clone a linked list where each node has both next and random pointers using HashMap or O(1) space interleaving method.',
    problemStatement:
      "You are given a singly linked list where each node has:\n<ul><li><code>val</code>: the node's integer value</li><li><code>next</code>: the next pointer</li><li><code>random</code>: a random pointer to any node in the list (or null)</li></ul>\n\nImplement a function to deep clone the list. Your cloned list must contain all the original <code>next</code> and <code>random</code> relationships.\n\nYou must implement the function using either:\n<ul>\n<li>A HashMap to map original nodes to copied ones (O(n) space), or</li>\n<li>An interleaving in-place approach (O(1) extra space)</li>\n</ul>\n\n<pre><code>Input:\nNodes: [1, 2, 3]\nRandom: [-1, 0, 1]\n\nOutput:\n1[null] -> 2[1] -> 3[2]</code></pre>\n\nExplanation:\nRandom[i] gives the index (0-based) of the node that node i's random pointer should point to (or -1 for null).\n\n<ul>\n<li>0 ≤ number of nodes ≤ 1000</li>\n<li>Values of nodes range between -10⁴ and 10⁴</li>\n<li>Output should be a deep copy (new node references)</li>\n</ul>\n\nPro Tip: To achieve O(1) space, consider interleaving cloned nodes between original nodes, assigning randoms, then detaching the copy.",
    sampleTestCases: [
      {
        input: '3\n1 2 3\n-1 0 1',
        expected: '1[null] 2[1] 3[2]',
      },
      {
        input: '2\n10 20\n1 0',
        expected: '10[20] 20[10]',
      },
    ],
    testCases: [
      {
        input: '1\n99\n-1',
        expected: '99[null]',
      },
      {
        input: '2\n1 2\n-1 -1',
        expected: '1[null] 2[null]',
      },
      {
        input: '3\n1 2 3\n2 1 0',
        expected: '1[3] 2[2] 3[1]',
      },
      {
        input: '4\n5 6 7 8\n3 2 1 0',
        expected: '5[8] 6[7] 7[6] 8[5]',
      },
      {
        input: '3\n10 20 30\n1 1 0',
        expected: '10[20] 20[20] 30[10]',
      },
      {
        input: '2\n0 0\n1 0',
        expected: '0[0] 0[0]',
      },
      {
        input: '3\n3 2 1\n0 1 2',
        expected: '3[3] 2[2] 1[1]',
      },
      {
        input: '4\n-1 -2 -3 -4\n-1 0 1 2',
        expected: '-1[null] -2[-1] -3[-2] -4[-3]',
      },
      {
        input: '0',
        expected: '',
      },
      {
        input: '3\n7 8 9\n-1 -1 -1',
        expected: '7[null] 8[null] 9[null]',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you design a deep clone function for a linked list where each node can point randomly to any other node? Bonus points for doing it with O(1) extra space.',
    difficulty: 'medium',
    frequency: 87,
    tags: [
      'linked list',
      'hashmap',
      'deep copy',
      'interleaving',
      'random pointer',
    ],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use a map to store original -> clone mapping for O(n) space approach.',
      'For O(1) space: interleave copies in between original nodes.',
      'Separate the original and copied lists in a second pass.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class Node {\n  constructor(val, next = null, random = null) {\n    this.val = val;\n    this.next = next;\n    this.random = random;\n  }\n}\n\nfunction buildRandomList(values, randomIndices) {\n  const nodes = values.map(v => new Node(v));\n  for (let i = 0; i < nodes.length - 1; i++) nodes[i].next = nodes[i + 1];\n  for (let i = 0; i < nodes.length; i++)\n    nodes[i].random = randomIndices[i] === -1 ? null : nodes[randomIndices[i]];\n  return nodes[0] || null;\n}\n\nfunction printRandomList(head) {\n  const out = [];\n  while (head) {\n    out.push(`${head.val}[${head.random ? head.random.val : "null"}]`);\n    head = head.next;\n  }\n  console.log(out.join(" "));\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  if (!input.length || input[0] === "0") return;\n  const n = parseInt(input[0]);\n  const values = input[1].split(" ").map(Number);\n  const randomIndices = input[2].split(" ").map(Number);\n  const head = buildRandomList(values, randomIndices);\n  const cloned = cloneRandomList(head);\n  printRandomList(cloned);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class Node:\n    def __init__(self, val, next=None, random=None):\n        self.val = val\n        self.next = next\n        self.random = random\n\ndef build_random_list(values, random_indices):\n    nodes = [Node(val) for val in values]\n    for i in range(len(nodes) - 1):\n        nodes[i].next = nodes[i+1]\n    for i, idx in enumerate(random_indices):\n        if idx != -1:\n            nodes[i].random = nodes[idx]\n    return nodes[0] if nodes else None\n\ndef print_random_list(head):\n    result = []\n    while head:\n        r = head.random.val if head.random else \'null\'\n        result.append(f"{head.val}[{r}]")\n        head = head.next\n    print(" ".join(result))\n\nif __name__ == "__main__":\n    import sys\n    lines = sys.stdin.read().strip().split("\\n")\n    if not lines or lines[0] == "0":\n        exit()\n    n = int(lines[0])\n    values = list(map(int, lines[1].split()))\n    random_indices = list(map(int, lines[2].split()))\n    head = build_random_list(values, random_indices)\n    cloned = cloneRandomList(head)\n    print_random_list(cloned)',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class Node {\n  constructor(val, next = null, random = null) {\n    this.val = val;\n    this.next = next;\n    this.random = random;\n  }\n}\n\nfunction cloneRandomList(head) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class Node:\n    def __init__(self, val, next=None, random=None):\n        self.val = val\n        self.next = next\n        self.random = random\n\ndef cloneRandomList(head):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Clone Linked List with Next and Random Pointers',
    slug: 'clone-linked-list-random-pointer',
    description:
      'Clone a linked list where each node has both next and random pointers using HashMap or O(1) space interleaving method.',
    problemStatement:
      "You are given a singly linked list where each node has:\n<ul><li><code>val</code>: the node's integer value</li><li><code>next</code>: the next pointer</li><li><code>random</code>: a random pointer to any node in the list (or null)</li></ul>\n\nImplement a function to deep clone the list. Your cloned list must contain all the original <code>next</code> and <code>random</code> relationships.\n\nYou must implement the function using either:\n<ul>\n<li>A HashMap to map original nodes to copied ones (O(n) space), or</li>\n<li>An interleaving in-place approach (O(1) extra space)</li>\n</ul>\n\n<pre><code>Input:\nNodes: [1, 2, 3]\nRandom: [-1, 0, 1]\n\nOutput:\n1[null] -> 2[1] -> 3[2]</code></pre>\n\nExplanation:\nRandom[i] gives the index (0-based) of the node that node i's random pointer should point to (or -1 for null).\n\n<ul>\n<li>0 ≤ number of nodes ≤ 1000</li>\n<li>Values of nodes range between -10⁴ and 10⁴</li>\n<li>Output should be a deep copy (new node references)</li>\n</ul>\n\nPro Tip: To achieve O(1) space, consider interleaving cloned nodes between original nodes, assigning randoms, then detaching the copy.",
    sampleTestCases: [
      {
        input: '3\n1 2 3\n-1 0 1',
        expected: '1[null] 2[1] 3[2]',
      },
      {
        input: '2\n10 20\n1 0',
        expected: '10[20] 20[10]',
      },
    ],
    testCases: [
      {
        input: '1\n99\n-1',
        expected: '99[null]',
      },
      {
        input: '2\n1 2\n-1 -1',
        expected: '1[null] 2[null]',
      },
      {
        input: '3\n1 2 3\n2 1 0',
        expected: '1[3] 2[2] 3[1]',
      },
      {
        input: '4\n5 6 7 8\n3 2 1 0',
        expected: '5[8] 6[7] 7[6] 8[5]',
      },
      {
        input: '3\n10 20 30\n1 1 0',
        expected: '10[20] 20[20] 30[10]',
      },
      {
        input: '2\n0 0\n1 0',
        expected: '0[0] 0[0]',
      },
      {
        input: '3\n3 2 1\n0 1 2',
        expected: '3[3] 2[2] 1[1]',
      },
      {
        input: '4\n-1 -2 -3 -4\n-1 0 1 2',
        expected: '-1[null] -2[-1] -3[-2] -4[-3]',
      },
      {
        input: '0',
        expected: '',
      },
      {
        input: '3\n7 8 9\n-1 -1 -1',
        expected: '7[null] 8[null] 9[null]',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you design a deep clone function for a linked list where each node can point randomly to any other node? Bonus points for doing it with O(1) extra space.',
    difficulty: 'medium',
    frequency: 87,
    tags: [
      'linked list',
      'hashmap',
      'deep copy',
      'interleaving',
      'random pointer',
    ],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use a map to store original -> clone mapping for O(n) space approach.',
      'For O(1) space: interleave copies in between original nodes.',
      'Separate the original and copied lists in a second pass.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class Node {\n  constructor(val, next = null, random = null) {\n    this.val = val;\n    this.next = next;\n    this.random = random;\n  }\n}\n\nfunction buildRandomList(values, randomIndices) {\n  const nodes = values.map(v => new Node(v));\n  for (let i = 0; i < nodes.length - 1; i++) nodes[i].next = nodes[i + 1];\n  for (let i = 0; i < nodes.length; i++)\n    nodes[i].random = randomIndices[i] === -1 ? null : nodes[randomIndices[i]];\n  return nodes[0] || null;\n}\n\nfunction printRandomList(head) {\n  const out = [];\n  while (head) {\n    out.push(`${head.val}[${head.random ? head.random.val : "null"}]`);\n    head = head.next;\n  }\n  console.log(out.join(" "));\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  if (!input.length || input[0] === "0") return;\n  const n = parseInt(input[0]);\n  const values = input[1].split(" ").map(Number);\n  const randomIndices = input[2].split(" ").map(Number);\n  const head = buildRandomList(values, randomIndices);\n  const cloned = cloneRandomList(head);\n  printRandomList(cloned);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class Node:\n    def __init__(self, val, next=None, random=None):\n        self.val = val\n        self.next = next\n        self.random = random\n\ndef build_random_list(values, random_indices):\n    nodes = [Node(val) for val in values]\n    for i in range(len(nodes) - 1):\n        nodes[i].next = nodes[i+1]\n    for i, idx in enumerate(random_indices):\n        if idx != -1:\n            nodes[i].random = nodes[idx]\n    return nodes[0] if nodes else None\n\ndef print_random_list(head):\n    result = []\n    while head:\n        r = head.random.val if head.random else \'null\'\n        result.append(f"{head.val}[{r}]")\n        head = head.next\n    print(" ".join(result))\n\nif __name__ == "__main__":\n    import sys\n    lines = sys.stdin.read().strip().split("\\n")\n    if not lines or lines[0] == "0":\n        exit()\n    n = int(lines[0])\n    values = list(map(int, lines[1].split()))\n    random_indices = list(map(int, lines[2].split()))\n    head = build_random_list(values, random_indices)\n    cloned = cloneRandomList(head)\n    print_random_list(cloned)',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class Node {\n  constructor(val, next = null, random = null) {\n    this.val = val;\n    this.next = next;\n    this.random = random;\n  }\n}\n\nfunction cloneRandomList(head) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class Node:\n    def __init__(self, val, next=None, random=None):\n        self.val = val\n        self.next = next\n        self.random = random\n\ndef cloneRandomList(head):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Delete N Nodes After M Nodes in Linked List',
    slug: 'delete-n-after-m-nodes-linked-list',
    description:
      'Delete N nodes in a singly linked list after skipping M nodes repeatedly until the end of the list.',
    problemStatement:
      'You are given the head of a singly linked list and two integers, <code>M</code> and <code>N</code>.\n\nTraverse the list and **skip M nodes**, then **delete the next N nodes**. Continue the same pattern until the end of the list. Return the head of the modified list.\n\n<pre><code>Input:\nList: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10\nM = 2, N = 3\nOutput:\n1 -> 2 -> 6 -> 7 -> 10</code></pre>\n\nExplanation:\n- Keep first 2 nodes (1, 2), delete next 3 nodes (3, 4, 5)\n- Keep next 2 nodes (6, 7), delete next 3 nodes (8, 9, 10)\n\n<ul>\n<li>1 ≤ number of nodes ≤ 10⁴</li>\n<li>0 ≤ M, N ≤ 10⁴</li>\n<li>If N = 0, no nodes are deleted</li>\n<li>If M = 0, delete every N nodes from the beginning</li>\n</ul>\n\nPro Tip: Use two nested loops—first to skip M nodes, then to delete N nodes—being cautious of edge cases and null references.',
    sampleTestCases: [
      {
        input: '10\n1 2 3 4 5 6 7 8 9 10\n2 3',
        expected: '1 2 6 7 10',
      },
      {
        input: '6\n1 2 3 4 5 6\n1 1',
        expected: '1 3 5',
      },
    ],
    testCases: [
      {
        input: '5\n1 2 3 4 5\n2 2',
        expected: '1 2 5',
      },
      {
        input: '7\n1 2 3 4 5 6 7\n1 0',
        expected: '1 2 3 4 5 6 7',
      },
      {
        input: '7\n1 2 3 4 5 6 7\n0 2',
        expected: '3 5 7',
      },
      {
        input: '4\n10 20 30 40\n3 2',
        expected: '10 20 30',
      },
      {
        input: '5\n1 2 3 4 5\n0 5',
        expected: '',
      },
      {
        input: '8\n1 2 3 4 5 6 7 8\n2 10',
        expected: '1 2',
      },
      {
        input: '3\n1 2 3\n0 1',
        expected: '2 3',
      },
      {
        input: '3\n1 2 3\n1 3',
        expected: '1',
      },
      {
        input: '6\n9 8 7 6 5 4\n1 2',
        expected: '9 6',
      },
      {
        input: '1\n99\n1 0',
        expected: '99',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re writing a memory cleaning utility that selectively deletes every N records after scanning M records in a data stream. Implement this logic for linked records.',
    difficulty: 'easy',
    frequency: 78,
    tags: ['linked list', 'deletion', 'iteration'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'PayPal', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Use two loops—first to skip M nodes, then to delete N nodes.',
      'Always check for null before advancing.',
      'Edge cases: M or N being 0 need special handling.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  const dummy = new ListNode();\n  let curr = dummy;\n  for (let v of arr) {\n    curr.next = new ListNode(v);\n    curr = curr.next;\n  }\n  return dummy.next;\n}\n\nfunction printList(head) {\n  const res = [];\n  while (head) {\n    res.push(head.val);\n    head = head.next;\n  }\n  console.log(res.join(" "));\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = input[1].split(" ").map(Number);\n  const [m, d] = input[2].split(" ").map(Number);\n  const head = buildLinkedList(arr);\n  const result = deleteNodesAfterM(head, m, d);\n  printList(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_linked_list(arr):\n    dummy = ListNode()\n    curr = dummy\n    for v in arr:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next\n\ndef print_list(head):\n    res = []\n    while head:\n        res.append(str(head.val))\n        head = head.next\n    print(" ".join(res))\n\nif __name__ == "__main__":\n    import sys\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    arr = list(map(int, lines[1].split()))\n    m, d = map(int, lines[2].split())\n    head = build_linked_list(arr)\n    result = deleteNodesAfterM(head, m, d)\n    print_list(result)',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction deleteNodesAfterM(head, m, n) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef deleteNodesAfterM(head, m, n):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Delete N Nodes After M Nodes in Linked List',
    slug: 'delete-n-after-m-nodes-linked-list',
    description:
      'Delete N nodes in a singly linked list after skipping M nodes repeatedly until the end of the list.',
    problemStatement:
      'You are given the head of a singly linked list and two integers, <code>M</code> and <code>N</code>.\n\nTraverse the list and **skip M nodes**, then **delete the next N nodes**. Continue the same pattern until the end of the list. Return the head of the modified list.\n\n<pre><code>Input:\nList: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10\nM = 2, N = 3\nOutput:\n1 -> 2 -> 6 -> 7 -> 10</code></pre>\n\nExplanation:\n- Keep first 2 nodes (1, 2), delete next 3 nodes (3, 4, 5)\n- Keep next 2 nodes (6, 7), delete next 3 nodes (8, 9, 10)\n\n<ul>\n<li>1 ≤ number of nodes ≤ 10⁴</li>\n<li>0 ≤ M, N ≤ 10⁴</li>\n<li>If N = 0, no nodes are deleted</li>\n<li>If M = 0, delete every N nodes from the beginning</li>\n</ul>\n\nPro Tip: Use two nested loops—first to skip M nodes, then to delete N nodes—being cautious of edge cases and null references.',
    sampleTestCases: [
      {
        input: '10\n1 2 3 4 5 6 7 8 9 10\n2 3',
        expected: '1 2 6 7 10',
      },
      {
        input: '6\n1 2 3 4 5 6\n1 1',
        expected: '1 3 5',
      },
    ],
    testCases: [
      {
        input: '5\n1 2 3 4 5\n2 2',
        expected: '1 2 5',
      },
      {
        input: '7\n1 2 3 4 5 6 7\n1 0',
        expected: '1 2 3 4 5 6 7',
      },
      {
        input: '7\n1 2 3 4 5 6 7\n0 2',
        expected: '3 5 7',
      },
      {
        input: '4\n10 20 30 40\n3 2',
        expected: '10 20 30',
      },
      {
        input: '5\n1 2 3 4 5\n0 5',
        expected: '',
      },
      {
        input: '8\n1 2 3 4 5 6 7 8\n2 10',
        expected: '1 2',
      },
      {
        input: '3\n1 2 3\n0 1',
        expected: '2 3',
      },
      {
        input: '3\n1 2 3\n1 3',
        expected: '1',
      },
      {
        input: '6\n9 8 7 6 5 4\n1 2',
        expected: '9 6',
      },
      {
        input: '1\n99\n1 0',
        expected: '99',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re writing a memory cleaning utility that selectively deletes every N records after scanning M records in a data stream. Implement this logic for linked records.',
    difficulty: 'easy',
    frequency: 78,
    tags: ['linked list', 'deletion', 'iteration'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'PayPal', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Use two loops—first to skip M nodes, then to delete N nodes.',
      'Always check for null before advancing.',
      'Edge cases: M or N being 0 need special handling.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  const dummy = new ListNode();\n  let curr = dummy;\n  for (let v of arr) {\n    curr.next = new ListNode(v);\n    curr = curr.next;\n  }\n  return dummy.next;\n}\n\nfunction printList(head) {\n  const res = [];\n  while (head) {\n    res.push(head.val);\n    head = head.next;\n  }\n  console.log(res.join(" "));\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = input[1].split(" ").map(Number);\n  const [m, d] = input[2].split(" ").map(Number);\n  const head = buildLinkedList(arr);\n  const result = deleteNodesAfterM(head, m, d);\n  printList(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_linked_list(arr):\n    dummy = ListNode()\n    curr = dummy\n    for v in arr:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next\n\ndef print_list(head):\n    res = []\n    while head:\n        res.append(str(head.val))\n        head = head.next\n    print(" ".join(res))\n\nif __name__ == "__main__":\n    import sys\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    arr = list(map(int, lines[1].split()))\n    m, d = map(int, lines[2].split())\n    head = build_linked_list(arr)\n    result = deleteNodesAfterM(head, m, d)\n    print_list(result)',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction deleteNodesAfterM(head, m, n) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef deleteNodesAfterM(head, m, n):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Delete Middle Node of Linked List',
    slug: 'delete-middle-node-linked-list',
    description:
      'Delete the middle node of a singly linked list and return the head of the updated list.',
    problemStatement:
      "You are given the head of a singly linked list. Your task is to delete the **middle node** of the list and return the head of the updated list.\n\nThe middle node is the ⌊n / 2⌋-th node (0-indexed). If there are multiple middle nodes (even length), delete the second one.\n\n<pre><code>Input: 1 -> 3 -> 4 -> 7 -> 1 -> 2 -> 6\nOutput: 1 -> 3 -> 4 -> 1 -> 2 -> 6\n\nInput: 1 -> 2 -> 3 -> 4\nOutput: 1 -> 2 -> 4</code></pre>\n\nExplanation:\n- In the first case, the 7 is the middle node (index 3 of 7), so it's removed.\n- In the second case, ⌊4 / 2⌋ = 2, so the node at index 2 (value 3) is removed.\n\n<ul>\n<li>1 ≤ number of nodes ≤ 10⁵</li>\n<li>Node values are integers and can be negative</li>\n<li>If list has only one node, return null</li>\n</ul>\n\nPro Tip: Use slow and fast pointer approach to find the middle node efficiently in one traversal.",
    sampleTestCases: [
      {
        input: '7\n1 3 4 7 1 2 6',
        expected: '1 3 4 1 2 6',
      },
      {
        input: '4\n1 2 3 4',
        expected: '1 2 4',
      },
    ],
    testCases: [
      {
        input: '1\n99',
        expected: '',
      },
      {
        input: '2\n1 2',
        expected: '1',
      },
      {
        input: '3\n1 2 3',
        expected: '1 3',
      },
      {
        input: '5\n10 20 30 40 50',
        expected: '10 20 40 50',
      },
      {
        input: '6\n1 3 5 7 9 11',
        expected: '1 3 5 9 11',
      },
      {
        input: '8\n8 7 6 5 4 3 2 1',
        expected: '8 7 6 5 3 2 1',
      },
      {
        input: '4\n-1 -2 -3 -4',
        expected: '-1 -2 -4',
      },
      {
        input: '5\n0 0 0 0 0',
        expected: '0 0 0 0',
      },
      {
        input: '3\n100 200 300',
        expected: '100 300',
      },
      {
        input: '6\n1 2 3 4 5 6',
        expected: '1 2 3 5 6',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Let’s say you're analyzing packets in a stream, and you need to remove the median-sized one quickly. How would you remove the middle node from a singly linked list efficiently?",
    difficulty: 'easy',
    frequency: 89,
    tags: ['linked list', 'slow fast pointer', 'deletion'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Use two pointers—slow moves by 1, fast moves by 2.',
      'Track the previous node of slow to unlink it when fast reaches the end.',
      'If list has only 1 node, return null.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  const dummy = new ListNode();\n  let curr = dummy;\n  for (let v of arr) {\n    curr.next = new ListNode(v);\n    curr = curr.next;\n  }\n  return dummy.next;\n}\n\nfunction printList(head) {\n  const res = [];\n  while (head) {\n    res.push(head.val);\n    head = head.next;\n  }\n  console.log(res.join(" "));\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = input[1].split(" ").map(Number);\n  const head = buildLinkedList(arr);\n  const result = deleteMiddle(head);\n  printList(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_linked_list(arr):\n    dummy = ListNode()\n    curr = dummy\n    for v in arr:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next\n\ndef print_list(head):\n    res = []\n    while head:\n        res.append(str(head.val))\n        head = head.next\n    print(" ".join(res))\n\nif __name__ == "__main__":\n    import sys\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    arr = list(map(int, lines[1].split()))\n    head = build_linked_list(arr)\n    result = deleteMiddle(head)\n    print_list(result)',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction deleteMiddle(head) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef deleteMiddle(head):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Remove Elements by Value from Linked List',
    slug: 'remove-elements-by-value-linked-list',
    description:
      'Remove all nodes from a singly linked list that contain a given target value.',
    problemStatement:
      'You are given the head of a singly linked list and an integer <code>val</code>. Remove all the nodes of the linked list that have <code>Node.val == val</code>, and return the new head.\n\nYou must do it in-place without creating a new list.\n\n<pre><code>Input:\nList: 1 -> 2 -> 6 -> 3 -> 4 -> 5 -> 6\nval = 6\nOutput:\n1 -> 2 -> 3 -> 4 -> 5</code></pre>\n\nExplanation:\nAll nodes with value 6 are removed.\n\n<ul>\n<li>1 ≤ number of nodes ≤ 10⁴</li>\n<li>Node values are integers from -10⁴ to 10⁴</li>\n<li>It is possible all nodes are deleted</li>\n</ul>\n\nPro Tip: Use a dummy node to simplify edge cases, especially when deletions happen at the head.',
    sampleTestCases: [
      {
        input: '7\n1 2 6 3 4 5 6\n6',
        expected: '1 2 3 4 5',
      },
      {
        input: '5\n7 7 7 7 7\n7',
        expected: '',
      },
    ],
    testCases: [
      {
        input: '1\n1\n1',
        expected: '',
      },
      {
        input: '2\n1 2\n2',
        expected: '1',
      },
      {
        input: '3\n1 2 3\n4',
        expected: '1 2 3',
      },
      {
        input: '4\n6 6 6 6\n6',
        expected: '',
      },
      {
        input: '6\n1 2 3 2 4 2\n2',
        expected: '1 3 4',
      },
      {
        input: '3\n10 20 30\n10',
        expected: '20 30',
      },
      {
        input: '3\n10 20 30\n30',
        expected: '10 20',
      },
      {
        input: '3\n10 20 30\n20',
        expected: '10 30',
      },
      {
        input: '0\n\n5',
        expected: '',
      },
      {
        input: '6\n1 1 2 2 3 3\n1',
        expected: '2 2 3 3',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're managing a data filtering pipeline. Can you implement a method that removes all records with a specific value from a stream represented as a linked list?",
    difficulty: 'easy',
    frequency: 91,
    tags: ['linked list', 'deletion', 'dummy node'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use a dummy node to handle edge cases where the head needs to be deleted.',
      'Keep track of the previous node to reconnect links after deletion.',
      'Continue traversing after each deletion.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  const dummy = new ListNode();\n  let curr = dummy;\n  for (let v of arr) {\n    curr.next = new ListNode(v);\n    curr = curr.next;\n  }\n  return dummy.next;\n}\n\nfunction printList(head) {\n  const res = [];\n  while (head) {\n    res.push(head.val);\n    head = head.next;\n  }\n  console.log(res.join(" "));\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const values = n ? input[1].split(" ").map(Number) : [];\n  const val = parseInt(input[n ? 2 : 1]);\n  const head = buildLinkedList(values);\n  const result = removeElements(head, val);\n  printList(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_linked_list(arr):\n    dummy = ListNode()\n    curr = dummy\n    for v in arr:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next\n\ndef print_list(head):\n    res = []\n    while head:\n        res.append(str(head.val))\n        head = head.next\n    print(" ".join(res))\n\nif __name__ == "__main__":\n    import sys\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    values = list(map(int, lines[1].split())) if n else []\n    val = int(lines[2] if n else lines[1])\n    head = build_linked_list(values)\n    result = removeElements(head, val)\n    print_list(result)',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction removeElements(head, val) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef removeElements(head, val):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Delete Node With Only Access to That Node',
    slug: 'delete-node-without-head',
    description:
      'Delete a node from a singly linked list when only that node is given, not the head.',
    problemStatement:
      "You are given a node that is guaranteed not to be the tail of a singly linked list. Your task is to delete this node, given only access to it—not the head of the list.\n\nYou must modify the linked list in-place.\n\n<pre><code>Input: 1 -> 2 -> 3 -> 4, delete node with value 3\nOutput: 1 -> 2 -> 4</code></pre>\n\nExplanation:\nInstead of deleting the node directly, you should copy the data from the next node into the current node, then delete the next node.\n\n<ul>\n<li>There will always be at least two nodes in the list</li>\n<li>The node to delete is not the last node</li>\n</ul>\n\nPro Tip: You can't change previous node’s next pointer, so simulate deletion by overwriting current node with next node’s value and bypassing it.",
    sampleTestCases: [
      {
        input: '4\n1 2 3 4\n2',
        expected: '1 2 4',
      },
      {
        input: '5\n10 20 30 40 50\n3',
        expected: '10 20 30 50',
      },
    ],
    testCases: [
      {
        input: '2\n1 2\n0',
        expected: '2',
      },
      {
        input: '3\n5 6 7\n1',
        expected: '5 7',
      },
      {
        input: '4\n9 8 7 6\n2',
        expected: '9 8 6',
      },
      {
        input: '5\n1 1 1 1 1\n1',
        expected: '1 1 1 1',
      },
      {
        input: '6\n0 2 4 6 8 10\n4',
        expected: '0 2 4 6 10',
      },
      {
        input: '3\n100 200 300\n1',
        expected: '100 300',
      },
      {
        input: '4\n1 3 5 7\n1',
        expected: '1 5 7',
      },
      {
        input: '4\n4 3 2 1\n2',
        expected: '4 3 1',
      },
      {
        input: '5\n9 7 5 3 1\n3',
        expected: '9 7 5 1',
      },
      {
        input: '3\n10 20 30\n0',
        expected: '20 30',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Let’s say you’re debugging in-place memory in a low-level system and you’re only handed a pointer to a node, not the list’s head. Can you simulate deleting that node?',
    difficulty: 'easy',
    frequency: 94,
    tags: ['linked list', 'in-place', 'overwrite', 'deletion'],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      "You can't change the previous node’s pointer, so update current node’s value and next pointer.",
      'Copy the value from the next node into the current one.',
      'Then remove the next node by changing pointers.',
    ],
    optimalComplexity: {
      time: 'O(1)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  const dummy = new ListNode();\n  let curr = dummy;\n  const nodeRefs = [];\n  for (let v of arr) {\n    curr.next = new ListNode(v);\n    curr = curr.next;\n    nodeRefs.push(curr);\n  }\n  return [dummy.next, nodeRefs];\n}\n\nfunction printList(head) {\n  const out = [];\n  while (head) {\n    out.push(head.val);\n    head = head.next;\n  }\n  console.log(out.join(" "));\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = input[1].split(" ").map(Number);\n  const index = parseInt(input[2]);\n  const [head, nodes] = buildLinkedList(arr);\n  deleteNode(nodes[index]);\n  printList(head);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_linked_list(arr):\n    dummy = ListNode()\n    curr = dummy\n    node_refs = []\n    for v in arr:\n        curr.next = ListNode(v)\n        curr = curr.next\n        node_refs.append(curr)\n    return dummy.next, node_refs\n\ndef print_list(head):\n    out = []\n    while head:\n        out.append(str(head.val))\n        head = head.next\n    print(" ".join(out))\n\nif __name__ == "__main__":\n    import sys\n    lines = sys.stdin.read().strip().split("\\n")\n    arr = list(map(int, lines[1].split()))\n    index = int(lines[2])\n    head, node_refs = build_linked_list(arr)\n    deleteNode(node_refs[index])\n    print_list(head)',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction deleteNode(node) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef deleteNode(node):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Remove Loop in Linked List Without Extra Space',
    slug: 'remove-loop-no-extra-space',
    description:
      'Detect and remove a loop from a linked list in-place using constant space.',
    problemStatement:
      "You are given the head of a singly linked list that may or may not contain a loop. If there is a loop (i.e., a node's next pointer points back to an earlier node), remove the loop without using any extra space.\n\nAfter removal, the list should become a linear singly linked list.\n\n<pre><code>Input: 1 -> 2 -> 3 -> 4 -> 5 -> back to 3\nOutput: 1 -> 2 -> 3 -> 4 -> 5</code></pre>\n\nExplanation:\nA loop exists from node 5 back to node 3. After removal, the cycle is broken.\n\n<ul>\n<li>0 ≤ number of nodes ≤ 10⁴</li>\n<li>Node values are integers</li>\n<li>The list may or may not contain a loop</li>\n<li>Return the head of the updated list (loop removed if present)</li>\n</ul>\n\nPro Tip: Use Floyd's Cycle Detection (Tortoise & Hare) to find the loop, then locate the node where the loop starts to unlink it.",
    sampleTestCases: [
      {
        input: '6\n1 2 3 4 5 6\n2',
        expected: '1 2 3 4 5 6',
      },
      {
        input: '5\n10 20 30 40 50\n0',
        expected: '10 20 30 40 50',
      },
    ],
    testCases: [
      {
        input: '0\n\n-1',
        expected: '',
      },
      {
        input: '1\n99\n-1',
        expected: '99',
      },
      {
        input: '2\n1 2\n-1',
        expected: '1 2',
      },
      {
        input: '3\n1 2 3\n1',
        expected: '1 2 3',
      },
      {
        input: '4\n5 10 15 20\n2',
        expected: '5 10 15 20',
      },
      {
        input: '6\n7 8 9 10 11 12\n3',
        expected: '7 8 9 10 11 12',
      },
      {
        input: '5\n1 2 3 4 5\n4',
        expected: '1 2 3 4 5',
      },
      {
        input: '3\n1 2 3\n0',
        expected: '1 2 3',
      },
      {
        input: '4\n100 200 300 400\n1',
        expected: '100 200 300 400',
      },
      {
        input: '5\n1 2 3 4 5\n-1',
        expected: '1 2 3 4 5',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're working with a linked data structure that must remain acyclic for integrity. Can you detect and break any loop in the list without using extra memory?",
    difficulty: 'medium',
    frequency: 82,
    tags: ['linked list', "floyd's cycle", 'two pointer', 'in-place'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use two pointers moving at different speeds to detect the loop.',
      'Once detected, reset one pointer to head and move both one step until they meet at the loop start.',
      'To remove the loop, traverse till the node before the start node and set its next to null.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLoopedList(values, pos) {\n  const dummy = new ListNode();\n  let curr = dummy, loopStart = null;\n  const nodes = [];\n  for (let i = 0; i < values.length; i++) {\n    curr.next = new ListNode(values[i]);\n    curr = curr.next;\n    nodes.push(curr);\n    if (i === pos) loopStart = curr;\n  }\n  if (pos >= 0 && pos < values.length) curr.next = loopStart;\n  return dummy.next;\n}\n\nfunction printList(head) {\n  const visited = new Set();\n  const out = [];\n  while (head && !visited.has(head)) {\n    out.push(head.val);\n    visited.add(head);\n    head = head.next;\n  }\n  console.log(out.join(" "));\n}\n\nconst fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = n ? input[1].split(" ").map(Number) : [];\n  const pos = parseInt(input[n ? 2 : 1]);\n  const head = buildLoopedList(arr, pos);\n  const result = removeLoop(head);\n  printList(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_looped_list(values, pos):\n    dummy = ListNode()\n    curr = dummy\n    nodes = []\n    for i, v in enumerate(values):\n        curr.next = ListNode(v)\n        curr = curr.next\n        nodes.append(curr)\n    if pos != -1:\n        curr.next = nodes[pos]\n    return dummy.next\n\ndef print_list(head):\n    visited = set()\n    out = []\n    while head and head not in visited:\n        out.append(str(head.val))\n        visited.add(head)\n        head = head.next\n    print(" ".join(out))\n\nif __name__ == "__main__":\n    import sys\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    values = list(map(int, lines[1].split())) if n else []\n    pos = int(lines[2] if n else lines[1])\n    head = build_looped_list(values, pos)\n    result = removeLoop(head)\n    print_list(result)',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction removeLoop(head) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef removeLoop(head):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Intersection of Two Sorted Linked Lists',
    slug: 'intersection-sorted-linked-lists',
    description:
      'Return the intersection of two sorted singly linked lists as a new sorted list.',
    problemStatement:
      'You are given the heads of two **sorted singly linked lists**. Your task is to return a new linked list that represents the intersection of the two lists.\n\nOnly elements that appear in **both** lists should be included in the result, and they should be in sorted order. Do not modify the input lists.\n\n<pre><code>Input:\nList1: 1 -> 2 -> 3 -> 4 -> 6\nList2: 2 -> 4 -> 6 -> 8\nOutput:\n2 -> 4 -> 6</code></pre>\n\nExplanation:\nOnly common elements from both sorted lists are added to the new list.\n\n<ul>\n<li>0 ≤ number of nodes in each list ≤ 10⁴</li>\n<li>List values are integers, may include duplicates</li>\n<li>The result list should not have duplicates</li>\n</ul>\n\nPro Tip: Use a two-pointer approach to efficiently compare both sorted lists and build the result list.',
    sampleTestCases: [
      {
        input: '5\n1 2 3 4 6\n4\n2 4 6 8',
        expected: '2 4 6',
      },
      {
        input: '3\n10 20 30\n3\n5 10 20',
        expected: '10 20',
      },
    ],
    testCases: [
      {
        input: '0\n\n0\n\n',
        expected: '',
      },
      {
        input: '1\n1\n1\n1',
        expected: '1',
      },
      {
        input: '3\n1 2 3\n3\n4 5 6',
        expected: '',
      },
      {
        input: '4\n1 2 2 3\n4\n2 2 3 4',
        expected: '2 3',
      },
      {
        input: '3\n1 2 3\n4\n2 3 4 5',
        expected: '2 3',
      },
      {
        input: '5\n5 10 15 20 25\n3\n10 15 30',
        expected: '10 15',
      },
      {
        input: '6\n1 3 5 7 9 11\n5\n2 3 6 9 12',
        expected: '3 9',
      },
      {
        input: '2\n1 1\n2\n1 1',
        expected: '1',
      },
      {
        input: '4\n1 2 3 4\n4\n1 2 3 4',
        expected: '1 2 3 4',
      },
      {
        input: '3\n7 8 9\n3\n5 6 7',
        expected: '7',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Given two sorted data streams in a monitoring system, extract only the overlapping values without altering the original inputs.',
    difficulty: 'easy',
    frequency: 84,
    tags: ['linked list', 'two pointer', 'sorted', 'intersection'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use two pointers to iterate through both lists.',
      'Only add values that are equal and not already added.',
      'Advance the pointer(s) based on comparison.',
    ],
    optimalComplexity: {
      time: 'O(n + m)',
      space: 'O(n + m)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  const dummy = new ListNode();\n  let curr = dummy;\n  for (let val of arr) {\n    curr.next = new ListNode(val);\n    curr = curr.next;\n  }\n  return dummy.next;\n}\n\nfunction printList(head) {\n  const res = [];\n  while (head) {\n    res.push(head.val);\n    head = head.next;\n  }\n  console.log(res.join(" "));\n}\n\nconst fs = require("fs");\nfunction main() {\n  const lines = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(lines[0]);\n  const list1 = n ? lines[1].split(" ").map(Number) : [];\n  const m = parseInt(lines[n ? 2 : 1]);\n  const list2 = m ? lines[n ? 3 : 2].split(" ").map(Number) : [];\n  const head1 = buildLinkedList(list1);\n  const head2 = buildLinkedList(list2);\n  const result = intersectionSortedLists(head1, head2);\n  printList(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_linked_list(arr):\n    dummy = ListNode()\n    curr = dummy\n    for v in arr:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next\n\ndef print_list(head):\n    res = []\n    while head:\n        res.append(str(head.val))\n        head = head.next\n    print(" ".join(res))\n\nif __name__ == "__main__":\n    import sys\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    arr1 = list(map(int, lines[1].split())) if n else []\n    m = int(lines[2 if n else 1])\n    arr2 = list(map(int, lines[3 if n else 2].split())) if m else []\n    head1 = build_linked_list(arr1)\n    head2 = build_linked_list(arr2)\n    result = intersectionSortedLists(head1, head2)\n    print_list(result)',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction intersectionSortedLists(head1, head2) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef intersectionSortedLists(head1, head2):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Add 1 to Number Represented by Linked List',
    slug: 'add-one-to-linked-list-number',
    description:
      'Increment a non-negative integer represented as a singly linked list by 1.',
    problemStatement:
      "You are given a singly linked list where each node contains a single digit (0–9), representing a non-negative integer in big-endian format (most significant digit at the head).\n\nWrite a function to add 1 to this number and return the head of the resulting linked list.\n\n<pre><code>Input: 1 -> 2 -> 3\nOutput: 1 -> 2 -> 4\n\nInput: 9 -> 9 -> 9\nOutput: 1 -> 0 -> 0 -> 0</code></pre>\n\nExplanation:\nIn the first case, 123 + 1 = 124. In the second case, 999 + 1 = 1000, so a new digit is added at the head.\n\n<ul>\n<li>1 ≤ number of nodes ≤ 10⁴</li>\n<li>Each node's value is in [0, 9]</li>\n<li>Leading zeros are not allowed in input; output should also have no leading zeros</li>\n</ul>\n\nPro Tip: Reverse the list to make addition easier, then reverse it back. Alternatively, use recursion to propagate carry from the end.",
    sampleTestCases: [
      {
        input: '3\n1 2 3',
        expected: '1 2 4',
      },
      {
        input: '3\n9 9 9',
        expected: '1 0 0 0',
      },
    ],
    testCases: [
      {
        input: '1\n9',
        expected: '1 0',
      },
      {
        input: '2\n4 9',
        expected: '5 0',
      },
      {
        input: '3\n0 0 9',
        expected: '0 1 0',
      },
      {
        input: '3\n2 3 9',
        expected: '2 4 0',
      },
      {
        input: '4\n1 9 9 9',
        expected: '2 0 0 0',
      },
      {
        input: '5\n1 2 3 4 5',
        expected: '1 2 3 4 6',
      },
      {
        input: '2\n1 0',
        expected: '1 1',
      },
      {
        input: '3\n3 0 0',
        expected: '3 0 1',
      },
      {
        input: '1\n0',
        expected: '1',
      },
      {
        input: '4\n9 9 0 9',
        expected: '9 9 1 0',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're modeling counters in a hardware register, and the digits are stored as linked lists. Can you write an efficient routine to increment them?",
    difficulty: 'easy',
    frequency: 88,
    tags: ['linked list', 'recursion', 'carry', 'addition'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Reverse the list to add from least significant digit.',
      'Or use recursion to reach the end and propagate carry back.',
      'Watch for carry at the most significant digit.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  const dummy = new ListNode();\n  let curr = dummy;\n  for (let val of arr) {\n    curr.next = new ListNode(val);\n    curr = curr.next;\n  }\n  return dummy.next;\n}\n\nfunction printList(head) {\n  const res = [];\n  while (head) {\n    res.push(head.val);\n    head = head.next;\n  }\n  console.log(res.join(" "));\n}\n\nconst fs = require("fs");\nfunction main() {\n  const lines = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(lines[0]);\n  const arr = lines[1].split(" ").map(Number);\n  const head = buildLinkedList(arr);\n  const result = addOne(head);\n  printList(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_linked_list(arr):\n    dummy = ListNode()\n    curr = dummy\n    for v in arr:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next\n\ndef print_list(head):\n    out = []\n    while head:\n        out.append(str(head.val))\n        head = head.next\n    print(" ".join(out))\n\nif __name__ == "__main__":\n    import sys\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    arr = list(map(int, lines[1].split()))\n    head = build_linked_list(arr)\n    result = addOne(head)\n    print_list(result)',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction addOne(head) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef addOne(head):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Subtract Two Linked Lists',
    slug: 'subtract-two-linked-lists',
    description:
      'Subtract the second linked list from the first where each list represents a non-negative integer.',
    problemStatement:
      "You are given the heads of two singly linked lists <code>l1</code> and <code>l2</code>, representing two non-negative integers in big-endian format (most significant digit comes first).\n\nYour task is to subtract the second number (l2) from the first (l1) and return the result as a linked list. You may assume that l1 ≥ l2 and no leading zeros are allowed in either input or output unless the result is 0.\n\n<pre><code>Input:\nList1: 1 -> 0 -> 0 -> 0\nList2: 1\nOutput:\n9 -> 9 -> 9</code></pre>\n\nExplanation:\n1000 - 1 = 999\n\n<ul>\n<li>1 ≤ number of nodes in each list ≤ 10⁴</li>\n<li>Each node's value is in [0, 9]</li>\n<li>l1 always represents a number greater than or equal to l2</li>\n<li>Result must not contain leading zeros unless it's zero</li>\n</ul>\n\nPro Tip: Use recursion or reverse both lists to perform subtraction from least significant digit, then clean leading zeros in the result.",
    sampleTestCases: [
      {
        input: '4\n1 0 0 0\n1\n1',
        expected: '9 9 9',
      },
      {
        input: '3\n2 0 0\n2\n1 0',
        expected: '1 9 0',
      },
    ],
    testCases: [
      {
        input: '1\n1\n1\n1',
        expected: '0',
      },
      {
        input: '2\n2 0\n2\n1 9',
        expected: '0 1',
      },
      {
        input: '4\n1 0 0 0\n3\n9 9 9',
        expected: '0 0 1',
      },
      {
        input: '5\n9 0 0 0 0\n1\n1',
        expected: '8 9 9 9 9',
      },
      {
        input: '3\n5 0 0\n2\n4 9',
        expected: '0 1',
      },
      {
        input: '3\n3 0 0\n3\n3 0 0',
        expected: '0',
      },
      {
        input: '2\n1 0\n2\n0 1',
        expected: '0 9',
      },
      {
        input: '4\n1 0 0 0\n2\n2 0',
        expected: '9 7 9 8',
      },
      {
        input: '2\n9 9\n1\n9',
        expected: '9 0',
      },
      {
        input: '5\n1 0 0 0 0\n3\n1 0 0',
        expected: '9 9 0 0',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Let's say you're building a ledger system and need to calculate a difference between two big integers stored as linked lists. How would you subtract one list from another safely and correctly?",
    difficulty: 'medium',
    frequency: 76,
    tags: ['linked list', 'subtraction', 'reverse', 'recursion', 'borrowing'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'PayPal', logoUrl: '' },
    ],
    hints: [
      'Pad the shorter list with zeros in front to equalize lengths.',
      'Use recursion or reverse both lists to subtract from LSB.',
      'Clean leading zeros in the resulting list after subtraction.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction buildLinkedList(arr) {\n  const dummy = new ListNode();\n  let curr = dummy;\n  for (let v of arr) {\n    curr.next = new ListNode(v);\n    curr = curr.next;\n  }\n  return dummy.next;\n}\n\nfunction printList(head) {\n  const out = [];\n  while (head) {\n    out.push(head.val);\n    head = head.next;\n  }\n  while (out.length > 1 && out[0] === 0) out.shift();\n  console.log(out.join(" "));\n}\n\nconst fs = require("fs");\nfunction main() {\n  const lines = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(lines[0]);\n  const list1 = lines[1].split(" ").map(Number);\n  const m = parseInt(lines[2]);\n  const list2 = lines[3].split(" ").map(Number);\n  const head1 = buildLinkedList(list1);\n  const head2 = buildLinkedList(list2);\n  const result = subtractLinkedLists(head1, head2);\n  printList(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef build_linked_list(arr):\n    dummy = ListNode()\n    curr = dummy\n    for v in arr:\n        curr.next = ListNode(v)\n        curr = curr.next\n    return dummy.next\n\ndef print_list(head):\n    result = []\n    while head:\n        result.append(str(head.val))\n        head = head.next\n    while len(result) > 1 and result[0] == \'0\':\n        result.pop(0)\n    print(" ".join(result))\n\nif __name__ == "__main__":\n    import sys\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    list1 = list(map(int, lines[1].split()))\n    m = int(lines[2])\n    list2 = list(map(int, lines[3].split()))\n    head1 = build_linked_list(list1)\n    head2 = build_linked_list(list2)\n    result = subtractLinkedLists(head1, head2)\n    print_list(result)',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction subtractLinkedLists(l1, l2) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef subtractLinkedLists(l1, l2):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Multiply Two Numbers Represented by Linked Lists',
    slug: 'multiply-linked-list-numbers',
    description:
      'Multiply two non-negative integers represented as linked lists.',
    problemStatement:
      'You are given the heads of two singly linked lists, where each node contains a single digit (0–9). The digits are stored in **forward (big‑endian)** order, meaning the head contains the most significant digit. Multiply the two numbers and return the product as a linked list in the same format (no leading zeros, except for the number 0 itself).\n\n<pre><code>Input:\nL1: 9 -> 4 -> 6 (represents 946)\nL2: 8 -> 4 (represents 84)\nOutput:\n7 -> 9 -> 5 -> 0 -> 4 (represents 946 × 84 = 79504)\n\nInput:\nL1: 1 -> 0 -> 0 (represents 100)\nL2: 1 -> 0 (represents 10)\nOutput:\n1 -> 0 -> 0 -> 0 (represents 1000)</code></pre>\n\nExplanation:\nEach input list represents a number in forward order. Multiply the two values and return the result as a linked list in the same forward order.\n\n<ul>\n  <li>1 ≤ number of nodes in each list ≤ 10⁴</li>\n  <li>Node values are in [0, 9]</li>\n  <li>Input may represent zero (e.g., single node 0)</li>\n  <li>Result should not contain leading zeros unless the result is zero</li>\n</ul>\n\nPro Tip: You can implement the classical long‑multiplication algorithm by converting the lists into arrays of digits, performing digit‑by‑digit multiplication with carries, and then building the result list from that.\n',
    sampleTestCases: [
      {
        input: '3\n9 4 6\n2\n8 4',
        expected: '7 9 5 0 4',
      },
      {
        input: '3\n1 0 0\n2\n1 0',
        expected: '1 0 0 0',
      },
    ],
    testCases: [
      {
        input: '1\n0\n1\n0',
        expected: '0',
      },
      {
        input: '1\n5\n1\n4',
        expected: '2 0',
      },
      {
        input: '2\n1 2\n2\n3 4',
        expected: '4 0 8',
      },
      {
        input: '3\n9 9 9\n3\n9 9 9',
        expected: '9 9 8 0 0 1',
      },
      {
        input: '4\n1 2 3 4\n3\n5 6 7',
        expected: '7 0 0 6 8',
      },
      {
        input: '3\n0 1 2\n3\n0 3 4',
        expected: '4 0 8',
      },
      {
        input: '3\n1 0 0\n3\n0 0 1',
        expected: '1 0 0',
      },
      {
        input: '2\n2 0\n2\n0 5',
        expected: '1 0 0',
      },
      {
        input: '3\n1 2 3\n1\n0',
        expected: '0',
      },
      {
        input: '4\n2 5 0 0\n3\n2 0 0',
        expected: '5 0 0 0 0 0',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re designing a big-integer arithmetic module backed by linked‑list digit storage. How would you multiply two such numbers accurately, without overflow risk?',
    difficulty: 'medium',
    frequency: 70,
    tags: [
      'linked list',
      'big integer',
      'multiplication',
      'digit array',
      'long multiplication',
    ],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Convert both lists into arrays of digits (forward order).',
      'Use long multiplication: for each digit in one number, multiply every digit in the other and add to the correct result position with carry.',
      'Convert the final digit array back to a linked list, skipping leading zeros.',
    ],
    optimalComplexity: {
      time: 'O(m × n)',
      space: 'O(m + n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction multiplyLists(l1, l2) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef multiplyLists(l1, l2):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Print Numbers from 1 to N',
    slug: 'print-numbers-1-to-n',
    description: 'Generate and return a sequence of integers from 1 to N.',
    problemStatement:
      'Given a positive integer <code>n</code>, return a list of numbers from 1 to <code>n</code> inclusive.\n\nYou must return the sequence in order, separated by spaces.\n\n<pre><code>Input:\n5\nOutput:\n1 2 3 4 5</code></pre>\n\nExplanation:\nThis is a basic iterative generation of numbers from 1 to n.\n\n<ul>\n<li>1 ≤ n ≤ 10⁶</li>\n<li>Use O(1) auxiliary space if possible</li>\n</ul>\n\nPro Tip: This is a common warm-up exercise to verify loop logic and output formatting.',
    sampleTestCases: [
      {
        input: '5',
        expected: '1 2 3 4 5',
      },
      {
        input: '1',
        expected: '1',
      },
    ],
    testCases: [
      {
        input: '10',
        expected: '1 2 3 4 5 6 7 8 9 10',
      },
      {
        input: '3',
        expected: '1 2 3',
      },
      {
        input: '7',
        expected: '1 2 3 4 5 6 7',
      },
      {
        input: '15',
        expected: '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15',
      },
      {
        input: '2',
        expected: '1 2',
      },
      {
        input: '20',
        expected: '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20',
      },
      {
        input: '4',
        expected: '1 2 3 4',
      },
      {
        input: '9',
        expected: '1 2 3 4 5 6 7 8 9',
      },
      {
        input: '11',
        expected: '1 2 3 4 5 6 7 8 9 10 11',
      },
      {
        input: '6',
        expected: '1 2 3 4 5 6',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Let’s warm up with a simple loop. Can you write a function that prints numbers from 1 to N?',
    difficulty: 'easy',
    frequency: 98,
    tags: ['loop', 'iteration', 'basic'],
    companies: [
      { name: 'TCS', logoUrl: '' },
      { name: 'Infosys', logoUrl: '' },
    ],
    hints: [
      'Use a loop from 1 to n.',
      'Collect results in an array or string, then output them.',
      'Be careful with spacing between numbers.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const n = parseInt(fs.readFileSync(0, "utf-8"));\n  const result = printNumbers(n);\n  console.log(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    print(printNumbers(n))',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function printNumbers(n) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def printNumbers(n):\n    # write code here\n    pass',
      },
    ],
  },
  {
    title: 'Print Numbers from 1 to N',
    slug: 'print-numbers-1-to-n',
    description: 'Generate and return a sequence of integers from 1 to N.',
    problemStatement:
      'Given a positive integer <code>n</code>, return a list of numbers from 1 to <code>n</code> inclusive.\n\nYou must return the sequence in order, separated by spaces.\n\n<pre><code>Input:\n5\nOutput:\n1 2 3 4 5</code></pre>\n\nExplanation:\nThis is a basic iterative generation of numbers from 1 to n.\n\n<ul>\n<li>1 ≤ n ≤ 10⁶</li>\n<li>Use O(1) auxiliary space if possible</li>\n</ul>\n\nPro Tip: This is a common warm-up exercise to verify loop logic and output formatting.',
    sampleTestCases: [
      {
        input: '5',
        expected: '1 2 3 4 5',
      },
      {
        input: '1',
        expected: '1',
      },
    ],
    testCases: [
      { input: '10', expected: '1 2 3 4 5 6 7 8 9 10' },
      { input: '3', expected: '1 2 3' },
      { input: '7', expected: '1 2 3 4 5 6 7' },
      { input: '15', expected: '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15' },
      { input: '2', expected: '1 2' },
      {
        input: '20',
        expected: '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20',
      },
      { input: '4', expected: '1 2 3 4' },
      { input: '9', expected: '1 2 3 4 5 6 7 8 9' },
      { input: '11', expected: '1 2 3 4 5 6 7 8 9 10 11' },
      { input: '6', expected: '1 2 3 4 5 6' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Let’s warm up with a simple loop. Can you write a function that prints numbers from 1 to N?',
    difficulty: 'easy',
    frequency: 98,
    tags: ['loop', 'iteration', 'basic'],
    companies: [
      { name: 'TCS', logoUrl: '' },
      { name: 'Infosys', logoUrl: '' },
    ],
    hints: [
      'Use a loop from 1 to n.',
      'Collect results in an array or string, then output them.',
      'Be careful with spacing between numbers.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const n = parseInt(fs.readFileSync(0, "utf-8"));\n  const result = printNumbers(n);\n  console.log(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    print(printNumbers(n))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        System.out.println(printNumbers(n));\n    }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n    int n;\n    scanf("%d", &n);\n    printNumbers(n);\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint main() {\n    int n;\n    cin >> n;\n    cout << printNumbers(n) << endl;\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function printNumbers(n) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def printNumbers(n):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static String printNumbers(int n) {\n    // write code here\n    return "";\n}',
      },
      {
        language: 'c',
        code: 'void printNumbers(int n) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'string printNumbers(int n) {\n    // write code here\n    return "";\n}',
      },
    ],
  },
  {
    title: 'Print Numbers from N to 1',
    slug: 'print-numbers-n-to-1',
    description:
      'Generate and return a sequence of integers from N to 1 in descending order.',
    problemStatement:
      'Given a positive integer <code>n</code>, return a list of numbers from <code>n</code> to 1 inclusive.\n\nThe numbers should be returned in descending order, separated by spaces.\n\n<pre><code>Input:\n5\nOutput:\n5 4 3 2 1</code></pre>\n\nExplanation:\nThis is the reverse of printing numbers from 1 to n.\n\n<ul>\n<li>1 ≤ n ≤ 10⁶</li>\n<li>Use O(1) auxiliary space if possible</li>\n</ul>\n\nPro Tip: Try implementing this with both iterative and recursive approaches to practice both techniques.',
    sampleTestCases: [
      {
        input: '5',
        expected: '5 4 3 2 1',
      },
      {
        input: '1',
        expected: '1',
      },
    ],
    testCases: [
      { input: '10', expected: '10 9 8 7 6 5 4 3 2 1' },
      { input: '3', expected: '3 2 1' },
      { input: '7', expected: '7 6 5 4 3 2 1' },
      { input: '15', expected: '15 14 13 12 11 10 9 8 7 6 5 4 3 2 1' },
      { input: '2', expected: '2 1' },
      { input: '4', expected: '4 3 2 1' },
      { input: '6', expected: '6 5 4 3 2 1' },
      { input: '9', expected: '9 8 7 6 5 4 3 2 1' },
      { input: '12', expected: '12 11 10 9 8 7 6 5 4 3 2 1' },
      { input: '8', expected: '8 7 6 5 4 3 2 1' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Warm-up: Can you print the first N natural numbers in reverse order?',
    difficulty: 'easy',
    frequency: 97,
    tags: ['loop', 'iteration', 'recursion', 'basic'],
    companies: [
      { name: 'Wipro', logoUrl: '' },
      { name: 'TCS', logoUrl: '' },
    ],
    hints: [
      'Use a loop or recursion that counts down from n to 1.',
      'Avoid unnecessary space usage or function stack overflows.',
      'Print or accumulate the result with space separation.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const n = parseInt(fs.readFileSync(0, "utf-8"));\n  const result = printNumbers(n);\n  console.log(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    print(printNumbers(n))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        System.out.println(printNumbers(n));\n    }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n    int n;\n    scanf("%d", &n);\n    printNumbers(n);\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint main() {\n    int n;\n    cin >> n;\n    cout << printNumbers(n) << endl;\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function printNumbers(n) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def printNumbers(n):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static String printNumbers(int n) {\n    // write code here\n    return "";\n}',
      },
      {
        language: 'c',
        code: 'void printNumbers(int n) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'string printNumbers(int n) {\n    // write code here\n    return "";\n}',
      },
    ],
  },
  {
    title: 'Factorial of a Number',
    slug: 'factorial-of-a-number',
    description: 'Compute the factorial of a given positive integer n.',
    problemStatement:
      'Given a positive integer <code>n</code>, return its factorial.\n\nThe factorial of a number n is defined as:\n<pre><code>n! = n × (n−1) × (n−2) × ... × 1</code></pre>\n\nYou should return the result as an integer if it fits in standard number types. Otherwise, return the result as a string to handle large values.\n\n<pre><code>Input: 5\nOutput: 120\n\nInput: 20\nOutput: 2432902008176640000</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 10⁴</li>\n<li>Use iterative or recursive approach as you prefer</li>\n<li>If number exceeds typical numeric limits, handle using big integer techniques</li>\n</ul>\n\nPro Tip: Factorial values grow very fast. Use `BigInt` or string-based multiplication for large values.',
    sampleTestCases: [
      { input: '5', expected: '120' },
      { input: '0', expected: '1' },
    ],
    testCases: [
      { input: '1', expected: '1' },
      { input: '2', expected: '2' },
      { input: '3', expected: '6' },
      { input: '10', expected: '3628800' },
      { input: '15', expected: '1307674368000' },
      { input: '20', expected: '2432902008176640000' },
      { input: '25', expected: '15511210043330985984000000' },
      { input: '30', expected: '265252859812191058636308480000000' },
      {
        input: '50',
        expected:
          '30414093201713378043612608166064768844377641568960512000000000000',
      },
      {
        input: '100',
        expected:
          '93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you write a function to calculate factorial of a number? Bonus: How would you handle large results?',
    difficulty: 'easy',
    frequency: 96,
    tags: ['math', 'recursion', 'iteration', 'bigint'],
    companies: [
      { name: 'TCS', logoUrl: '' },
      { name: 'Wipro', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use a loop or recursive function to calculate factorial.',
      'For very large values, use BigInt or string manipulation for multiplication.',
      'Remember factorial of 0 is 1.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1) or O(n) for recursion stack',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const n = parseInt(fs.readFileSync(0, "utf-8"));\n  const result = factorial(n);\n  console.log(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    print(factorial(n))',
      },
      {
        language: 'java',
        code: 'import java.math.BigInteger;\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        System.out.println(factorial(n));\n    }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n    int n;\n    scanf("%d", &n);\n    factorial(n);\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint main() {\n    int n;\n    cin >> n;\n    cout << factorial(n) << endl;\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function factorial(n) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def factorial(n):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static BigInteger factorial(int n) {\n    // write code here\n    return BigInteger.ONE;\n}',
      },
      {
        language: 'c',
        code: 'void factorial(int n) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: '#include <string>\nstring factorial(int n) {\n    // write code here\n    return "1";\n}',
      },
    ],
  },
  {
    title: 'Sum of First N Natural Numbers',
    slug: 'sum-of-first-n-natural-numbers',
    description: 'Compute the sum of the first N natural numbers.',
    problemStatement:
      'Given a positive integer <code>n</code>, return the sum of the first <code>n</code> natural numbers.\n\nThe formula for the sum is:\n<pre><code>sum = n × (n + 1) / 2</code></pre>\n\nReturn the result as an integer.\n\n<pre><code>Input: 5\nOutput: 15\n\nInput: 10\nOutput: 55</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 10⁹</li>\n<li>Use integer arithmetic (avoid floating point errors)</li>\n<li>Should work in O(1) time and constant space</li>\n</ul>\n\nPro Tip: Prefer the mathematical formula over a loop for better performance and accuracy.',
    sampleTestCases: [
      { input: '5', expected: '15' },
      { input: '1', expected: '1' },
    ],
    testCases: [
      { input: '10', expected: '55' },
      { input: '2', expected: '3' },
      { input: '100', expected: '5050' },
      { input: '20', expected: '210' },
      { input: '50', expected: '1275' },
      { input: '1000', expected: '500500' },
      { input: '999999', expected: '499999500000' },
      { input: '1234567', expected: '762078245628' },
      { input: '1000000000', expected: '500000000500000000' },
      { input: '3', expected: '6' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Warm-up: Can you find the sum of the first N natural numbers efficiently?',
    difficulty: 'easy',
    frequency: 99,
    tags: ['math', 'formula', 'arithmetic'],
    companies: [
      { name: 'Infosys', logoUrl: '' },
      { name: 'TCS', logoUrl: '' },
      { name: 'Wipro', logoUrl: '' },
    ],
    hints: [
      'Use the mathematical formula: n * (n + 1) / 2.',
      'Be careful with data type limits on large n.',
      'Use long or BigInt if required.',
    ],
    optimalComplexity: {
      time: 'O(1)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const n = BigInt(fs.readFileSync(0, "utf-8"));\n  const result = sumFirstN(n);\n  console.log(result.toString());\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    print(sumFirstN(n))',
      },
      {
        language: 'java',
        code: 'import java.math.BigInteger;\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        BigInteger n = sc.nextBigInteger();\n        System.out.println(sumFirstN(n));\n    }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n    long long n;\n    scanf("%lld", &n);\n    printf("%lld\\n", sumFirstN(n));\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint main() {\n    long long n;\n    cin >> n;\n    cout << sumFirstN(n) << endl;\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function sumFirstN(n) {\n  // write code here using BigInt if needed\n}',
      },
      {
        language: 'python',
        code: 'def sumFirstN(n):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static BigInteger sumFirstN(BigInteger n) {\n    // write code here\n    return BigInteger.ZERO;\n}',
      },
      {
        language: 'c',
        code: 'long long sumFirstN(long long n) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'long long sumFirstN(long long n) {\n    // write code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Fibonacci Number',
    slug: 'fibonacci-number',
    description: 'Return the nth Fibonacci number using efficient computation.',
    problemStatement:
      'Given an integer <code>n</code>, return the nth Fibonacci number, where:\n<pre><code>F(0) = 0\nF(1) = 1\nF(n) = F(n−1) + F(n−2) for n > 1</code></pre>\n\nThe result should be returned as an integer. You must implement an efficient solution.\n\n<pre><code>Input: 5\nOutput: 5\n\nInput: 10\nOutput: 55</code></pre>\n\n<ul>\n<li>0 ≤ n ≤ 10⁵</li>\n<li>Use iterative DP or matrix exponentiation to ensure optimal performance</li>\n<li>Use modulo 10⁹+7 to avoid overflow for large results</li>\n</ul>\n\nPro Tip: Use a loop with two variables to achieve O(n) time and O(1) space. For even better performance, matrix exponentiation gives O(log n).',
    sampleTestCases: [
      { input: '5', expected: '5' },
      { input: '10', expected: '55' },
    ],
    testCases: [
      { input: '0', expected: '0' },
      { input: '1', expected: '1' },
      { input: '2', expected: '1' },
      { input: '3', expected: '2' },
      { input: '4', expected: '3' },
      { input: '7', expected: '13' },
      { input: '20', expected: '6765' },
      { input: '50', expected: '12586269025' },
      { input: '100', expected: '354224848179261915075' },
      { input: '500', expected: '139423224561697880139045716410000860509' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Classic interview favorite — can you compute the nth Fibonacci number efficiently?',
    difficulty: 'easy',
    frequency: 100,
    tags: ['dp', 'recursion', 'math', 'iteration'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'TCS', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Avoid recursion for large n due to stack overflow.',
      'Use modulo 10^9 + 7 to avoid overflow in languages with fixed integer size.',
      'Try the iterative approach for optimal performance.',
    ],
    optimalComplexity: {
      time: 'O(log n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const n = parseInt(fs.readFileSync(0, "utf-8"));\n  console.log(fibonacci(n));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    print(fibonacci(n))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        System.out.println(fibonacci(n));\n    }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n    int n;\n    scanf("%d", &n);\n    printf("%lld\\n", fibonacci(n));\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint main() {\n    int n;\n    cin >> n;\n    cout << fibonacci(n) << endl;\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function fibonacci(n) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def fibonacci(n):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static long fibonacci(int n) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'c',
        code: 'long long fibonacci(int n) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'long long fibonacci(int n) {\n    // write code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Check if a String is Palindrome',
    slug: 'check-if-string-is-palindrome',
    description: 'Determine whether a given string is a palindrome.',
    problemStatement:
      'Given a string <code>s</code>, return <code>true</code> if it is a palindrome, or <code>false</code> otherwise.\n\nA palindrome is a string that reads the same forward and backward.\n\n<pre><code>Input: "racecar"\nOutput: true\n\nInput: "hello"\nOutput: false</code></pre>\n\n<ul>\n<li>1 ≤ s.length ≤ 10⁵</li>\n<li>The string consists of lowercase English letters only</li>\n<li>Case-sensitive comparison</li>\n</ul>\n\nPro Tip: Try using two pointers — one from the start and one from the end of the string.',
    sampleTestCases: [
      { input: 'racecar', expected: 'true' },
      { input: 'hello', expected: 'false' },
    ],
    testCases: [
      { input: 'a', expected: 'true' },
      { input: 'abba', expected: 'true' },
      { input: 'abcd', expected: 'false' },
      { input: 'madam', expected: 'true' },
      { input: 'level', expected: 'true' },
      { input: 'palindrome', expected: 'false' },
      { input: 'noon', expected: 'true' },
      { input: 'deified', expected: 'true' },
      { input: 'rotator', expected: 'true' },
      { input: 'civic', expected: 'true' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Classic string check — can you efficiently determine if a string is a palindrome?',
    difficulty: 'easy',
    frequency: 98,
    tags: ['string', 'two pointer', 'palindrome'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'TCS', logoUrl: '' },
    ],
    hints: [
      'Compare characters from both ends of the string moving inward.',
      "If at any point they mismatch, it's not a palindrome.",
      'You can also reverse the string and compare.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const s = fs.readFileSync(0, "utf-8").trim();\n  console.log(isPalindrome(s));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    s = input().strip()\n    print(isPalindrome(s))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    System.out.println(isPalindrome(s));\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\n#include <string.h>\nint main() {\n  char s[100001];\n  scanf("%s", s);\n  printf("%s\\n", isPalindrome(s) ? "true" : "false");\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n  string s;\n  cin >> s;\n  cout << (isPalindrome(s) ? "true" : "false") << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function isPalindrome(s) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def isPalindrome(s):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static boolean isPalindrome(String s) {\n    // write code here\n    return false;\n}',
      },
      {
        language: 'c',
        code: 'int isPalindrome(char* s) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'bool isPalindrome(string s) {\n    // write code here\n    return false;\n}',
      },
    ],
  },
  {
    title: 'Reverse a String using Recursion',
    slug: 'reverse-string-using-recursion',
    description: 'Reverse the given string using a recursive approach.',
    problemStatement:
      'Given a string <code>s</code>, return its reverse using recursion only.\n\nYou are not allowed to use loops or in-built reverse functions.\n\n<pre><code>Input: "hello"\nOutput: "olleh"\n\nInput: "abcd"\nOutput: "dcba"</code></pre>\n\n<ul>\n<li>1 ≤ s.length ≤ 10⁵</li>\n<li>String consists of lowercase English letters only</li>\n<li>You must solve this using recursion</li>\n</ul>\n\nPro Tip: Think of how to break down the problem into reversing the rest of the string and appending the current character.',
    sampleTestCases: [
      { input: 'hello', expected: 'olleh' },
      { input: 'a', expected: 'a' },
    ],
    testCases: [
      { input: 'abcd', expected: 'dcba' },
      { input: 'racecar', expected: 'racecar' },
      { input: 'xyz', expected: 'zyx' },
      { input: 'palindrome', expected: 'emordnilap' },
      { input: 'openai', expected: 'ianepo' },
      { input: 'level', expected: 'level' },
      { input: 'testcase', expected: 'esactset' },
      { input: 'gpt', expected: 'tpg' },
      { input: 'recursion', expected: 'noisrucer' },
      { input: 'string', expected: 'gnirts' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you reverse a string recursively without using loops or inbuilt functions?',
    difficulty: 'easy',
    frequency: 93,
    tags: ['recursion', 'string'],
    companies: [
      { name: 'TCS', logoUrl: '' },
      { name: 'Wipro', logoUrl: '' },
      { name: 'Infosys', logoUrl: '' },
    ],
    hints: [
      'Base case: empty string or length 1.',
      'Recursive case: reverse(s[1:]) + s[0].',
      "Ensure string slicing doesn't cause performance issues.",
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const s = fs.readFileSync(0, "utf-8").trim();\n  console.log(reverseString(s));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    s = input().strip()\n    print(reverseString(s))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    System.out.println(reverseString(s));\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\n#include <string.h>\nint main() {\n  char s[100001];\n  scanf("%s", s);\n  reverseString(s);\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n  string s;\n  cin >> s;\n  cout << reverseString(s) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function reverseString(s) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def reverseString(s):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static String reverseString(String s) {\n    // write code here\n    return "";\n}',
      },
      {
        language: 'c',
        code: 'void reverseString(char* s) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'string reverseString(string s) {\n    // write code here\n    return "";\n}',
      },
    ],
  },
  {
    title: 'Power of a Number (x^n)',
    slug: 'power-of-a-number',
    description: 'Compute x raised to the power n efficiently.',
    problemStatement:
      'Given two numbers <code>x</code> and <code>n</code>, return <code>x<sup>n</sup></code>.\n\nYou must implement an efficient algorithm to compute this using recursion or iteration, especially for large n.\n\n<pre><code>Input: 2 10\nOutput: 1024\n\nInput: 3 0\nOutput: 1</code></pre>\n\n<ul>\n<li>0 ≤ x ≤ 10⁹</li>\n<li>0 ≤ n ≤ 10⁵</li>\n<li>Use integer arithmetic</li>\n<li>Return result modulo 10⁹+7 to prevent overflow</li>\n</ul>\n\nPro Tip: Use binary exponentiation (exponentiation by squaring) for optimal time complexity.',
    sampleTestCases: [
      { input: '2 10', expected: '1024' },
      { input: '3 0', expected: '1' },
    ],
    testCases: [
      { input: '5 3', expected: '125' },
      { input: '2 5', expected: '32' },
      { input: '1 100000', expected: '1' },
      { input: '9 4', expected: '6561' },
      { input: '10 6', expected: '1000000' },
      { input: '0 5', expected: '0' },
      { input: '123 1', expected: '123' },
      { input: '2 100000', expected: '607723520' },
      { input: '7 7', expected: '823543' },
      { input: '1000000000 100000', expected: '747081812' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re implementing a fast exponentiation function — how would you compute x^n efficiently?',
    difficulty: 'easy',
    frequency: 95,
    tags: ['recursion', 'binary exponentiation', 'math'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Infosys', logoUrl: '' },
    ],
    hints: [
      'Use fast exponentiation: divide n into halves recursively.',
      'Remember: x^0 = 1 and x^1 = x.',
      'Apply modulo at each step to avoid overflow.',
    ],
    optimalComplexity: {
      time: 'O(log n)',
      space: 'O(log n) recursive or O(1) iterative',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [x, n] = fs.readFileSync(0, "utf-8").trim().split(" ").map(Number);\n  console.log(power(x, n));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    x, n = map(int, input().split())\n    print(power(x, n))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int x = sc.nextInt();\n    int n = sc.nextInt();\n    System.out.println(power(x, n));\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  int x, n;\n  scanf("%d %d", &x, &n);\n  printf("%d\\n", power(x, n));\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint main() {\n  int x, n;\n  cin >> x >> n;\n  cout << power(x, n) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function power(x, n) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def power(x, n):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int power(int x, int n) {\n    // write code here\n    return 1;\n}',
      },
      {
        language: 'c',
        code: 'int power(int x, int n) {\n    // write code here\n    return 1;\n}',
      },
      {
        language: 'cpp',
        code: 'int power(int x, int n) {\n    // write code here\n    return 1;\n}',
      },
    ],
  },
  {
    title: 'Count Digits of a Number',
    slug: 'count-digits-of-a-number',
    description: 'Count how many digits are present in a given number.',
    problemStatement:
      'Given a non-negative integer <code>n</code>, return the number of digits in it.\n\nYou must not use string conversion methods (e.g., .length, str, toString).\n\n<pre><code>Input: 12345\nOutput: 5\n\nInput: 0\nOutput: 1</code></pre>\n\n<ul>\n<li>0 ≤ n ≤ 10<sup>18</sup></li>\n<li>Use only arithmetic operations</li>\n<li>Efficient solutions should use O(log n) time</li>\n</ul>\n\nPro Tip: Divide the number by 10 repeatedly to count how many times it takes to reach 0.',
    sampleTestCases: [
      { input: '12345', expected: '5' },
      { input: '0', expected: '1' },
    ],
    testCases: [
      { input: '1', expected: '1' },
      { input: '9', expected: '1' },
      { input: '99', expected: '2' },
      { input: '100', expected: '3' },
      { input: '123456789', expected: '9' },
      { input: '100000', expected: '6' },
      { input: '999999999999', expected: '12' },
      { input: '123456789012345', expected: '15' },
      { input: '1000000000000000000', expected: '19' },
      { input: '999999999999999999', expected: '18' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Given an integer, can you count how many digits it has using only arithmetic operations?',
    difficulty: 'easy',
    frequency: 94,
    tags: ['math', 'digits', 'logarithmic'],
    companies: [
      { name: 'Wipro', logoUrl: '' },
      { name: 'TCS', logoUrl: '' },
      { name: 'Infosys', logoUrl: '' },
    ],
    hints: [
      'Keep dividing the number by 10 until it becomes 0.',
      'Count the number of iterations in the process.',
      'Handle 0 as a special case.',
    ],
    optimalComplexity: {
      time: 'O(log n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const n = BigInt(fs.readFileSync(0, "utf-8").trim());\n  console.log(countDigits(n));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    print(countDigits(n))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\nimport java.math.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    BigInteger n = sc.nextBigInteger();\n    System.out.println(countDigits(n));\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  long long n;\n  scanf("%lld", &n);\n  printf("%d\\n", countDigits(n));\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint main() {\n  long long n;\n  cin >> n;\n  cout << countDigits(n) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function countDigits(n) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def countDigits(n):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int countDigits(BigInteger n) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'c',
        code: 'int countDigits(long long n) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'int countDigits(long long n) {\n    // write code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Check if Array is Sorted',
    slug: 'check-if-array-is-sorted',
    description:
      'Determine whether an array is sorted in non-decreasing order.',
    problemStatement:
      'Given an array of integers, check if the array is sorted in non-decreasing order.\n\nReturn <code>true</code> if sorted, otherwise <code>false</code>.\n\n<pre><code>Input:\n5\n1 2 2 3 4\nOutput:\ntrue\n\nInput:\n4\n4 3 2 1\nOutput:\nfalse</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 10⁵</li>\n<li>−10⁹ ≤ arr[i] ≤ 10⁹</li>\n<li>Use O(1) space and O(n) time</li>\n</ul>\n\nPro Tip: Compare each element with the next one, and return false if any element is greater than the next.',
    sampleTestCases: [
      { input: '5\n1 2 2 3 4', expected: 'true' },
      { input: '3\n3 2 1', expected: 'false' },
    ],
    testCases: [
      { input: '1\n5', expected: 'true' },
      { input: '2\n5 5', expected: 'true' },
      { input: '3\n1 2 3', expected: 'true' },
      { input: '3\n3 2 1', expected: 'false' },
      { input: '4\n1 3 2 4', expected: 'false' },
      { input: '6\n1 2 3 4 5 6', expected: 'true' },
      { input: '6\n6 5 4 3 2 1', expected: 'false' },
      { input: '4\n7 7 7 7', expected: 'true' },
      { input: '5\n1 1 2 2 3', expected: 'true' },
      { input: '5\n1 2 3 4 3', expected: 'false' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you determine if an array is sorted in a single pass?',
    difficulty: 'easy',
    frequency: 95,
    tags: ['array', 'comparison', 'iteration'],
    companies: [
      { name: 'Infosys', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'TCS', logoUrl: '' },
    ],
    hints: [
      'Iterate through the array.',
      'Compare each element with the next one.',
      'Return false if any element is greater than the next.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = input[1].split(" ").map(Number);\n  console.log(isSorted(arr));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(isSorted(arr))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int[] arr = new int[n];\n    for(int i = 0; i < n; i++) arr[i] = sc.nextInt();\n    System.out.println(isSorted(arr));\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  int n;\n  scanf("%d", &n);\n  int arr[n];\n  for(int i = 0; i < n; i++) scanf("%d", &arr[i]);\n  printf("%s\\n", isSorted(arr, n) ? "true" : "false");\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nbool isSorted(int arr[], int n);\nint main() {\n  int n;\n  cin >> n;\n  int arr[n];\n  for(int i = 0; i < n; i++) cin >> arr[i];\n  cout << (isSorted(arr, n) ? "true" : "false") << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function isSorted(arr) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def isSorted(arr):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static boolean isSorted(int[] arr) {\n    // write code here\n    return false;\n}',
      },
      {
        language: 'c',
        code: 'int isSorted(int arr[], int n) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'bool isSorted(int arr[], int n) {\n    // write code here\n    return false;\n}',
      },
    ],
  },
  {
    title: 'Linear Search in Array',
    slug: 'linear-search-in-array',
    description: 'Search for a given element in an array using linear search.',
    problemStatement:
      'Given an array of integers and a target value <code>x</code>, return the index of the first occurrence of <code>x</code> using linear search. If <code>x</code> is not present, return <code>-1</code>.\n\n<pre><code>Input:\n6\n1 3 5 7 9 11\n7\nOutput:\n3\n\nInput:\n4\n10 20 30 40\n25\nOutput:\n-1</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 10⁵</li>\n<li>−10⁹ ≤ arr[i], x ≤ 10⁹</li>\n<li>Return the 0-based index of the first occurrence</li>\n</ul>\n\nPro Tip: Start checking elements from the beginning and stop as soon as you find the target.',
    sampleTestCases: [
      { input: '5\n2 4 6 8 10\n6', expected: '2' },
      { input: '4\n5 7 9 11\n8', expected: '-1' },
    ],
    testCases: [
      { input: '1\n5\n5', expected: '0' },
      { input: '2\n1 2\n2', expected: '1' },
      { input: '3\n1 2 3\n4', expected: '-1' },
      { input: '6\n10 20 30 40 50 60\n40', expected: '3' },
      { input: '7\n1 2 3 4 5 6 7\n1', expected: '0' },
      { input: '5\n5 5 5 5 5\n5', expected: '0' },
      { input: '10\n0 1 2 3 4 5 6 7 8 9\n9', expected: '9' },
      { input: '4\n-3 -1 0 2\n0', expected: '2' },
      { input: '5\n100 200 300 400 500\n600', expected: '-1' },
      { input: '3\n8 9 10\n10', expected: '2' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you search for a number in an array without using in-built functions?',
    difficulty: 'easy',
    frequency: 97,
    tags: ['array', 'linear search', 'iteration'],
    companies: [
      { name: 'TCS', logoUrl: '' },
      { name: 'Wipro', logoUrl: '' },
      { name: 'Infosys', logoUrl: '' },
    ],
    hints: [
      'Use a loop to iterate over the array.',
      'Return the index when you find the element.',
      'If loop ends without finding it, return -1.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = input[1].split(" ").map(Number);\n  const x = parseInt(input[2]);\n  console.log(linearSearch(arr, x));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    x = int(input())\n    print(linearSearch(arr, x))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int[] arr = new int[n];\n    for(int i = 0; i < n; i++) arr[i] = sc.nextInt();\n    int x = sc.nextInt();\n    System.out.println(linearSearch(arr, x));\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  int n, x;\n  scanf("%d", &n);\n  int arr[n];\n  for(int i = 0; i < n; i++) scanf("%d", &arr[i]);\n  scanf("%d", &x);\n  printf("%d\\n", linearSearch(arr, n, x));\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint main() {\n  int n, x;\n  cin >> n;\n  int arr[n];\n  for(int i = 0; i < n; i++) cin >> arr[i];\n  cin >> x;\n  cout << linearSearch(arr, n, x) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function linearSearch(arr, x) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def linearSearch(arr, x):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int linearSearch(int[] arr, int x) {\n    // write code here\n    return -1;\n}',
      },
      {
        language: 'c',
        code: 'int linearSearch(int arr[], int n, int x) {\n    // write code here\n    return -1;\n}',
      },
      {
        language: 'cpp',
        code: 'int linearSearch(int arr[], int n, int x) {\n    // write code here\n    return -1;\n}',
      },
    ],
  },
  {
    title: 'Binary Search Using Recursion',
    slug: 'binary-search-using-recursion',
    description:
      'Implement binary search to find a target in a sorted array using recursion.',
    problemStatement:
      'Given a sorted array of integers and a target value <code>x</code>, return the index of <code>x</code> using recursive binary search. If <code>x</code> is not found, return <code>-1</code>.\n\nYou must implement the solution recursively.\n\n<pre><code>Input:\n5\n1 3 5 7 9\n7\nOutput:\n3\n\nInput:\n4\n10 20 30 40\n25\nOutput:\n-1</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 10⁵</li>\n<li>−10⁹ ≤ arr[i], x ≤ 10⁹</li>\n<li>The array is sorted in non-decreasing order</li>\n</ul>\n\nPro Tip: Use the recursive divide-and-conquer strategy by checking the middle element and reducing the search range accordingly.',
    sampleTestCases: [
      { input: '5\n1 3 5 7 9\n7', expected: '3' },
      { input: '4\n10 20 30 40\n25', expected: '-1' },
    ],
    testCases: [
      { input: '1\n5\n5', expected: '0' },
      { input: '3\n1 2 3\n3', expected: '2' },
      { input: '6\n2 4 6 8 10 12\n2', expected: '0' },
      { input: '5\n5 10 15 20 25\n25', expected: '4' },
      { input: '5\n5 10 15 20 25\n5', expected: '0' },
      { input: '5\n5 10 15 20 25\n17', expected: '-1' },
      { input: '6\n1 3 5 7 9 11\n11', expected: '5' },
      { input: '6\n1 3 5 7 9 11\n4', expected: '-1' },
      { input: '10\n1 2 3 4 5 6 7 8 9 10\n6', expected: '5' },
      { input: '7\n2 4 6 8 10 12 14\n8', expected: '3' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you implement binary search recursively without using loops?',
    difficulty: 'easy',
    frequency: 97,
    tags: ['array', 'binary search', 'recursion'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Infosys', logoUrl: '' },
    ],
    hints: [
      'Define a recursive helper function with low and high indices.',
      'Base case: if low > high, return -1.',
      'Check middle element and recurse left or right accordingly.',
    ],
    optimalComplexity: {
      time: 'O(log n)',
      space: 'O(log n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = input[1].split(" ").map(Number);\n  const x = parseInt(input[2]);\n  console.log(binarySearch(arr, x, 0, n - 1));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    x = int(input())\n    print(binarySearch(arr, x, 0, n - 1))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int[] arr = new int[n];\n    for(int i = 0; i < n; i++) arr[i] = sc.nextInt();\n    int x = sc.nextInt();\n    System.out.println(binarySearch(arr, x, 0, n - 1));\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  int n, x;\n  scanf("%d", &n);\n  int arr[n];\n  for(int i = 0; i < n; i++) scanf("%d", &arr[i]);\n  scanf("%d", &x);\n  printf("%d\\n", binarySearch(arr, x, 0, n - 1));\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint binarySearch(int arr[], int x, int low, int high);\nint main() {\n  int n, x;\n  cin >> n;\n  int arr[n];\n  for(int i = 0; i < n; i++) cin >> arr[i];\n  cin >> x;\n  cout << binarySearch(arr, x, 0, n - 1) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function binarySearch(arr, x, low, high) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def binarySearch(arr, x, low, high):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int binarySearch(int[] arr, int x, int low, int high) {\n    // write code here\n    return -1;\n}',
      },
      {
        language: 'c',
        code: 'int binarySearch(int arr[], int x, int low, int high) {\n    // write code here\n    return -1;\n}',
      },
      {
        language: 'cpp',
        code: 'int binarySearch(int arr[], int x, int low, int high) {\n    // write code here\n    return -1;\n}',
      },
    ],
  },
  {
    title: 'Find First Occurrence in Array',
    slug: 'find-first-occurrence-in-array',
    description:
      'Find the index of the first occurrence of a given element in a sorted array.',
    problemStatement:
      'Given a sorted array of integers and a target value <code>x</code>, return the index of the first occurrence of <code>x</code>. If <code>x</code> is not present, return <code>-1</code>.\n\nYou must implement a binary search-based solution to ensure logarithmic time complexity.\n\n<pre><code>Input:\n6\n1 2 2 2 3 4\n2\nOutput:\n1\n\nInput:\n5\n1 3 5 7 9\n4\nOutput:\n-1</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 10⁵</li>\n<li>−10⁹ ≤ arr[i], x ≤ 10⁹</li>\n<li>Array is sorted in non-decreasing order</li>\n<li>Return 0-based index of first occurrence</li>\n</ul>\n\nPro Tip: Use modified binary search — when you find x, check if it’s the first occurrence or keep searching left.',
    sampleTestCases: [
      { input: '6\n1 2 2 2 3 4\n2', expected: '1' },
      { input: '5\n1 3 5 7 9\n4', expected: '-1' },
    ],
    testCases: [
      { input: '1\n5\n5', expected: '0' },
      { input: '2\n5 5\n5', expected: '0' },
      { input: '4\n1 2 2 3\n2', expected: '1' },
      { input: '6\n1 2 2 2 3 4\n3', expected: '4' },
      { input: '6\n1 2 2 2 3 4\n5', expected: '-1' },
      { input: '8\n1 1 2 2 2 2 3 4\n2', expected: '2' },
      { input: '6\n1 1 1 1 1 1\n1', expected: '0' },
      { input: '5\n1 2 3 4 5\n5', expected: '4' },
      { input: '5\n1 2 3 4 5\n1', expected: '0' },
      { input: '5\n1 2 3 4 5\n6', expected: '-1' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re given a sorted array with duplicates. Can you find the first occurrence of a value efficiently?',
    difficulty: 'easy',
    frequency: 98,
    tags: ['binary search', 'array', 'first occurrence'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'TCS', logoUrl: '' },
    ],
    hints: [
      'Use binary search, not linear search.',
      'When x is found, check if it’s the first element or if the element before it is also x.',
      'If so, continue search in the left half.',
    ],
    optimalComplexity: {
      time: 'O(log n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = input[1].split(" ").map(Number);\n  const x = parseInt(input[2]);\n  console.log(firstOccurrence(arr, x));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    x = int(input())\n    print(firstOccurrence(arr, x))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int[] arr = new int[n];\n    for(int i = 0; i < n; i++) arr[i] = sc.nextInt();\n    int x = sc.nextInt();\n    System.out.println(firstOccurrence(arr, x));\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  int n, x;\n  scanf("%d", &n);\n  int arr[n];\n  for(int i = 0; i < n; i++) scanf("%d", &arr[i]);\n  scanf("%d", &x);\n  printf("%d\\n", firstOccurrence(arr, n, x));\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint firstOccurrence(int arr[], int n, int x);\nint main() {\n  int n, x;\n  cin >> n;\n  int arr[n];\n  for(int i = 0; i < n; i++) cin >> arr[i];\n  cin >> x;\n  cout << firstOccurrence(arr, n, x) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function firstOccurrence(arr, x) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def firstOccurrence(arr, x):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int firstOccurrence(int[] arr, int x) {\n    // write code here\n    return -1;\n}',
      },
      {
        language: 'c',
        code: 'int firstOccurrence(int arr[], int n, int x) {\n    // write code here\n    return -1;\n}',
      },
      {
        language: 'cpp',
        code: 'int firstOccurrence(int arr[], int n, int x) {\n    // write code here\n    return -1;\n}',
      },
    ],
  },
  {
    title: 'Find Last Occurrence in Array',
    slug: 'find-last-occurrence-in-array',
    description:
      'Find the index of the last occurrence of a given element in a sorted array.',
    problemStatement:
      'Given a sorted array of integers and a target value <code>x</code>, return the index of the last occurrence of <code>x</code>. If <code>x</code> is not present, return <code>-1</code>.\n\nYou must implement a binary search-based solution to ensure logarithmic time complexity.\n\n<pre><code>Input:\n6\n1 2 2 2 3 4\n2\nOutput:\n3\n\nInput:\n5\n1 3 5 7 9\n4\nOutput:\n-1</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 10⁵</li>\n<li>−10⁹ ≤ arr[i], x ≤ 10⁹</li>\n<li>Array is sorted in non-decreasing order</li>\n<li>Return 0-based index of last occurrence</li>\n</ul>\n\nPro Tip: Use modified binary search — when you find x, check if it’s the last occurrence or keep searching right.',
    sampleTestCases: [
      { input: '6\n1 2 2 2 3 4\n2', expected: '3' },
      { input: '5\n1 3 5 7 9\n4', expected: '-1' },
    ],
    testCases: [
      { input: '1\n5\n5', expected: '0' },
      { input: '2\n5 5\n5', expected: '1' },
      { input: '4\n1 2 2 3\n2', expected: '2' },
      { input: '6\n1 2 2 2 3 4\n3', expected: '4' },
      { input: '6\n1 2 2 2 3 4\n5', expected: '-1' },
      { input: '8\n1 1 2 2 2 2 3 4\n2', expected: '5' },
      { input: '6\n1 1 1 1 1 1\n1', expected: '5' },
      { input: '5\n1 2 3 4 5\n5', expected: '4' },
      { input: '5\n1 2 3 4 5\n1', expected: '0' },
      { input: '5\n1 2 3 4 5\n6', expected: '-1' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're given a sorted array with possible duplicates. Can you find the last occurrence of a value efficiently?",
    difficulty: 'easy',
    frequency: 97,
    tags: ['binary search', 'array', 'last occurrence'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'TCS', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use binary search instead of linear scan.',
      'When x is found, check if it’s the last element or if the element after it is also x.',
      'If so, continue searching in the right half.',
    ],
    optimalComplexity: {
      time: 'O(log n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = input[1].split(" ").map(Number);\n  const x = parseInt(input[2]);\n  console.log(lastOccurrence(arr, x));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    x = int(input())\n    print(lastOccurrence(arr, x))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int[] arr = new int[n];\n    for(int i = 0; i < n; i++) arr[i] = sc.nextInt();\n    int x = sc.nextInt();\n    System.out.println(lastOccurrence(arr, x));\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  int n, x;\n  scanf("%d", &n);\n  int arr[n];\n  for(int i = 0; i < n; i++) scanf("%d", &arr[i]);\n  scanf("%d", &x);\n  printf("%d\\n", lastOccurrence(arr, n, x));\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint lastOccurrence(int arr[], int n, int x);\nint main() {\n  int n, x;\n  cin >> n;\n  int arr[n];\n  for(int i = 0; i < n; i++) cin >> arr[i];\n  cin >> x;\n  cout << lastOccurrence(arr, n, x) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function lastOccurrence(arr, x) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def lastOccurrence(arr, x):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int lastOccurrence(int[] arr, int x) {\n    // write code here\n    return -1;\n}',
      },
      {
        language: 'c',
        code: 'int lastOccurrence(int arr[], int n, int x) {\n    // write code here\n    return -1;\n}',
      },
      {
        language: 'cpp',
        code: 'int lastOccurrence(int arr[], int n, int x) {\n    // write code here\n    return -1;\n}',
      },
    ],
  },
  {
    title: 'Store All Occurrences of an Element',
    slug: 'store-all-occurrences-of-an-element',
    description: 'Find and store all indices of a target element in an array.',
    problemStatement:
      'Given an array of integers and a target value <code>x</code>, return all indices where <code>x</code> occurs in the array. Return the indices in increasing order. If the element is not present, return an empty list.\n\n<pre><code>Input:\n7\n1 2 3 2 4 2 5\n2\nOutput:\n1 3 5\n\nInput:\n4\n1 3 5 7\n2\nOutput:\n</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 10⁵</li>\n<li>−10⁹ ≤ arr[i], x ≤ 10⁹</li>\n<li>Return the space-separated list of 0-based indices, or blank if not found</li>\n</ul>\n\nPro Tip: Use a loop to iterate and collect matching indices in a result list.',
    sampleTestCases: [
      { input: '7\n1 2 3 2 4 2 5\n2', expected: '1 3 5' },
      { input: '4\n1 3 5 7\n2', expected: '' },
    ],
    testCases: [
      { input: '1\n2\n2', expected: '0' },
      { input: '2\n2 2\n2', expected: '0 1' },
      { input: '5\n1 2 3 2 1\n2', expected: '1 3' },
      { input: '6\n1 1 1 1 1 1\n1', expected: '0 1 2 3 4 5' },
      { input: '6\n1 2 3 4 5 6\n7', expected: '' },
      { input: '5\n2 3 4 5 2\n2', expected: '0 4' },
      { input: '4\n5 6 7 8\n8', expected: '3' },
      { input: '3\n9 9 9\n9', expected: '0 1 2' },
      { input: '5\n1 2 3 4 5\n5', expected: '4' },
      { input: '5\n5 4 3 2 1\n1', expected: '4' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you return all the positions where a given number appears in an array?',
    difficulty: 'easy',
    frequency: 97,
    tags: ['array', 'search', 'iteration'],
    companies: [
      { name: 'Wipro', logoUrl: '' },
      { name: 'TCS', logoUrl: '' },
      { name: 'Capgemini', logoUrl: '' },
    ],
    hints: [
      'Iterate through the array.',
      'For each match with x, append the index to result list.',
      'Handle empty result by printing blank output.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = input[1].split(" ").map(Number);\n  const x = parseInt(input[2]);\n  console.log(storeOccurrences(arr, x).join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    x = int(input())\n    print(" ".join(map(str, storeOccurrences(arr, x))))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int[] arr = new int[n];\n    for(int i = 0; i < n; i++) arr[i] = sc.nextInt();\n    int x = sc.nextInt();\n    List<Integer> result = storeOccurrences(arr, x);\n    for(int i : result) System.out.print(i + " ");\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  int n, x;\n  scanf("%d", &n);\n  int arr[n];\n  for(int i = 0; i < n; i++) scanf("%d", &arr[i]);\n  scanf("%d", &x);\n  storeOccurrences(arr, n, x);\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nvoid storeOccurrences(int arr[], int n, int x);\nint main() {\n  int n, x;\n  cin >> n;\n  int arr[n];\n  for(int i = 0; i < n; i++) cin >> arr[i];\n  cin >> x;\n  storeOccurrences(arr, n, x);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function storeOccurrences(arr, x) {\n  // write code here\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def storeOccurrences(arr, x):\n    # write code here\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<Integer> storeOccurrences(int[] arr, int x) {\n    // write code here\n    return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void storeOccurrences(int arr[], int n, int x) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'void storeOccurrences(int arr[], int n, int x) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Maximum Element in Array',
    slug: 'maximum-element-in-array',
    description: 'Find the largest number in the given array.',
    problemStatement:
      'Given an array of integers, return the maximum (largest) element present in the array.\n\n<pre><code>Input:\n5\n1 3 7 2 5\nOutput:\n7\n\nInput:\n4\n-1 -5 -3 -4\nOutput:\n-1</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 10⁵</li>\n<li>−10⁹ ≤ arr[i] ≤ 10⁹</li>\n<li>You must find the maximum value in O(n) time using a single traversal.</li>\n</ul>\n\nPro Tip: Initialize a variable to store the max and iterate through the array comparing and updating it.',
    sampleTestCases: [
      { input: '5\n1 3 7 2 5', expected: '7' },
      { input: '4\n-1 -5 -3 -4', expected: '-1' },
    ],
    testCases: [
      { input: '1\n100', expected: '100' },
      { input: '2\n5 5', expected: '5' },
      { input: '3\n10 20 30', expected: '30' },
      { input: '5\n-10 -20 -30 -5 -1', expected: '-1' },
      { input: '6\n10 9 8 7 6 5', expected: '10' },
      { input: '6\n1 2 3 4 5 100', expected: '100' },
      { input: '4\n999 1000 998 997', expected: '1000' },
      { input: '5\n0 0 0 0 0', expected: '0' },
      { input: '3\n-1 -1 -1', expected: '-1' },
      {
        input: '6\n-1000000000 0 1000000000 -5 99 -99',
        expected: '1000000000',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re given a list of numbers. Can you find the highest one using a single pass?',
    difficulty: 'easy',
    frequency: 98,
    tags: ['array', 'maximum', 'iteration'],
    companies: [
      { name: 'Wipro', logoUrl: '' },
      { name: 'TCS', logoUrl: '' },
      { name: 'Accenture', logoUrl: '' },
    ],
    hints: [
      'Initialize max with the first element.',
      'Iterate through the rest and update if you find a bigger value.',
      'Return the final max.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = input[1].split(" ").map(Number);\n  console.log(maxElement(arr));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(maxElement(arr))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int[] arr = new int[n];\n    for (int i = 0; i < n; i++) arr[i] = sc.nextInt();\n    System.out.println(maxElement(arr));\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  int n;\n  scanf("%d", &n);\n  int arr[n];\n  for(int i = 0; i < n; i++) scanf("%d", &arr[i]);\n  printf("%d\\n", maxElement(arr, n));\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint maxElement(int arr[], int n);\nint main() {\n  int n;\n  cin >> n;\n  int arr[n];\n  for(int i = 0; i < n; i++) cin >> arr[i];\n  cout << maxElement(arr, n) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function maxElement(arr) {\n  // write code here\n  return 0;\n}',
      },
      {
        language: 'python',
        code: 'def maxElement(arr):\n    # write code here\n    return 0',
      },
      {
        language: 'java',
        code: 'public static int maxElement(int[] arr) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'c',
        code: 'int maxElement(int arr[], int n) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'int maxElement(int arr[], int n) {\n    // write code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Generate All Subarrays',
    slug: 'generate-all-subarrays',
    description: 'Print all possible contiguous subarrays of a given array.',
    problemStatement:
      'Given an array of integers, generate and print all possible contiguous subarrays.\n\nEach subarray must be printed on a new line, with elements separated by spaces.\n\n<pre><code>Input:\n3\n1 2 3\nOutput:\n1\n1 2\n1 2 3\n2\n2 3\n3</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 1000</li>\n<li>−10⁶ ≤ arr[i] ≤ 10⁶</li>\n<li>There are n(n+1)/2 total subarrays</li>\n<li>Order must be from left to right, i.e., start from index 0 to n-1</li>\n</ul>\n\nPro Tip: Use two nested loops — outer for starting index, inner for ending index — and print the subarray directly.',
    sampleTestCases: [
      { input: '3\n1 2 3', expected: '1\n1 2\n1 2 3\n2\n2 3\n3' },
      { input: '2\n4 5', expected: '4\n4 5\n5' },
    ],
    testCases: [
      { input: '1\n10', expected: '10' },
      { input: '2\n10 20', expected: '10\n10 20\n20' },
      { input: '3\n-1 0 1', expected: '-1\n-1 0\n-1 0 1\n0\n0 1\n1' },
      {
        input: '4\n1 1 1 1',
        expected: '1\n1 1\n1 1 1\n1 1 1 1\n1\n1 1\n1 1 1\n1\n1 1\n1',
      },
      { input: '3\n7 8 9', expected: '7\n7 8\n7 8 9\n8\n8 9\n9' },
      { input: '2\n-5 -10', expected: '-5\n-5 -10\n-10' },
      {
        input: '4\n1 2 3 4',
        expected: '1\n1 2\n1 2 3\n1 2 3 4\n2\n2 3\n2 3 4\n3\n3 4\n4',
      },
      { input: '3\n0 0 0', expected: '0\n0 0\n0 0 0\n0\n0 0\n0' },
      {
        input: '2\n1000000 -1000000',
        expected: '1000000\n1000000 -1000000\n-1000000',
      },
      { input: '3\n5 10 15', expected: '5\n5 10\n5 10 15\n10\n10 15\n15' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Let's try generating all contiguous subarrays of an array. Can you print each one line-by-line?",
    difficulty: 'easy',
    frequency: 92,
    tags: ['array', 'nested loop', 'subarray generation'],
    companies: [
      { name: 'TCS', logoUrl: '' },
      { name: 'Cognizant', logoUrl: '' },
      { name: 'Infosys', logoUrl: '' },
    ],
    hints: [
      'Use two loops: outer for start index, inner for end index.',
      'Print subarrays from arr[i] to arr[j] inclusive.',
      'Be careful with output formatting (space-separated).',
    ],
    optimalComplexity: {
      time: 'O(n^2)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = input[1].split(" ").map(Number);\n  generateSubarrays(arr);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    generateSubarrays(arr)',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int[] arr = new int[n];\n    for(int i = 0; i < n; i++) arr[i] = sc.nextInt();\n    generateSubarrays(arr);\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nvoid generateSubarrays(int arr[], int n);\nint main() {\n  int n;\n  scanf("%d", &n);\n  int arr[n];\n  for(int i = 0; i < n; i++) scanf("%d", &arr[i]);\n  generateSubarrays(arr, n);\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nvoid generateSubarrays(int arr[], int n);\nint main() {\n  int n;\n  cin >> n;\n  int arr[n];\n  for(int i = 0; i < n; i++) cin >> arr[i];\n  generateSubarrays(arr, n);\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function generateSubarrays(arr) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def generateSubarrays(arr):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static void generateSubarrays(int[] arr) {\n    // write code here\n}',
      },
      {
        language: 'c',
        code: 'void generateSubarrays(int arr[], int n) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'void generateSubarrays(int arr[], int n) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Check if Subsequence Exists in Array',
    slug: 'check-if-subsequence-exists-in-array',
    description: 'Verify if the given subsequence exists in the main array.',
    problemStatement:
      'Given two arrays <code>arr</code> and <code>sub</code>, check whether <code>sub</code> is a subsequence of <code>arr</code>.\n\nA subsequence is a sequence that appears in the same relative order, but not necessarily contiguous.\n\nReturn <code>true</code> if <code>sub</code> is a subsequence of <code>arr</code>, otherwise return <code>false</code>.\n\n<pre><code>Input:\n6\n1 2 3 4 5 6\n3\n2 4 6\nOutput:\ntrue\n\nInput:\n5\n10 20 30 40 50\n3\n20 50 40\nOutput:\nfalse</code></pre>\n\n<ul>\n<li>1 ≤ n, m ≤ 10⁵</li>\n<li>−10⁹ ≤ arr[i], sub[i] ≤ 10⁹</li>\n<li>Both arrays may contain duplicates</li>\n</ul>\n\nPro Tip: Use two pointers — one for <code>arr</code> and one for <code>sub</code> — and iterate to verify matching order.',
    sampleTestCases: [
      { input: '6\n1 2 3 4 5 6\n3\n2 4 6', expected: 'true' },
      { input: '5\n10 20 30 40 50\n3\n20 50 40', expected: 'false' },
    ],
    testCases: [
      { input: '5\n1 2 3 4 5\n3\n1 2 3', expected: 'true' },
      { input: '5\n1 2 3 4 5\n3\n2 4 5', expected: 'true' },
      { input: '5\n1 2 3 4 5\n3\n3 2 1', expected: 'false' },
      { input: '4\n1 2 2 3\n2\n2 3', expected: 'true' },
      { input: '4\n1 2 2 3\n2\n2 2', expected: 'true' },
      { input: '4\n1 2 2 3\n2\n2 4', expected: 'false' },
      { input: '3\n5 6 7\n3\n5 6 7', expected: 'true' },
      { input: '3\n5 6 7\n0\n', expected: 'true' },
      { input: '0\n\n1\n1', expected: 'false' },
      { input: '6\n1 2 3 4 5 6\n6\n1 2 3 4 5 6', expected: 'true' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you determine if one array is a subsequence of another using a simple linear scan?',
    difficulty: 'easy',
    frequency: 95,
    tags: ['two pointer', 'subsequence', 'array'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Infosys', logoUrl: '' },
      { name: 'Wipro', logoUrl: '' },
    ],
    hints: [
      'Maintain two indices — i for arr, j for sub.',
      'If arr[i] matches sub[j], move both forward.',
      'If j reaches end of sub, return true.',
    ],
    optimalComplexity: {
      time: 'O(n + m)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = input[1].split(" ").map(Number);\n  const m = parseInt(input[2]);\n  const sub = input[3].split(" ").map(Number);\n  console.log(isSubsequence(arr, sub));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    m = int(input())\n    sub = list(map(int, input().split()))\n    print(isSubsequence(arr, sub))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int[] arr = new int[n];\n    for (int i = 0; i < n; i++) arr[i] = sc.nextInt();\n    int m = sc.nextInt();\n    int[] sub = new int[m];\n    for (int i = 0; i < m; i++) sub[i] = sc.nextInt();\n    System.out.println(isSubsequence(arr, sub));\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\n#include <stdbool.h>\nbool isSubsequence(int arr[], int n, int sub[], int m);\nint main() {\n  int n, m;\n  scanf("%d", &n);\n  int arr[n];\n  for (int i = 0; i < n; i++) scanf("%d", &arr[i]);\n  scanf("%d", &m);\n  int sub[m];\n  for (int i = 0; i < m; i++) scanf("%d", &sub[i]);\n  printf(isSubsequence(arr, n, sub, m) ? "true\\n" : "false\\n");\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nbool isSubsequence(int arr[], int n, int sub[], int m);\nint main() {\n  int n, m;\n  cin >> n;\n  int arr[n];\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  cin >> m;\n  int sub[m];\n  for (int i = 0; i < m; i++) cin >> sub[i];\n  cout << (isSubsequence(arr, n, sub, m) ? "true" : "false") << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function isSubsequence(arr, sub) {\n  // write code here\n  return false;\n}',
      },
      {
        language: 'python',
        code: 'def isSubsequence(arr, sub):\n    # write code here\n    return False',
      },
      {
        language: 'java',
        code: 'public static boolean isSubsequence(int[] arr, int[] sub) {\n    // write code here\n    return false;\n}',
      },
      {
        language: 'c',
        code: 'bool isSubsequence(int arr[], int n, int sub[], int m) {\n    // write code here\n    return false;\n}',
      },
      {
        language: 'cpp',
        code: 'bool isSubsequence(int arr[], int n, int sub[], int m) {\n    // write code here\n    return false;\n}',
      },
    ],
  },
  {
    title: 'Sum of Array Elements',
    slug: 'sum-of-array-elements',
    description: 'Calculate the sum of all elements in the array.',
    problemStatement:
      'Given an array of integers, return the sum of all its elements.\n\n<pre><code>Input:\n5\n1 2 3 4 5\nOutput:\n15\n\nInput:\n4\n10 -2 3 7\nOutput:\n18</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 10⁵</li>\n<li>−10⁶ ≤ arr[i] ≤ 10⁶</li>\n<li>Expected time complexity: O(n)</li>\n</ul>\n\nPro Tip: Use a loop or built-in methods (where allowed) to accumulate the sum while iterating over the array.',
    sampleTestCases: [
      { input: '5\n1 2 3 4 5', expected: '15' },
      { input: '4\n10 -2 3 7', expected: '18' },
    ],
    testCases: [
      { input: '1\n5', expected: '5' },
      { input: '2\n-5 5', expected: '0' },
      { input: '3\n100 200 300', expected: '600' },
      { input: '5\n0 0 0 0 0', expected: '0' },
      { input: '4\n-1 -2 -3 -4', expected: '-10' },
      { input: '6\n1 -1 1 -1 1 -1', expected: '0' },
      { input: '5\n5 10 15 20 25', expected: '75' },
      { input: '2\n1000000 1000000', expected: '2000000' },
      { input: '3\n1 -1000000 999999', expected: '0' },
      { input: '4\n4 3 2 1', expected: '10' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'This is a warm-up task. Can you quickly compute the sum of all values in an array?',
    difficulty: 'easy',
    frequency: 99,
    tags: ['array', 'sum', 'loop'],
    companies: [
      { name: 'TCS', logoUrl: '' },
      { name: 'Wipro', logoUrl: '' },
      { name: 'Capgemini', logoUrl: '' },
    ],
    hints: [
      'Initialize a sum variable to 0.',
      'Iterate through the array and add each element to sum.',
      'Return or print the final sum.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = input[1].split(" ").map(Number);\n  console.log(sumArray(arr));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(sumArray(arr))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int[] arr = new int[n];\n    for (int i = 0; i < n; i++) arr[i] = sc.nextInt();\n    System.out.println(sumArray(arr));\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint sumArray(int arr[], int n);\nint main() {\n  int n;\n  scanf("%d", &n);\n  int arr[n];\n  for (int i = 0; i < n; i++) scanf("%d", &arr[i]);\n  printf("%d\\n", sumArray(arr, n));\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint sumArray(int arr[], int n);\nint main() {\n  int n;\n  cin >> n;\n  int arr[n];\n  for (int i = 0; i < n; i++) cin >> arr[i];\n  cout << sumArray(arr, n) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function sumArray(arr) {\n  // write code here\n  return 0;\n}',
      },
      {
        language: 'python',
        code: 'def sumArray(arr):\n    # write code here\n    return 0',
      },
      {
        language: 'java',
        code: 'public static int sumArray(int[] arr) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'c',
        code: 'int sumArray(int arr[], int n) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'int sumArray(int arr[], int n) {\n    // write code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Reverse Array using Recursion',
    slug: 'reverse-array-using-recursion',
    description: 'Reverse the elements of an array using a recursive approach.',
    problemStatement:
      'Given an array of integers, reverse its contents using recursion. You must not use iterative constructs like loops.\n\n<pre><code>Input:\n5\n1 2 3 4 5\nOutput:\n5 4 3 2 1\n\nInput:\n3\n10 20 30\nOutput:\n30 20 10</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 10⁴</li>\n<li>−10⁶ ≤ arr[i] ≤ 10⁶</li>\n<li>Use a helper recursive function or pass additional parameters if needed</li>\n</ul>\n\nPro Tip: Swap first and last elements, then recursively reverse the remaining subarray.',
    sampleTestCases: [
      { input: '5\n1 2 3 4 5', expected: '5 4 3 2 1' },
      { input: '3\n10 20 30', expected: '30 20 10' },
    ],
    testCases: [
      { input: '1\n100', expected: '100' },
      { input: '2\n1 2', expected: '2 1' },
      { input: '4\n-1 -2 -3 -4', expected: '-4 -3 -2 -1' },
      { input: '3\n5 5 5', expected: '5 5 5' },
      { input: '6\n1 3 5 7 9 11', expected: '11 9 7 5 3 1' },
      { input: '5\n0 0 0 0 0', expected: '0 0 0 0 0' },
      { input: '3\n1000000 0 -1000000', expected: '-1000000 0 1000000' },
      { input: '4\n4 3 2 1', expected: '1 2 3 4' },
      { input: '2\n7 14', expected: '14 7' },
      { input: '3\n99 100 101', expected: '101 100 99' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Reverse an array recursively without using loops. Think divide and conquer.',
    difficulty: 'easy',
    frequency: 92,
    tags: ['recursion', 'array', 'two pointer'],
    companies: [
      { name: 'TCS', logoUrl: '' },
      { name: 'Infosys', logoUrl: '' },
      { name: 'Wipro', logoUrl: '' },
    ],
    hints: [
      'Use two pointers: start and end.',
      'Swap elements at start and end, then recurse on the remaining subarray.',
      'Base case: stop when start >= end.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const arr = input[1].split(" ").map(Number);\n  reverseArray(arr, 0, arr.length - 1);\n  console.log(arr.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'def reverseArray(arr, start, end):\n    if start >= end:\n        return\n    arr[start], arr[end] = arr[end], arr[start]\n    reverseArray(arr, start + 1, end - 1)\n\nif __name__ == "__main__":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    reverseArray(arr, 0, n - 1)\n    print(" ".join(map(str, arr)))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void reverseArray(int[] arr, int start, int end) {\n    if (start >= end) return;\n    int temp = arr[start];\n    arr[start] = arr[end];\n    arr[end] = temp;\n    reverseArray(arr, start + 1, end - 1);\n  }\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int[] arr = new int[n];\n    for (int i = 0; i < n; i++) arr[i] = sc.nextInt();\n    reverseArray(arr, 0, n - 1);\n    for (int i : arr) System.out.print(i + " ");\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nvoid reverseArray(int arr[], int start, int end) {\n    if (start >= end) return;\n    int temp = arr[start];\n    arr[start] = arr[end];\n    arr[end] = temp;\n    reverseArray(arr, start + 1, end - 1);\n}\nint main() {\n    int n;\n    scanf("%d", &n);\n    int arr[n];\n    for (int i = 0; i < n; i++) scanf("%d", &arr[i]);\n    reverseArray(arr, 0, n - 1);\n    for (int i = 0; i < n; i++) printf("%d ", arr[i]);\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nvoid reverseArray(int arr[], int start, int end) {\n    if (start >= end) return;\n    swap(arr[start], arr[end]);\n    reverseArray(arr, start + 1, end - 1);\n}\nint main() {\n    int n;\n    cin >> n;\n    int arr[n];\n    for (int i = 0; i < n; i++) cin >> arr[i];\n    reverseArray(arr, 0, n - 1);\n    for (int i = 0; i < n; i++) cout << arr[i] << " ";\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function reverseArray(arr, start, end) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def reverseArray(arr, start, end):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static void reverseArray(int[] arr, int start, int end) {\n    // write code here\n}',
      },
      {
        language: 'c',
        code: 'void reverseArray(int arr[], int start, int end) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'void reverseArray(int arr[], int start, int end) {\n    // write code here\n}',
      },
    ],
  },
  {
    title: 'Remove All Occurrences of ‘a’ from String',
    slug: 'remove-all-occurrences-of-a-from-string',
    description:
      "Remove all instances of the character 'a' from the input string using recursion.",
    problemStatement:
      "Given a string <code>s</code>, remove all occurrences of the lowercase character <code>'a'</code> using recursion and return the resulting string.\n\nYou must not use iterative loops like <code>for</code> or <code>while</code>.\n\n<pre><code>Input:\nabcaxxa\nOutput:\nbcxx\n\nInput:\naaaaaa\nOutput:\n</code></pre>\n\n<ul>\n<li>1 ≤ |s| ≤ 10⁴</li>\n<li>s consists only of lowercase English letters</li>\n<li>Use recursive string processing</li>\n</ul>\n\nPro Tip: You can solve this by checking one character at a time and recursively building the output.",
    sampleTestCases: [
      { input: 'abcaxxa', expected: 'bcxx' },
      { input: 'aaaaaa', expected: '' },
    ],
    testCases: [
      { input: 'a', expected: '' },
      { input: 'b', expected: 'b' },
      { input: 'abc', expected: 'bc' },
      { input: 'xyz', expected: 'xyz' },
      { input: 'banana', expected: 'bnn' },
      { input: 'abracadabra', expected: 'brcdbr' },
      { input: 'aaabbb', expected: 'bbb' },
      { input: 'abcabcabc', expected: 'bcbcbc' },
      { input: 'abcaaaaa', expected: 'bc' },
      { input: 'bcdef', expected: 'bcdef' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Write a recursive function to remove all occurrences of a given character (say 'a') from a string.",
    difficulty: 'easy',
    frequency: 93,
    tags: ['recursion', 'string'],
    companies: [
      { name: 'TCS', logoUrl: '' },
      { name: 'Wipro', logoUrl: '' },
      { name: 'Infosys', logoUrl: '' },
    ],
    hints: [
      'Base case: if string is empty, return empty string.',
      "Recursive case: if current char is 'a', skip it; else, include it and continue recursion.",
      'Use string slicing or substring methods depending on language.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const s = fs.readFileSync(0, "utf-8").trim();\n  console.log(removeA(s));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    s = input().strip()\n    print(removeA(s))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.next();\n    System.out.println(removeA(s));\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\n#include <string.h>\nvoid removeA(char* s);\nint main() {\n  char s[10001];\n  scanf("%s", s);\n  removeA(s);\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nstring removeA(string s);\nint main() {\n  string s;\n  cin >> s;\n  cout << removeA(s) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function removeA(s) {\n  // write code here\n  return s;\n}',
      },
      {
        language: 'python',
        code: 'def removeA(s):\n    # write code here\n    return s',
      },
      {
        language: 'java',
        code: 'public static String removeA(String s) {\n    // write code here\n    return s;\n}',
      },
      {
        language: 'c',
        code: 'void removeA(char* s) {\n    // write code here\n    return;\n}',
      },
      {
        language: 'cpp',
        code: 'string removeA(string s) {\n    // write code here\n    return s;\n}',
      },
    ],
  },
  {
    title: 'Remove Duplicates in a String',
    slug: 'remove-duplicates-in-a-string',
    description:
      'Remove all duplicate characters from a string while preserving original order.',
    problemStatement:
      'Given a string <code>s</code>, remove all duplicate characters and return the resulting string with only the first occurrences, preserving the original order of characters.\n\n<pre><code>Input:\nprogramming\nOutput:\nprogamin\n\nInput:\naabbcc\nOutput:\nabc</code></pre>\n\n<ul>\n<li>1 ≤ |s| ≤ 10⁵</li>\n<li>s contains only lowercase English letters</li>\n<li>Order of first occurrences must be preserved</li>\n</ul>\n\nPro Tip: Use a set to track seen characters and build the result string using only new characters.',
    sampleTestCases: [
      { input: 'programming', expected: 'progamin' },
      { input: 'aabbcc', expected: 'abc' },
    ],
    testCases: [
      { input: 'a', expected: 'a' },
      { input: 'abcabc', expected: 'abc' },
      { input: 'zzzzzz', expected: 'z' },
      { input: 'banana', expected: 'ban' },
      { input: 'apple', expected: 'aple' },
      { input: 'xyzxyz', expected: 'xyz' },
      { input: 'aabbaa', expected: 'ab' },
      { input: 'abcdef', expected: 'abcdef' },
      { input: 'abcdabcdabcd', expected: 'abcd' },
      { input: 'aaabbbcccddd', expected: 'abcd' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you remove duplicates from a string without changing the order of the first appearances?',
    difficulty: 'easy',
    frequency: 96,
    tags: ['string', 'hashing', 'set'],
    companies: [
      { name: 'TCS', logoUrl: '' },
      { name: 'Infosys', logoUrl: '' },
      { name: 'Wipro', logoUrl: '' },
    ],
    hints: [
      'Use a set or boolean array to track visited characters.',
      "Append a character to result only if it's not seen before.",
      'Preserve the original order while removing duplicates.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const s = fs.readFileSync(0, "utf-8").trim();\n  console.log(removeDuplicates(s));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    s = input().strip()\n    print(removeDuplicates(s))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.next();\n    System.out.println(removeDuplicates(s));\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\n#include <string.h>\nvoid removeDuplicates(char* s);\nint main() {\n  char s[100001];\n  scanf("%s", s);\n  removeDuplicates(s);\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nstring removeDuplicates(string s);\nint main() {\n  string s;\n  cin >> s;\n  cout << removeDuplicates(s) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function removeDuplicates(s) {\n  // write code here\n  return s;\n}',
      },
      {
        language: 'python',
        code: 'def removeDuplicates(s):\n    # write code here\n    return s',
      },
      {
        language: 'java',
        code: 'public static String removeDuplicates(String s) {\n    // write code here\n    return s;\n}',
      },
      {
        language: 'c',
        code: 'void removeDuplicates(char* s) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'string removeDuplicates(string s) {\n    // write code here\n    return s;\n}',
      },
    ],
  },
  {
    title: 'Permutations of a String',
    slug: 'permutations-of-a-string',
    description:
      'Generate all unique permutations of a given string in lexicographical order.',
    problemStatement:
      'Given a string <code>s</code> of distinct lowercase characters, generate all its permutations in lexicographical order.\n\nEach permutation must be printed on a new line.\n\n<pre><code>Input:\nabc\nOutput:\nabc\nacb\nbac\nbca\ncab\ncba\n\nInput:\nab\nOutput:\nab\nba</code></pre>\n\n<ul>\n<li>1 ≤ |s| ≤ 8</li>\n<li>s contains distinct lowercase English letters only</li>\n<li>Output permutations in sorted order</li>\n</ul>\n\nPro Tip: Use backtracking with a visited array or recursive swaps to generate permutations. Sort the input first for lexicographical order.',
    sampleTestCases: [
      { input: 'abc', expected: 'abc\nacb\nbac\nbca\ncab\ncba' },
      { input: 'ab', expected: 'ab\nba' },
    ],
    testCases: [
      { input: 'a', expected: 'a' },
      { input: 'ab', expected: 'ab\nba' },
      { input: 'abc', expected: 'abc\nacb\nbac\nbca\ncab\ncba' },
      {
        input: 'abcd',
        expected:
          'abcd\nabdc\nacbd\nacdb\nadbc\nadcb\nbacd\nbadc\nbcad\nbcda\nbdac\nbdca\ncabd\ncadb\ncbad\ncbda\ncdab\ncdba\ndabc\ndacb\ndbac\ndbca\ndcab\ndcba',
      },
      { input: 'xy', expected: 'xy\nyx' },
      {
        input: 'wxyz',
        expected:
          'wxyz\nwxzy\nwyxz\nwyzx\nwzxy\nwzyx\nxwyz\nxwzy\nxywz\nxyzx\nxzwx\nxzyw\nywxz\nywzx\nyxwz\nyxzw\nyzwx\nyzxw\nzwxy\nzwyx\nzxwy\nzxyw\nzywx\nzyxw',
      },
      { input: 'lm', expected: 'lm\nml' },
      {
        input: 'efgh',
        expected:
          'efgh\nefhg\negfh\neghf\nehfg\nehgf\nf... (continues up to 24 lines)',
      },
      {
        input: 'abcf',
        expected:
          'abcf\nabfc\nacbf\nacfb\nafbc\nafcb\nbacf\nbafc\nbcaf\nbcfa\nbfac\nbfca\ncabf\ncafb\ncbaf\ncbfa\ncfab\ncfba\nfabc\nfacb\nfbac\nfbca\nfcab\nfcba',
      },
      { input: 'z', expected: 'z' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Given a short string with distinct characters, can you generate all its permutations in lexicographic order?',
    difficulty: 'medium',
    frequency: 91,
    tags: ['recursion', 'backtracking', 'permutation'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use recursion and swap characters at each index.',
      'Sort the input first to generate permutations in lexicographical order.',
      'Backtrack after exploring each recursive call.',
    ],
    optimalComplexity: {
      time: 'O(n * n!)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const s = fs.readFileSync(0, "utf-8").trim();\n  const result = permutations(s);\n  for (const str of result) console.log(str);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    s = input().strip()\n    result = permutations(s)\n    for p in result:\n        print(p)',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.next();\n    List<String> result = permutations(s);\n    for (String str : result) System.out.println(str);\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nvoid permutations(char* s);\nint main() {\n  char s[10];\n  scanf("%s", s);\n  permutations(s);\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nvector<string> permutations(string s);\nint main() {\n  string s;\n  cin >> s;\n  vector<string> result = permutations(s);\n  for (string &str : result) cout << str << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function permutations(s) {\n  // write code here\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def permutations(s):\n    # write code here\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<String> permutations(String s) {\n    // write code here\n    return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void permutations(char* s) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<string> permutations(string s) {\n    // write code here\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Subsequence Generator',
    slug: 'subsequence-generator',
    description: 'Generate all subsequences of a given string using recursion.',
    problemStatement:
      'Given a string <code>s</code>, generate all possible subsequences of the string using recursion.\n\nA subsequence is a sequence that can be derived by deleting some or no elements of the string without changing the order of the remaining characters.\n\nReturn or print all subsequences in any order (including the empty subsequence).\n\n<pre><code>Input:\nab\nOutput:\n""\na\nb\nab\n\nInput:\nabc\nOutput:\n""\na\nb\nc\nab\nac\nbc\nabc</code></pre>\n\n<ul>\n<li>1 ≤ |s| ≤ 15</li>\n<li>s contains only lowercase English letters</li>\n<li>2<sup>|s|</sup> total subsequences including empty string</li>\n</ul>\n\nPro Tip: At each step, choose to include or exclude the current character. This leads to a binary tree of decisions.',
    sampleTestCases: [
      { input: 'ab', expected: '""\na\nb\nab' },
      { input: 'abc', expected: '""\na\nb\nc\nab\nac\nbc\nabc' },
    ],
    testCases: [
      { input: 'a', expected: '""\na' },
      { input: 'ab', expected: '""\na\nb\nab' },
      { input: 'abc', expected: '""\na\nb\nc\nab\nac\nbc\nabc' },
      {
        input: 'abcd',
        expected:
          '""\na\nb\nc\nd\nab\nac\nad\nbc\nbd\ncd\nabc\nabd\nacd\nbcd\nabcd',
      },
      { input: 'xy', expected: '""\nx\ny\nxy' },
      { input: 'aaa', expected: '""\na\na\na\naa\naa\naaa' },
      { input: 'z', expected: '""\nz' },
      { input: 'wxyz', expected: 'includes 16 lines' },
      { input: 'pq', expected: '""\np\nq\npq' },
      { input: 'abcd', expected: 'includes 16 lines' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you recursively generate all subsequences of a given string?',
    difficulty: 'medium',
    frequency: 90,
    tags: ['recursion', 'backtracking', 'string', 'subset'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'At each index, include the character or skip it.',
      'Use a helper function to track the current subsequence.',
      'Base case is when index equals string length.',
    ],
    optimalComplexity: {
      time: 'O(2^n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const s = fs.readFileSync(0, "utf-8").trim();\n  const result = subsequences(s);\n  for (const str of result) console.log(str);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    s = input().strip()\n    result = subsequences(s)\n    for p in result:\n        print(p)',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.next();\n    List<String> result = subsequences(s);\n    for (String str : result) System.out.println(str);\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nvoid subsequences(char* s);\nint main() {\n  char s[20];\n  scanf("%s", s);\n  subsequences(s);\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nvector<string> subsequences(string s);\nint main() {\n  string s;\n  cin >> s;\n  vector<string> result = subsequences(s);\n  for (string &str : result) cout << str << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function subsequences(s) {\n  // write code here\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def subsequences(s):\n    # write code here\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<String> subsequences(String s) {\n    // write code here\n    return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void subsequences(char* s) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<string> subsequences(string s) {\n    // write code here\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Count Palindromic Subsequences in a String',
    slug: 'count-palindromic-subsequences',
    description:
      'Count all palindromic subsequences (not necessarily distinct) in a string using dynamic programming.',
    problemStatement:
      'Given a string `s`, return the total number of palindromic subsequences present in `s`. Subsequences need not be distinct (i.e., duplicates are counted). Since the number might be large, return the count modulo 10⁹ + 7.\n\nA subsequence is obtained by deleting zero or more characters without changing the order, and is considered palindromic if it reads the same backward as forward.\n\n<pre><code>Input:\naab\nOutput:\n4\n\nExplanation:\nThe palindromic subsequences are "a" (position 1), "a" (pos 2), "b" (pos 3), and "aa".</code></pre>\n\n<ul>\n<li>1 ≤ |s| ≤ 1000</li>\n<li>s consists of lowercase English letters</li>\n<li>Return the answer modulo 10⁹ + 7</li>\n</ul>\n\nPro Tip: Think recursively — for substring s[i..j], if s[i] == s[j], count includes all palindromic subsequences within and spanning these characters; else subtract the overlapping count. Use memoization or bottom-up DP for efficiency.',
    sampleTestCases: [
      { input: 'aab', expected: '4' },
      { input: 'aaa', expected: '7' },
    ],
    testCases: [
      { input: 'a', expected: '1' },
      { input: 'ab', expected: '2' },
      { input: 'aba', expected: '4' },
      { input: 'aaa', expected: '7' },
      { input: 'aab', expected: '4' },
      { input: 'abca', expected: '5' },
      { input: 'abcd', expected: '4' },
      { input: 'aaaab', expected: '15' },
      { input: 'ababa', expected: '13' },
      { input: 'racecar', expected: '??' /* large */ },
    ],
    topics: ['dynamic programming', 'recursion', 'string'],
    interviewExcerpt:
      'A classic DP problem: count how many palindromic subsequences a string contains. Use overlapping subproblems effectively!',
    difficulty: 'medium',
    frequency: 85,
    tags: ['recursion', 'dp', 'substring', 'modular arithmetic'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Define dp(i,j) as count of palindromic subsequences in s[i..j].',
      'If s[i] == s[j], dp(i,j) = dp(i+1,j) + dp(i,j-1) + 1.',
      'Else, dp(i,j) = dp(i+1,j) + dp(i,j-1) - dp(i+1,j-1).',
      'Use modulo at each step to manage large numbers.',
    ],
    optimalComplexity: {
      time: 'O(n²)',
      space: 'O(n²)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const MOD = 1e9+7;\nfunction countPS(s) {\n  const n = s.length;\n  const dp = Array.from({ length: n }, () => Array(n).fill(0));\n  for (let i = n - 1; i >= 0; i--) {\n    dp[i][i] = 1;\n    for (let j = i + 1; j < n; j++) {\n      if (s[i] === s[j]) {\n        dp[i][j] = (dp[i+1][j] + dp[i][j-1] + 1) % MOD;\n      } else {\n        dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] + MOD) % MOD;\n      }\n    }\n  }\n  return dp[0][n-1];\n}',
      },
      {
        language: 'python',
        code: 'MOD = 10**9+7\n\ndef countPS(s):\n    n = len(s)\n    dp = [[0]*n for _ in range(n)]\n    for i in range(n-1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i+1, n):\n            if s[i] == s[j]:\n                dp[i][j] = (dp[i+1][j] + dp[i][j-1] + 1) % MOD\n            else:\n                dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] + MOD) % MOD\n    return dp[0][n-1]\n',
      },
      {
        language: 'java',
        code: 'class Solution {\n    static final int MOD = 1000000007;\n    public long countPS(String s) {\n        int n = s.length();\n        long[][] dp = new long[n][n];\n        for (int i = n - 1; i >= 0; i--) {\n            dp[i][i] = 1;\n            for (int j = i + 1; j < n; j++) {\n                if (s.charAt(i) == s.charAt(j)) {\n                    dp[i][j] = (dp[i+1][j] + dp[i][j-1] + 1) % MOD;\n                } else {\n                    dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] + MOD) % MOD;\n                }\n            }\n        }\n        return dp[0][n-1];\n    }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\n#include <string.h>\n#define MOD 1000000007\nlong countPS(char* s) {\n    int n = strlen(s);\n    long dp[n][n];\n    memset(dp, 0, sizeof(dp));\n    for (int i = n - 1; i >= 0; i--) {\n        dp[i][i] = 1;\n        for (int j = i + 1; j < n; j++) {\n            if (s[i] == s[j])\n                dp[i][j] = (dp[i+1][j] + dp[i][j-1] + 1) % MOD;\n            else\n                dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] + MOD) % MOD;\n        }\n    }\n    return dp[0][n-1];\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1000000007;\nlong countPS(const string &s) {\n    int n = s.size();\n    vector<vector<long>> dp(n, vector<long>(n));\n    for(int i = n - 1; i >= 0; --i) {\n        dp[i][i] = 1;\n        for(int j = i + 1; j < n; ++j) {\n            if(s[i] == s[j]) dp[i][j] = (dp[i+1][j] + dp[i][j-1] + 1) % MOD;\n            else dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] + MOD) % MOD;\n        }\n    }\n    return dp[0][n-1];\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function countPS(s) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def countPS(s):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static long countPS(String s) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'c',
        code: 'long countPS(char* s) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'long countPS(const string &s) {\n    // write code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Generate All Balanced Parentheses',
    slug: 'generate-all-balanced-parentheses',
    description:
      'Generate all combinations of balanced parentheses for a given number of pairs.',
    problemStatement:
      'Given an integer <code>n</code>, generate all combinations of balanced parentheses consisting of <code>n</code> pairs.\n\nEach combination must contain exactly <code>n</code> opening and <code>n</code> closing parentheses in a valid order.\n\n<pre><code>Input:\n3\nOutput:\n((()))\n(()())\n(())()\n()(())\n()()()</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 10</li>\n<li>Each output should be a string of length 2n</li>\n<li>Output the results in any order</li>\n</ul>\n\nPro Tip: Use recursion and backtracking. Track open and close parentheses used so far to ensure validity.',
    sampleTestCases: [
      { input: '2', expected: '(())\n()()' },
      { input: '3', expected: '((()))\n(()())\n(())()\n()(())\n()()()' },
    ],
    testCases: [
      { input: '1', expected: '()' },
      { input: '2', expected: '(())\n()()' },
      { input: '3', expected: '((()))\n(()())\n(())()\n()(())\n()()()' },
      {
        input: '4',
        expected:
          '(((())))\n((()()))\n((())())\n((()))()\n(()(()))\n(()()())\n(()())()\n(())(())\n(())()()\n()((()))\n()(()())\n()(())()\n()()(())\n()()()()',
      },
      { input: '5', expected: 'contains 42 lines' },
      { input: '6', expected: 'contains 132 lines' },
      { input: '7', expected: 'contains 429 lines' },
      { input: '8', expected: 'contains 1430 lines' },
      { input: '9', expected: 'contains 4862 lines' },
      { input: '10', expected: 'contains 16796 lines' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'This is a classic recursion and backtracking problem. Can you generate all well-formed parentheses combinations for given pairs?',
    difficulty: 'medium',
    frequency: 97,
    tags: ['recursion', 'backtracking', 'string', 'combinatorics'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Track the count of open and close parentheses placed so far.',
      "Only add a '(' if open < n, and ')' if close < open.",
      'Use a helper function for recursive exploration.',
    ],
    optimalComplexity: {
      time: 'O(2^n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const n = parseInt(fs.readFileSync(0, "utf-8").trim());\n  const result = generateParentheses(n);\n  for (const str of result) console.log(str);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    result = generateParentheses(n)\n    for p in result:\n        print(p)',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    List<String> result = generateParentheses(n);\n    for (String str : result) System.out.println(str);\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nvoid generateParentheses(int n);\nint main() {\n  int n;\n  scanf("%d", &n);\n  generateParentheses(n);\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nvector<string> generateParentheses(int n);\nint main() {\n  int n;\n  cin >> n;\n  vector<string> result = generateParentheses(n);\n  for (string &str : result) cout << str << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function generateParentheses(n) {\n  // write code here\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def generateParentheses(n):\n    # write code here\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<String> generateParentheses(int n) {\n    // write code here\n    return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void generateParentheses(int n) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<string> generateParentheses(int n) {\n    // write code here\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Palindrome Partitioning',
    slug: 'palindrome-partitioning',
    description: 'Generate all possible palindrome partitioning of a string.',
    problemStatement:
      'Given a string <code>s</code>, partition it such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of <code>s</code>.\n\n<pre><code>Input:\naab\nOutput:\n[ ["a","a","b"], ["aa","b"] ]</code></pre>\n\nExplanation:\nYou can partition "aab" as ["a","a","b"] or ["aa","b"], where each partition consists entirely of palindromic substrings.\n\n<ul>\n<li>1 ≤ |s| ≤ 16</li>\n<li>s consists of lowercase English letters only</li>\n<li>Return partitions in any order</li>\n</ul>\n\nPro Tip: Use a backtracking (DFS) approach with pruning via palindrome checking. Precompute a DP table to speed up checks effectively.</p>',
    sampleTestCases: [
      { input: 'aab', expected: '[["a","a","b"],["aa","b"]]' },
      { input: 'a', expected: '[["a"]]' },
    ],
    testCases: [
      { input: 'a', expected: '[["a"]]' },
      { input: 'aa', expected: '[["a","a"],["aa"]]' },
      { input: 'aba', expected: '[["a","b","a"],["aba"]]' },
      { input: 'aab', expected: '[["a","a","b"],["aa","b"]]' },
      {
        input: 'aaba',
        expected: '[["a","a","b","a"],["aa","b","a"],["a","aba"]]',
      },
      {
        input: 'abba',
        expected: '[["a","b","b","a"],["a","bb","a"],["abba"]]',
      },
      { input: 'racecar', expected: 'many partitions—varies' },
      { input: 'abc', expected: '[["a","b","c"]]' },
    ],
    topics: ['backtracking', 'dynamic programming', 'string', 'dfs'],
    interviewExcerpt:
      'Classic recursion + DP problem—can you generate all palindrome-only partitions of a string efficiently?',
    difficulty: 'medium',
    frequency: 95,
    tags: ['backtracking', 'dfs', 'palindrome-check', 'dp'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use DFS to explore partitions: pick every prefix that’s a palindrome, and recurse on the rest.',
      "Use a 2D DP table 'isPal[i][j]' to memoize whether s[i..j] is a palindrome.",
      'The recursion ends when your start index reaches the end—add the current partition to results.',
    ],
    optimalComplexity: {
      time: 'O(2^n * n)',
      space: 'O(n^2)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const s = fs.readFileSync(0, "utf-8").trim();\n  const result = partition(s);\n  console.log(JSON.stringify(result));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    s = input().strip()\n    result = partition(s)\n    print(result)',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.next();\n    List<List<String>> res = partition(s);\n    System.out.println(res);\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nvoid partition(char* s);\nint main() {\n  char s[20]; scanf("%s", s);\n  partition(s);\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nvector<vector<string>> partition(const string &s);\nint main() {\n  string s; cin >> s;\n  auto res = partition(s);\n  for(auto &part: res) {\n    for(auto &str: part) cout << str << " ";\n    cout << endl;\n  }\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function partition(s) {\n  // write code here\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def partition(s):\n    # write code here\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<List<String>> partition(String s) {\n    // write code here\n    return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void partition(char* s) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<vector<string>> partition(const string &s) {\n    // write code here\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Palindrome Partitioning',
    slug: 'palindrome-partitioning',
    description: 'Generate all possible palindrome partitioning of a string.',
    problemStatement:
      'Given a string <code>s</code>, partition it such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of <code>s</code>.\n\n<pre><code>Input:\naab\nOutput:\n[ ["a","a","b"], ["aa","b"] ]</code></pre>\n\nExplanation:\nYou can partition "aab" as ["a","a","b"] or ["aa","b"], where each partition consists entirely of palindromic substrings.\n\n<ul>\n<li>1 ≤ |s| ≤ 16</li>\n<li>s consists of lowercase English letters only</li>\n<li>Return partitions in any order</li>\n</ul>\n\nPro Tip: Use a backtracking (DFS) approach with pruning via palindrome checking. Precompute a DP table to speed up checks effectively.</p>',
    sampleTestCases: [
      { input: 'aab', expected: '[["a","a","b"],["aa","b"]]' },
      { input: 'a', expected: '[["a"]]' },
    ],
    testCases: [
      { input: 'a', expected: '[["a"]]' },
      { input: 'aa', expected: '[["a","a"],["aa"]]' },
      { input: 'aba', expected: '[["a","b","a"],["aba"]]' },
      { input: 'aab', expected: '[["a","a","b"],["aa","b"]]' },
      {
        input: 'aaba',
        expected: '[["a","a","b","a"],["aa","b","a"],["a","aba"]]',
      },
      {
        input: 'abba',
        expected: '[["a","b","b","a"],["a","bb","a"],["abba"]]',
      },
      { input: 'racecar', expected: 'many partitions—varies' },
      { input: 'abc', expected: '[["a","b","c"]]' },
    ],
    topics: ['backtracking', 'dynamic programming', 'string', 'dfs'],
    interviewExcerpt:
      'Classic recursion + DP problem—can you generate all palindrome-only partitions of a string efficiently?',
    difficulty: 'medium',
    frequency: 95,
    tags: ['backtracking', 'dfs', 'palindrome-check', 'dp'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use DFS to explore partitions: pick every prefix that’s a palindrome, and recurse on the rest.',
      "Use a 2D DP table 'isPal[i][j]' to memoize whether s[i..j] is a palindrome.",
      'The recursion ends when your start index reaches the end—add the current partition to results.',
    ],
    optimalComplexity: {
      time: 'O(2^n * n)',
      space: 'O(n^2)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const s = fs.readFileSync(0, "utf-8").trim();\n  const result = partition(s);\n  console.log(JSON.stringify(result));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    s = input().strip()\n    result = partition(s)\n    print(result)',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.next();\n    List<List<String>> res = partition(s);\n    System.out.println(res);\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nvoid partition(char* s);\nint main() {\n  char s[20]; scanf("%s", s);\n  partition(s);\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nvector<vector<string>> partition(const string &s);\nint main() {\n  string s; cin >> s;\n  auto res = partition(s);\n  for(auto &part: res) {\n    for(auto &str: part) cout << str << " ";\n    cout << endl;\n  }\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function partition(s) {\n  // write code here\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def partition(s):\n    # write code here\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<List<String>> partition(String s) {\n    // write code here\n    return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void partition(char* s) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<vector<string>> partition(const string &s) {\n    // write code here\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Longest Palindromic Subsequence',
    slug: 'longest-palindromic-subsequence',
    description:
      'Find the length of the longest palindromic subsequence using recursion or dynamic programming.',
    problemStatement:
      'Given a string <code>s</code>, return the length of the longest palindromic subsequence in it. A subsequence is a sequence that can be derived from the string by deleting some or no characters without changing the order of the remaining characters.\n\nUse a recursive or dynamic programming approach to solve it.\n\n<pre><code>Input:\nbbabab\nOutput:\n5\n\nExplanation:\nThe longest palindromic subsequence is "bbabb".</code></pre>\n\n<ul>\n<li>1 ≤ |s| ≤ 1000</li>\n<li>s consists of lowercase English letters only</li>\n</ul>\n\nPro Tip: Let <code>dp(i, j)</code> represent the length of the longest palindromic subsequence in <code>s[i..j]</code>. Use memoization or bottom-up DP to optimize.',
    sampleTestCases: [
      { input: 'bbabab', expected: '5' },
      { input: 'cbbd', expected: '2' },
    ],
    testCases: [
      { input: 'a', expected: '1' },
      { input: 'aa', expected: '2' },
      { input: 'ab', expected: '1' },
      { input: 'aba', expected: '3' },
      { input: 'racecar', expected: '7' },
      { input: 'cbbd', expected: '2' },
      { input: 'bbbab', expected: '4' },
      { input: 'abcdef', expected: '1' },
      { input: 'abcba', expected: '5' },
      { input: 'abacdfgdcaba', expected: '5' },
    ],
    topics: ['dynamic programming', 'recursion', 'string'],
    interviewExcerpt:
      'Classic DP problem: Can you recursively find the longest palindromic subsequence in a string?',
    difficulty: 'medium',
    frequency: 94,
    tags: ['dp', 'recursion', 'palindrome'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Meta', logoUrl: '' },
    ],
    hints: [
      'Use a 2D memoization table to store results of subproblems.',
      'If s[i] == s[j], then count 2 + LPS(i+1, j-1).',
      'Else take max of LPS(i+1, j) and LPS(i, j-1).',
    ],
    optimalComplexity: {
      time: 'O(n^2)',
      space: 'O(n^2)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const s = fs.readFileSync(0, "utf-8").trim();\n  console.log(longestPalindromeSubseq(s));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    s = input().strip()\n    print(longestPalindromeSubseq(s))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.next();\n    System.out.println(longestPalindromeSubseq(s));\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\n#include <string.h>\nint longestPalindromeSubseq(char* s);\nint main() {\n  char s[1001];\n  scanf("%s", s);\n  printf("%d\\n", longestPalindromeSubseq(s));\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\nusing namespace std;\nint longestPalindromeSubseq(string s);\nint main() {\n  string s;\n  cin >> s;\n  cout << longestPalindromeSubseq(s) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function longestPalindromeSubseq(s) {\n  // write code here\n  return 0;\n}',
      },
      {
        language: 'python',
        code: 'def longestPalindromeSubseq(s):\n    # write code here\n    return 0',
      },
      {
        language: 'java',
        code: 'public static int longestPalindromeSubseq(String s) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'c',
        code: 'int longestPalindromeSubseq(char* s) {\n    // write code here\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: 'int longestPalindromeSubseq(string s) {\n    // write code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Scramble String',
    slug: 'scramble-string',
    description:
      'Determine whether one string is a scrambled version of another using recursive splitting and swapping.',
    problemStatement:
      'Given two strings `s1` and `s2` of the same length, return `true` if `s2` is a scrambled string of `s1`, otherwise return `false`.\n\nA scrambled string is formed by recursively splitting the string into two non-empty substrings and choosing to either swap them or not, then applying the same process recursively to each part. You need to decide if `s2` can result from such a process starting from `s1`.\n\n<pre><code>Input:\ns1 = "great", s2 = "rgeat"\nOutput: true  // “great” can be split into "gr" + "eat" and then substrings are scrambled to form "rgeat".\n\nInput:\ns1 = "abcde", s2 = "caebd"\nOutput: false</code></pre>',
    sampleTestCases: [
      { input: 'great, rgeat', expected: 'true' },
      { input: 'abcde, caebd', expected: 'false' },
    ],
    testCases: [
      { input: 'a, a', expected: 'true' },
      { input: 'ab, ba', expected: 'true' },
      { input: 'ab, ab', expected: 'true' },
      { input: 'great, rgeat', expected: 'true' },
      { input: 'great, rgtae', expected: 'true' },
      { input: 'abcd, bdac', expected: 'false' },
      { input: 'coder, ocder', expected: 'true' },
      { input: 'aaab, baa a', expected: 'true' },
      { input: 'abc, bca', expected: 'false' },
      { input: 'abcdefghijkl, abcdlkjihgf', expected: 'false' },
    ],
    topics: [
      'recursion',
      'divide-and-conquer',
      'dynamic programming',
      'memoization',
      'string',
    ],
    interviewExcerpt:
      'Given two strings, can you determine if one is a scrambled version of the other through recursive splitting and swapping? Use memoized recursion to optimize.',
    difficulty: 'hard',
    frequency: 85,
    tags: ['recursion', 'memoization', 'dfs', 'string', 'dynamic programming'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Base cases: check equality of the strings and character count (anagram check).',
      "At each step, try all possible splits and check both 'swap' and 'no-swap' scenarios.",
      'Use memoization to cache results for each pair (s1, s2) to avoid exponential recomputation.',
    ],
    optimalComplexity: {
      time: 'O(n³)',
      space: 'O(n³)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "function isScramble(s1, s2, memo = {}) {\n  const key = s1 + '|' + s2;\n  if (memo[key] !== undefined) return memo[key];\n  if (s1 === s2) return memo[key] = true;\n  if ([...s1].sort().join() !== [...s2].sort().join()) return memo[key] = false;\n  const n = s1.length;\n  for (let i = 1; i < n; i++) {\n    if (\n      (isScramble(s1.slice(0, i), s2.slice(0, i), memo) && isScramble(s1.slice(i), s2.slice(i), memo)) ||\n      (isScramble(s1.slice(0, i), s2.slice(n - i), memo) && isScramble(s1.slice(i), s2.slice(0, n - i), memo))\n    ) {\n      return memo[key] = true;\n    }\n  }\n  return memo[key] = false;\n}",
      },
      {
        language: 'python',
        code: 'from functools import lru_cache\n\ndef is_scramble(s1, s2):\n    @lru_cache(None)\n    def dfs(a, b):\n        if a == b:\n            return True\n        if sorted(a) != sorted(b):\n            return False\n        n = len(a)\n        for i in range(1, n):\n            if (dfs(a[:i], b[:i]) and dfs(a[i:], b[i:])) or (dfs(a[:i], b[-i:]) and dfs(a[i:], b[:-i])):\n                return True\n        return False\n    return dfs(s1, s2)',
      },
      {
        language: 'java',
        code: 'class Solution {\n  Map<String, Boolean> memo = new HashMap<>();\n  public boolean isScramble(String s1, String s2) {\n    String key = s1 + "|" + s2;\n    if (memo.containsKey(key)) return memo.get(key);\n    if (s1.equals(s2)) return true;\n    char[] c1 = s1.toCharArray(), c2 = s2.toCharArray();\n    Arrays.sort(c1); Arrays.sort(c2);\n    if (!Arrays.equals(c1, c2)) return memo.put(key, false);\n    int n = s1.length();\n    for (int i = 1; i < n; i++) {\n      if ((isScramble(s1.substring(0, i), s2.substring(0, i)) &&\n           isScramble(s1.substring(i), s2.substring(i))) ||\n          (isScramble(s1.substring(0, i), s2.substring(n - i)) &&\n           isScramble(s1.substring(i), s2.substring(0, n - i)))) {\n        return memo.put(key, true);\n      }\n    }\n    return memo.put(key, false);\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <unordered_map>\nstring join_key(const string &a, const string &b) { return a + "|" + b; }\nbool isScramble(const string &s1, const string &s2, unordered_map<string,bool> &memo) {\n  string key = join_key(s1, s2);\n  if (memo.count(key)) return memo[key];\n  if (s1 == s2) return memo[key] = true;\n  string t1 = s1, t2 = s2;\n  sort(t1.begin(), t1.end()); sort(t2.begin(), t2.end());\n  if (t1 != t2) return memo[key] = false;\n  int n = s1.size();\n  for (int i = 1; i < n; i++) {\n    if ((isScramble(s1.substr(0, i), s2.substr(0, i), memo) && isScramble(s1.substr(i), s2.substr(i), memo)) ||\n        (isScramble(s1.substr(0, i), s2.substr(n - i), memo) && isScramble(s1.substr(i), s2.substr(0, n - i), memo)))\n      return memo[key] = true;\n  }\n  return memo[key] = false;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function isScramble(s1, s2) {\n  // write memoized recursion here\n}',
      },
      {
        language: 'python',
        code: 'def is_scramble(s1, s2):\n    # write memoized recursion here\n    pass',
      },
      {
        language: 'java',
        code: 'public boolean isScramble(String s1, String s2) {\n    // write memoized recursion here\n}',
      },
      {
        language: 'cpp',
        code: 'bool isScramble(const string &s1, const string &s2) {\n    // write memoized recursion here\n}',
      },
    ],
  },
  {
    title: 'Generate All Subsets (Power Set)',
    slug: 'generate-all-subsets-power-set',
    description:
      'Generate all possible subsets (the power set) of a given array of distinct integers.',
    problemStatement:
      'Given an array <code>nums</code> of distinct integers, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the subsets in any order.\n\n<pre><code>Input:\nnums = [1,2,3]\nOutput:\n[ [], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3] ]</code></pre>\n\n<ul>\n<li>0 ≤ nums.length ≤ 10</li>\n<li>-10 ≤ nums[i] ≤ 10</li>\n<li>All elements are distinct</li>\n</ul>\n\nPro Tip: Use recursion and backtracking. At each step, choose to include or exclude the current element.',
    sampleTestCases: [
      {
        input: '3\n1 2 3',
        expected: '[] [3] [2] [2,3] [1] [1,3] [1,2] [1,2,3]',
      },
      { input: '2\n0 1', expected: '[] [1] [0] [0,1]' },
    ],
    testCases: [
      { input: '0\n', expected: '[]' },
      { input: '1\n5', expected: '[] [5]' },
      { input: '2\n1 2', expected: '[] [2] [1] [1,2]' },
      {
        input: '3\n1 2 3',
        expected: '[] [3] [2] [2,3] [1] [1,3] [1,2] [1,2,3]',
      },
      { input: '4\n1 2 3 4', expected: '16 subsets' },
      { input: '5\n5 6 7 8 9', expected: '32 subsets' },
      { input: '6\n-1 0 1 2 3 4', expected: '64 subsets' },
      { input: '7\n1 2 3 4 5 6 7', expected: '128 subsets' },
      { input: '8\n1 2 3 4 5 6 7 8', expected: '256 subsets' },
      { input: '9\n1 2 3 4 5 6 7 8 9', expected: '512 subsets' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you generate all subsets (also called the power set) of a given list of distinct integers?',
    difficulty: 'medium',
    frequency: 98,
    tags: ['backtracking', 'recursion', 'bitmask', 'array', 'subset'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Meta', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use recursion: at each element, either include or exclude it in the current subset.',
      'The total number of subsets is 2^n, where n is the size of the input list.',
      'Backtracking helps build and explore subset paths efficiently.',
    ],
    optimalComplexity: {
      time: 'O(2^n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const nums = input[1].split(" ").map(Number);\n  const result = subsets(nums);\n  for (const subset of result) {\n    console.log(`[${subset.join(",")}]`);\n  }\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    nums = list(map(int, input().split()))\n    result = subsets(nums)\n    for subset in result:\n        print(subset)',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int[] nums = new int[n];\n    for (int i = 0; i < n; i++) nums[i] = sc.nextInt();\n    List<List<Integer>> res = subsets(nums);\n    for (List<Integer> list : res) System.out.println(list);\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nvoid subsets(int* arr, int n);\nint main() {\n  int n; scanf("%d", &n);\n  int arr[n];\n  for (int i = 0; i < n; i++) scanf("%d", &arr[i]);\n  subsets(arr, n);\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nvector<vector<int>> subsets(vector<int> &nums);\nint main() {\n  int n; cin >> n;\n  vector<int> nums(n);\n  for (int i = 0; i < n; i++) cin >> nums[i];\n  auto res = subsets(nums);\n  for (auto &sub : res) {\n    cout << "[";\n    for (int i = 0; i < sub.size(); ++i) {\n      cout << sub[i] << (i + 1 < sub.size() ? "," : "");\n    }\n    cout << "]\\n";\n  }\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function subsets(nums) {\n  // write code here\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def subsets(nums):\n    # write code here\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<List<Integer>> subsets(int[] nums) {\n    // write code here\n    return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void subsets(int* arr, int n) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<vector<int>> subsets(vector<int> &nums) {\n    // write code here\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Subsets with Duplicates (Unique Power Set)',
    slug: 'subsets-with-duplicates',
    description:
      'Generate all unique subsets from an integer array that may contain duplicates.',
    problemStatement:
      'Given an integer array <code>nums</code> that may contain duplicates, return all possible subsets (the power set) without duplicate subsets.\n\nEach subset should be valid in any order, but no duplicate subset is allowed.\n\n<pre><code>Input:\nnums = [1,2,2]\nOutput:\n[[], [1], [2], [1,2], [2,2], [1,2,2]]</code></pre>',
    sampleTestCases: [
      { input: '[1,2,2]', expected: '[[],[1],[2],[1,2],[2,2],[1,2,2]]' },
      { input: '[0]', expected: '[[],[0]]' },
    ],
    testCases: [
      { input: '[]', expected: '[[]]' },
      { input: '[1]', expected: '[[],[1]]' },
      { input: '[1,2,2]', expected: '[[],[1],[2],[1,2],[2,2],[1,2,2]]' },
      { input: '[2,2,2]', expected: '[[],[2],[2,2],[2,2,2]]' },
      { input: '[1,2,2,3]', expected: 'unique subsets, no duplicates' },
      { input: '[4,4,4,4]', expected: '[[],[4],[4,4],[4,4,4],[4,4,4,4]]' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Use recursion + backtracking and skip duplicates to generate all unique subsets of an array with duplicates.',
    difficulty: 'medium',
    frequency: 90,
    tags: ['backtracking', 'recursion', 'sorting', 'duplicate-handling'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Sort the array first so duplicates are adjacent.',
      'Use backtracking to explore inclusion/exclusion of each element.',
      'Skip duplicates by checking if current element is same as previous and not on the same recursion level.',
    ],
    optimalComplexity: {
      time: 'O(2ⁿ)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = JSON.parse(fs.readFileSync(0, "utf-8"));\n  const result = subsetsWithDup(input);\n  console.log(JSON.stringify(result));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import json\n    nums = json.loads(input())\n    result = subsetsWithDup(nums)\n    print(result)',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String line = sc.nextLine();\n    String[] parts = line.replaceAll("[\\[\\] ]", "").split(",");\n    int[] nums = Arrays.stream(parts).filter(p -> !p.isEmpty()).mapToInt(Integer::parseInt).toArray();\n    List<List<Integer>> result = subsetsWithDup(nums);\n    System.out.println(result);\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvector<vector<int>> subsetsWithDup(vector<int> &nums);\nint main() {\n  string line;\n  getline(cin, line);\n  vector<int> nums;\n  size_t i = 0;\n  while (i < line.size()) {\n    if (isdigit(line[i]) || line[i] == \'-\') {\n      int start = i;\n      while (i < line.size() && (isdigit(line[i]) || line[i] == \'-\')) i++;\n      nums.push_back(stoi(line.substr(start, i - start)));\n    } else i++;\n  }\n  auto res = subsetsWithDup(nums);\n  for (auto &subset : res) {\n    cout << "[";\n    for (int j = 0; j < subset.size(); ++j) cout << subset[j] << (j + 1 < subset.size() ? "," : "");\n    cout << "]\\n";\n  }\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function subsetsWithDup(nums) {\n  // sort nums and implement backtracking\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def subsetsWithDup(nums):\n    # sort nums and implement dfs\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<List<Integer>> subsetsWithDup(int[] nums) {\n    // sort and use backtracking to generate unique subsets\n    return new ArrayList<>();\n}',
      },
      {
        language: 'cpp',
        code: 'vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n    // sort and dfs with duplicate check\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Generate Binary Strings without Consecutive 1s',
    slug: 'generate-binary-strings-without-consecutive-1s',
    description:
      'Generate all binary strings of length n such that no two consecutive 1s appear.',
    problemStatement:
      "Given a number <code>n</code>, generate all binary strings of length <code>n</code> such that there are no consecutive 1s in the string.\n\nReturn the binary strings in any order.\n\n<pre><code>Input:\nn = 3\nOutput:\n000\n001\n010\n100\n101</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 15</li>\n</ul>\n\nPro Tip: Use recursion to add either '0' or '1' at each step, but only allow '1' if the last character was not also '1'.",
    sampleTestCases: [
      { input: '2', expected: '00\n01\n10' },
      { input: '3', expected: '000\n001\n010\n100\n101' },
    ],
    testCases: [
      { input: '1', expected: '0\n1' },
      { input: '2', expected: '00\n01\n10' },
      { input: '3', expected: '000\n001\n010\n100\n101' },
      {
        input: '4',
        expected: '0000\n0001\n0010\n0100\n0101\n1000\n1001\n1010',
      },
      { input: '5', expected: '13 combinations' },
      { input: '6', expected: '21 combinations' },
      { input: '7', expected: '34 combinations' },
      { input: '8', expected: '55 combinations' },
    ],
    topics: ['recursion', 'backtracking', 'binary', 'string'],
    interviewExcerpt:
      'Can you generate all binary strings of a given length such that no two 1s appear consecutively?',
    difficulty: 'medium',
    frequency: 83,
    tags: ['recursion', 'binary', 'string', 'backtracking'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'TCS', logoUrl: '' },
      { name: 'Infosys', logoUrl: '' },
    ],
    hints: [
      'Use recursion to build the string character by character.',
      "Only add '1' if the previous character is not '1'.",
      'At each recursive call, track the current string and the last character used.',
    ],
    optimalComplexity: {
      time: 'O(2^n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const n = parseInt(fs.readFileSync(0, "utf-8"));\n  const res = generateBinary(n);\n  for (const s of res) console.log(s);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    n = int(input())\n    res = generateBinary(n)\n    for r in res:\n        print(r)',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    List<String> res = generateBinary(n);\n    for (String s : res) System.out.println(s);\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\nusing namespace std;\nvector<string> generateBinary(int n);\nint main() {\n  int n;\n  cin >> n;\n  auto res = generateBinary(n);\n  for (auto &s : res) cout << s << "\\n";\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function generateBinary(n) {\n  // backtracking to generate binary strings\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def generateBinary(n):\n    # backtracking with no consecutive 1s\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<String> generateBinary(int n) {\n    // backtracking to generate valid binary strings\n    return new ArrayList<>();\n}',
      },
      {
        language: 'cpp',
        code: 'vector<string> generateBinary(int n) {\n    // backtracking to generate binary strings without consecutive 1s\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Partition Array into Two Equal Subsets',
    slug: 'partition-array-into-two-equal-subsets',
    description:
      'Determine whether the given array can be partitioned into two subsets with equal sum.',
    problemStatement:
      'Given an array of positive integers `nums`, determine if you can partition it into two subsets such that the sums of the subsets are equal.\n\nReturn `true` if such a partition exists, otherwise `false`.\n\n<pre><code>Input:\nnums = [1, 5, 11, 5]\nOutput:\ntrue   // because [1, 5, 5] and [11]\n\nInput:\nnums = [1, 2, 3, 5]\nOutput:\nfalse</code></pre>\n\n<ul>\n<li>1 ≤ nums.length ≤ 200</li>\n<li>1 ≤ nums[i] ≤ 100</li>\n</ul>\n\nPro Tip: This is a classic subset-sum problem. First check if the total sum is even. If yes, try to find a subset with sum equal to totalSum / 2 using either recursion with memoization or dynamic programming (1D knapsack).',
    sampleTestCases: [
      { input: '[1,5,11,5]', expected: 'true' },
      { input: '[1,2,3,5]', expected: 'false' },
    ],
    testCases: [
      { input: '[]', expected: 'false' },
      { input: '[2,2]', expected: 'true' },
      { input: '[1,5,11,5]', expected: 'true' },
      { input: '[1,2,3,5]', expected: 'false' },
      { input: '[3,3,3,4,5]', expected: 'true' },
      { input: '[2,2,3,5]', expected: 'false' },
      { input: '[100,100]', expected: 'true' },
      { input: '[100]', expected: 'false' },
      { input: '[1,1,1,1,1,1,1,1,1,1,50]', expected: 'false' },
      { input: '[14,9,8,4,3,2]', expected: 'true' },
    ],
    topics: ['dynamic programming', 'recursion', 'subset sum'],
    interviewExcerpt:
      'Check if you can split the array into two subsets of equal sum—reduce the problem to subset sum with half of the total.',
    difficulty: 'medium',
    frequency: 96,
    tags: ['dp', 'recursion', 'subset sum', 'knapsack'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      "Sum the array; if it's odd, answer is false immediately.",
      'Otherwise, target = sum / 2. Use DP to check if some subset sums up to target.',
      'You can use a boolean DP array for 1D knapsack to optimize space.',
    ],
    optimalComplexity: {
      time: 'O(n * sum(nums))',
      space: 'O(sum(nums))',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const nums = JSON.parse(fs.readFileSync(0, "utf-8"));\n  console.log(canPartition(nums));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import json\n    nums = json.loads(input())\n    print(canPartition(nums))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String line = sc.nextLine().trim();\n    line = line.replaceAll("[\\[\\] ]", "");\n    int[] nums;\n    if (line.isEmpty()) nums = new int[0];\n    else nums = Arrays.stream(line.split(",")).mapToInt(Integer::parseInt).toArray();\n    System.out.println(canPartition(nums));\n  }\n}',
      },
      {
        language: 'cpp',
        code: "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool canPartition(vector<int>& nums);\n\nint main() {\n  string input;\n  getline(cin, input);\n  vector<int> nums;\n  for (size_t i = 0; i < input.size(); ) {\n    if ((input[i] >= '0' && input[i] <= '9') || input[i] == '-') {\n      int j = i + 1;\n      while (j < input.size() && (isdigit(input[j]) || input[j] == '-')) ++j;\n      nums.push_back(stoi(input.substr(i, j - i)));\n      i = j;\n    } else i++;\n  }\n  cout << (canPartition(nums) ? \"true\" : \"false\") << endl;\n  return 0;\n}",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function canPartition(nums) {\n  // implement subset-sum approach with DP or memoization\n  return false;\n}',
      },
      {
        language: 'python',
        code: 'def canPartition(nums):\n    # implement subset-sum with DP or recursion + cache\n    return False',
      },
      {
        language: 'java',
        code: 'public static boolean canPartition(int[] nums) {\n    // implement subset sum DP solution\n    return false;\n}',
      },
      {
        language: 'cpp',
        code: 'bool canPartition(vector<int>& nums) {\n    // implement DP (1D knapsack-like) solution\n    return false;\n}',
      },
    ],
  },
  {
    title: 'Rat in a Maze - All Paths Finder',
    slug: 'rat-in-a-maze-all-paths-finder',
    description:
      'Find all possible paths a rat can take in a maze from top-left to bottom-right corner.',
    problemStatement:
      "You're given an `n x n` grid representing a maze, where `1` indicates an open cell and `0` indicates a blocked cell. A rat starts at the top-left cell (0,0) and wants to reach the bottom-right cell (n-1,n-1). The rat can only move in four directions: up (`U`), down (`D`), left (`L`), and right (`R`). The rat can only travel through open cells and cannot visit the same cell more than once in a path. Your task is to return all possible paths (as strings of directions) the rat can take to reach the destination. Return the paths in lexicographical order.\n\nExamples:\n\n<pre><code>Input:\n3\n1 0 0\n1 1 0\n0 1 1\n\nOutput:\nDRDDRR\n\nExplanation:\nOne valid path is Down → Right → Down → Down → Right → Right\n\nInput:\n2\n1 0\n1 1\n\nOutput:\nDR\n\nExplanation:\nOne valid path: Down → Right</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 10</li>\n<li>Maze grid contains only 0s and 1s</li>\n<li>Rat starts at (0, 0) and must reach (n-1, n-1)</li>\n<li>If no path exists, return an empty array</li>\n</ul>\n\n<b>Pro Tip:</b> Use backtracking to explore all paths. Keep track of visited cells to avoid cycles. Sort paths before returning them.",
    sampleTestCases: [
      {
        input: '3\n1 0 0\n1 1 0\n0 1 1',
        expected: 'DRDDRR',
      },
      {
        input: '2\n1 0\n1 1',
        expected: 'DR',
      },
    ],
    testCases: [
      {
        input: '3\n1 0 0\n1 1 0\n0 1 1',
        expected: 'DRDDRR',
      },
      {
        input: '2\n1 0\n1 1',
        expected: 'DR',
      },
      {
        input: '3\n1 1 1\n1 1 1\n1 1 1',
        expected: 'DDRRRRDD',
      },
      {
        input: '3\n1 0 0\n0 1 0\n0 1 1',
        expected: '',
      },
      {
        input: '4\n1 1 0 1\n0 1 1 0\n1 1 0 1\n0 1 1 1',
        expected: 'DRDRDRDDRR',
      },
      {
        input: '1\n1',
        expected: '',
      },
      {
        input: '2\n0 1\n1 1',
        expected: '',
      },
      {
        input: '3\n1 1 1\n0 0 1\n1 1 1',
        expected: 'RRDD',
      },
      {
        input: '3\n1 0 1\n1 1 0\n1 1 1',
        expected: 'DRDRRR',
      },
      {
        input: '2\n1 1\n0 1',
        expected: 'RD',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're working on a robot navigation system for a grid-based warehouse. Imagine a rat that must find all possible paths from the top-left corner to the bottom-right corner of a maze represented as a grid. The twist? The rat can only move in four directions and can't revisit a cell. Could you help us find all these paths?",
    categories: ['backtracking', 'recursion', 'matrix traversal'],
    difficulty: 'medium',
    frequency: 84,
    tags: ['backtracking', 'matrix', 'recursion'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Think recursively: move in each of the four directions if the move is safe.',
      'Maintain a visited matrix to avoid revisiting cells.',
      'Backtrack after exploring a path.',
    ],
    optimalComplexity: {
      time: 'O(4^(n*n))',
      space: 'O(n*n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\n\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const grid = [];\n  for (let i = 1; i <= n; i++) {\n    grid.push(input[i].split(" ").map(Number));\n  }\n  const result = findPaths(grid);\n  console.log(result.join("\\n"));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    grid = [list(map(int, line.split())) for line in input_lines[1:n+1]]\n    res = findPaths(grid)\n    print("\\n".join(res))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[][] grid = new int[n][n];\n    for (int i = 0; i < n; i++) {\n      String[] parts = sc.nextLine().split(" ");\n      for (int j = 0; j < n; j++) {\n        grid[i][j] = Integer.parseInt(parts[j]);\n      }\n    }\n    List<String> res = Solution.findPaths(grid);\n    for (String path : res) System.out.println(path);\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nvector<string> findPaths(vector<vector<int>>& grid);\nint main() {\n  int n; cin >> n;\n  vector<vector<int>> grid(n, vector<int>(n));\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j)\n      cin >> grid[i][j];\n  vector<string> res = findPaths(grid);\n  for (string& s : res) cout << s << "\\n";\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function findPaths(grid) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def findPaths(grid):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static List<String> findPaths(int[][] grid) {\n    // write code here\n    return new ArrayList<>();\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\n#include <string>\nusing namespace std;\nvector<string> findPaths(vector<vector<int>>& grid) {\n    // write code here\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Rat in a Maze with Obstacles',
    slug: 'rat-in-a-maze-with-obstacles',
    description:
      'Find all valid paths for a rat to reach the destination while avoiding obstacles.',
    problemStatement:
      "You're given an `n x n` grid representing a maze. A cell with `1` is open and a cell with `0` is an obstacle. A rat starts from the top-left corner (0,0) and aims to reach the bottom-right corner (n-1,n-1). The rat can only move in four directions: up (`U`), down (`D`), left (`L`), and right (`R`). The rat cannot revisit the same cell and cannot pass through obstacles (0s). Return all valid paths as strings of directions in lexicographical order. If no path exists, return an empty array.\n\nExamples:\n\n<pre><code>Input:\n4\n1 0 0 0\n1 1 0 1\n0 1 0 0\n1 1 1 1\n\nOutput:\nDDRDRR\n\nExplanation:\nOne valid path: Down → Down → Right → Down → Right → Right\n\nInput:\n2\n1 1\n0 1\n\nOutput:\nRD</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 10</li>\n<li>Maze consists of only 0s (obstacle) and 1s (open)</li>\n<li>Start is always (0,0) and end is (n-1,n-1)</li>\n<li>Return all paths sorted lexicographically</li>\n<li>No cell can be revisited in the same path</li>\n<li>If no path exists, return an empty array</li>\n</ul>\n\n<b>Pro Tip:</b> Backtracking with bounds and obstacle checks is key. Avoid cycles by tracking visited cells.",
    sampleTestCases: [
      {
        input: '4\n1 0 0 0\n1 1 0 1\n0 1 0 0\n1 1 1 1',
        expected: 'DDRDRR',
      },
      {
        input: '2\n1 1\n0 1',
        expected: 'RD',
      },
    ],
    testCases: [
      {
        input: '4\n1 0 0 0\n1 1 0 1\n0 1 0 0\n1 1 1 1',
        expected: 'DDRDRR',
      },
      {
        input: '2\n1 1\n0 1',
        expected: 'RD',
      },
      {
        input: '3\n1 0 1\n1 1 1\n0 1 1',
        expected: 'DRDRR',
      },
      {
        input: '3\n1 1 1\n1 0 1\n1 1 1',
        expected: 'DDRURR',
      },
      {
        input: '3\n1 0 0\n0 1 0\n0 0 1',
        expected: '',
      },
      {
        input: '2\n0 1\n1 1',
        expected: '',
      },
      {
        input: '1\n1',
        expected: '',
      },
      {
        input: '3\n1 1 1\n1 1 1\n1 1 1',
        expected: 'DDRR\nDRDR\nDRRD\nRDDR\nRDRD\nRRDD',
      },
      {
        input: '4\n1 1 1 1\n0 0 0 1\n1 1 1 1\n1 0 0 1',
        expected: 'RRRRDDDD',
      },
      {
        input: '3\n1 0 1\n1 0 1\n1 1 1',
        expected: 'DDRR',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Imagine programming a robot to navigate through a warehouse grid full of obstacles. You need to find every possible way it can move from the entrance (top-left) to the exit (bottom-right), avoiding blocked cells. How would you approach this?',
    categories: ['recursion', 'matrix traversal', 'backtracking'],
    difficulty: 'medium',
    frequency: 79,
    tags: ['matrix', 'backtracking', 'recursion'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use a visited matrix to avoid re-visiting cells.',
      'Check boundaries and obstacles before moving.',
      'Collect valid paths recursively and backtrack after each move.',
    ],
    optimalComplexity: {
      time: 'O(4^(n*n))',
      space: 'O(n*n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\n\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const grid = [];\n  for (let i = 1; i <= n; i++) {\n    grid.push(input[i].split(" ").map(Number));\n  }\n  const result = findPaths(grid);\n  console.log(result.join("\\n"));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    grid = [list(map(int, line.split())) for line in input_lines[1:n+1]]\n    res = findPaths(grid)\n    print("\\n".join(res))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[][] grid = new int[n][n];\n    for (int i = 0; i < n; i++) {\n      String[] parts = sc.nextLine().split(" ");\n      for (int j = 0; j < n; j++) {\n        grid[i][j] = Integer.parseInt(parts[j]);\n      }\n    }\n    List<String> res = Solution.findPaths(grid);\n    for (String path : res) System.out.println(path);\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nvector<string> findPaths(vector<vector<int>>& grid);\nint main() {\n  int n; cin >> n;\n  vector<vector<int>> grid(n, vector<int>(n));\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j)\n      cin >> grid[i][j];\n  vector<string> res = findPaths(grid);\n  for (string& s : res) cout << s << "\\n";\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function findPaths(grid) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def findPaths(grid):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static List<String> findPaths(int[][] grid) {\n    // write code here\n    return new ArrayList<>();\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\n#include <string>\nusing namespace std;\nvector<string> findPaths(vector<vector<int>>& grid) {\n    // write code here\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Print All Paths in a Matrix',
    slug: 'print-all-paths-in-a-matrix',
    description:
      'Print all possible paths from the top-left to bottom-right corner in a matrix by only moving right or down.',
    problemStatement:
      "You're given an `m x n` matrix filled with integers. A person starts at the top-left cell (0,0) and wants to reach the bottom-right cell (m-1,n-1). At any point, the person can only move **right** or **down**. Print all possible paths as lists of integers, representing the values from each cell visited in order.\n\nExamples:\n\n<pre><code>Input:\n2 2\n1 2\n3 4\n\nOutput:\n[1, 2, 4]\n[1, 3, 4]\n\nExplanation:\nTwo paths: (0,0) → (0,1) → (1,1), and (0,0) → (1,0) → (1,1)</code></pre>\n\n<pre><code>Input:\n2 3\n1 2 3\n4 5 6\n\nOutput:\n[1, 2, 3, 6]\n[1, 2, 5, 6]\n[1, 4, 5, 6]</code></pre>\n\n<ul>\n<li>1 ≤ m, n ≤ 10</li>\n<li>-100 ≤ matrix[i][j] ≤ 100</li>\n<li>You must explore all valid paths from top-left to bottom-right</li>\n</ul>\n\n<b>Pro Tip:</b> Use recursion with backtracking to explore each path and collect results. You only need to consider right and down directions.",
    sampleTestCases: [
      {
        input: '2 2\n1 2\n3 4',
        expected: '[1, 2, 4]\n[1, 3, 4]',
      },
      {
        input: '2 3\n1 2 3\n4 5 6',
        expected: '[1, 2, 3, 6]\n[1, 2, 5, 6]\n[1, 4, 5, 6]',
      },
    ],
    testCases: [
      {
        input: '2 2\n1 2\n3 4',
        expected: '[1, 2, 4]\n[1, 3, 4]',
      },
      {
        input: '2 3\n1 2 3\n4 5 6',
        expected: '[1, 2, 3, 6]\n[1, 2, 5, 6]\n[1, 4, 5, 6]',
      },
      {
        input: '1 3\n7 8 9',
        expected: '[7, 8, 9]',
      },
      {
        input: '3 1\n5\n6\n7',
        expected: '[5, 6, 7]',
      },
      {
        input: '3 2\n1 2\n3 4\n5 6',
        expected: '[1, 2, 4, 6]\n[1, 2, 4, 6]\n[1, 3, 4, 6]',
      },
      {
        input: '2 1\n10\n20',
        expected: '[10, 20]',
      },
      {
        input: '1 1\n99',
        expected: '[99]',
      },
      {
        input: '2 2\n0 1\n2 3',
        expected: '[0, 1, 3]\n[0, 2, 3]',
      },
      {
        input: '3 3\n1 2 3\n4 5 6\n7 8 9',
        expected:
          '[1, 2, 3, 6, 9]\n[1, 2, 5, 6, 9]\n[1, 2, 5, 8, 9]\n[1, 4, 5, 6, 9]\n[1, 4, 5, 8, 9]\n[1, 4, 7, 8, 9]',
      },
      {
        input: '2 3\n-1 -2 -3\n-4 -5 -6',
        expected: '[-1, -2, -3, -6]\n[-1, -2, -5, -6]\n[-1, -4, -5, -6]',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Let's say you're building a path tracing tool that needs to explore all ways to travel from the top-left to bottom-right of a matrix, only moving right or down. How would you go about generating all such routes, along with their values?",
    categories: ['recursion', 'backtracking', 'matrix traversal'],
    difficulty: 'easy',
    frequency: 71,
    tags: ['recursion', 'matrix', 'backtracking'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
      { name: 'Flipkart', logoUrl: '' },
    ],
    hints: [
      'Use DFS starting from (0,0).',
      'Pass along the current path in recursion and push when at destination.',
      'Only move right or down at each step.',
    ],
    optimalComplexity: {
      time: 'O(2^(m+n))',
      space: 'O(m+n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const [m, n] = input[0].split(" ").map(Number);\n  const matrix = [];\n  for (let i = 1; i <= m; i++) {\n    matrix.push(input[i].split(" ").map(Number));\n  }\n  const paths = getAllPaths(matrix);\n  for (let p of paths) {\n    console.log("[" + p.join(", ") + "]");\n  }\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    m, n = map(int, input_lines[0].split())\n    matrix = [list(map(int, line.split())) for line in input_lines[1:m+1]]\n    paths = getAllPaths(matrix)\n    for p in paths:\n        print("[{}]".format(", ".join(map(str, p))))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String[] dims = sc.nextLine().split(" ");\n    int m = Integer.parseInt(dims[0]), n = Integer.parseInt(dims[1]);\n    int[][] matrix = new int[m][n];\n    for (int i = 0; i < m; i++) {\n      String[] parts = sc.nextLine().split(" ");\n      for (int j = 0; j < n; j++) matrix[i][j] = Integer.parseInt(parts[j]);\n    }\n    List<List<Integer>> paths = Solution.getAllPaths(matrix);\n    for (List<Integer> p : paths) {\n      System.out.println(p);\n    }\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> getAllPaths(vector<vector<int>>& matrix);\nint main() {\n  int m, n; cin >> m >> n;\n  vector<vector<int>> matrix(m, vector<int>(n));\n  for (int i = 0; i < m; ++i)\n    for (int j = 0; j < n; ++j)\n      cin >> matrix[i][j];\n  auto paths = getAllPaths(matrix);\n  for (auto& path : paths) {\n    cout << "[";\n    for (size_t i = 0; i < path.size(); ++i) {\n      cout << path[i];\n      if (i < path.size() - 1) cout << ", ";\n    }\n    cout << "]\\n";\n  }\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function getAllPaths(matrix) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def getAllPaths(matrix):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static List<List<Integer>> getAllPaths(int[][] matrix) {\n    // write code here\n    return new ArrayList<>();\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\nusing namespace std;\nvector<vector<int>> getAllPaths(vector<vector<int>>& matrix) {\n  // write code here\n  return {};\n}',
      },
    ],
  },
  {
    title: 'Word Search in a 2D Grid',
    slug: 'word-search-in-a-2d-grid',
    description:
      'Determine if a word exists in a 2D character grid by moving horizontally or vertically.',
    problemStatement:
      'You are given a 2D grid of characters and a target word. Your task is to determine if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a path.\n\nReturn `true` if the word exists in the grid, otherwise return `false`.\n\nExamples:\n\n<pre><code>Input:\n3 4\nA B C E\nS F C S\nA D E E\nABCCED\n\nOutput:\ntrue\n\nExplanation:\nThe word "ABCCED" can be traced as A → B → C → C → E → D.\n\nInput:\n2 2\nA B\nC D\nABCD\n\nOutput:\nfalse\n\nExplanation:\nThe path would require revisiting cells, which is not allowed.</code></pre>\n\n<ul>\n<li>1 ≤ m, n ≤ 6</li>\n<li>1 ≤ word.length ≤ 15</li>\n<li>Grid contains only uppercase English letters</li>\n<li>The same cell may not be used more than once per word</li>\n</ul>\n\n<b>Pro Tip:</b> Use DFS with backtracking from each cell to match characters in the word. Mark visited cells during traversal.',
    sampleTestCases: [
      {
        input: '3 4\nA B C E\nS F C S\nA D E E\nABCCED',
        expected: 'true',
      },
      {
        input: '2 2\nA B\nC D\nABCD',
        expected: 'false',
      },
    ],
    testCases: [
      {
        input: '3 4\nA B C E\nS F C S\nA D E E\nABCCED',
        expected: 'true',
      },
      {
        input: '3 4\nA B C E\nS F C S\nA D E E\nSEE',
        expected: 'true',
      },
      {
        input: '3 4\nA B C E\nS F C S\nA D E E\nABCB',
        expected: 'false',
      },
      {
        input: '2 2\nA B\nC D\nABCD',
        expected: 'false',
      },
      {
        input: '1 4\nA B C D\nABCD',
        expected: 'true',
      },
      {
        input: '2 3\nA B C\nD E F\nCDE',
        expected: 'false',
      },
      {
        input: '3 3\nA A A\nA A A\nA A A\nAAAAAAAAAAAAAAA',
        expected: 'false',
      },
      {
        input: '3 3\nC A T\nX X X\nX X X\nCAT',
        expected: 'true',
      },
      {
        input: '2 2\nA B\nC D\nAD',
        expected: 'false',
      },
      {
        input: '3 3\nA B C\nD E F\nG H I\nBEF',
        expected: 'true',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're building a crossword puzzle checker that verifies if a given word can be formed by tracing a path through a grid. You can only move horizontally or vertically, and can't reuse any cell. Can you write a function to check if a word exists in the grid?",
    categories: ['backtracking', 'matrix', 'search'],
    difficulty: 'medium',
    frequency: 88,
    tags: ['dfs', 'backtracking', 'matrix'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Try DFS from every cell that matches the first letter.',
      'Keep track of visited cells using a temporary marker or separate array.',
      'Backtrack after exploring each direction.',
    ],
    optimalComplexity: {
      time: 'O(m * n * 4^L)',
      space: 'O(L)',
      note: 'L = length of the word',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const [m, n] = input[0].split(" ").map(Number);\n  const grid = [];\n  for (let i = 1; i <= m; i++) {\n    grid.push(input[i].split(" "));\n  }\n  const word = input[m + 1];\n  console.log(exist(grid, word));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    m, n = map(int, input_lines[0].split())\n    board = [line.split() for line in input_lines[1:m+1]]\n    word = input_lines[m+1]\n    print(exist(board, word))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String[] dims = sc.nextLine().split(" ");\n    int m = Integer.parseInt(dims[0]), n = Integer.parseInt(dims[1]);\n    char[][] board = new char[m][n];\n    for (int i = 0; i < m; i++) {\n      String[] line = sc.nextLine().split(" ");\n      for (int j = 0; j < n; j++) board[i][j] = line[j].charAt(0);\n    }\n    String word = sc.nextLine();\n    System.out.println(Solution.exist(board, word));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nbool exist(vector<vector<char>>& board, string word);\nint main() {\n  int m, n; cin >> m >> n;\n  vector<vector<char>> board(m, vector<char>(n));\n  for (int i = 0; i < m; ++i)\n    for (int j = 0; j < n; ++j)\n      cin >> board[i][j];\n  string word; cin >> word;\n  cout << (exist(board, word) ? "true" : "false") << endl;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function exist(board, word) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def exist(board, word):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static boolean exist(char[][] board, String word) {\n    // write code here\n    return false;\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\n#include <string>\nusing namespace std;\nbool exist(vector<vector<char>>& board, string word) {\n  // write code here\n  return false;\n}',
      },
    ],
  },
  {
    title: 'Unique Paths III',
    slug: 'unique-paths-iii',
    description:
      'Count all unique paths from a start square to an end square while visiting every non-obstacle square exactly once.',
    problemStatement:
      'You are given an m x n grid where each cell can be one of four values:\n- 0: an empty square you can walk over,\n- -1: an obstacle you cannot walk over,\n- 1: the starting square,\n- 2: the ending square.\n\nReturn the number of unique paths from the starting square to the ending square such that all the non-obstacle squares are visited exactly once.\n\nYou can only move up, down, left, or right. No cell can be visited more than once in the same path.\n\nExamples:\n\n<pre><code>Input:\n3 4\n1 0 0 0\n0 0 0 0\n0 0 2 -1\n\nOutput:\n2\n\nExplanation:\nThere are two paths that start at 1, end at 2, and visit every non-obstacle cell once.\n\nInput:\n2 2\n1 0\n0 2\n\nOutput:\n1\n\nExplanation:\nOnly one valid path exists: (0,0) → (0,1) → (1,1)</code></pre>\n\n<ul>\n<li>1 ≤ m, n ≤ 10</li>\n<li>Exactly one cell has the value 1 (start), and one cell has the value 2 (end)</li>\n<li>Each cell is either 0 (walkable), -1 (obstacle), 1 (start), or 2 (end)</li>\n</ul>\n\n<b>Pro Tip:</b> Use DFS with backtracking and count the number of valid cells. Only increment the path count if you reach the end after visiting all valid cells.',
    sampleTestCases: [
      {
        input: '3 4\n1 0 0 0\n0 0 0 0\n0 0 2 -1',
        expected: '2',
      },
      {
        input: '2 2\n1 0\n0 2',
        expected: '1',
      },
    ],
    testCases: [
      {
        input: '3 4\n1 0 0 0\n0 0 0 0\n0 0 2 -1',
        expected: '2',
      },
      {
        input: '2 2\n1 0\n0 2',
        expected: '1',
      },
      {
        input: '3 3\n1 0 0\n0 -1 0\n0 0 2',
        expected: '2',
      },
      {
        input: '3 3\n1 -1 0\n0 -1 0\n0 0 2',
        expected: '0',
      },
      {
        input: '1 4\n1 0 0 2',
        expected: '1',
      },
      {
        input: '2 3\n1 0 0\n-1 -1 2',
        expected: '0',
      },
      {
        input: '3 3\n1 0 0\n0 0 0\n2 -1 0',
        expected: '4',
      },
      {
        input: '2 2\n1 -1\n-1 2',
        expected: '0',
      },
      {
        input: '2 2\n1 2\n-1 -1',
        expected: '0',
      },
      {
        input: '3 3\n1 0 0\n0 2 0\n0 0 0',
        expected: '4',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're programming a cleaning robot that must pass through every open square in a room exactly once, starting from a designated square and ending at another. How would you count all such valid paths?",
    categories: ['backtracking', 'matrix', 'dfs'],
    difficulty: 'hard',
    frequency: 77,
    tags: ['dfs', 'backtracking', 'matrix', 'counting'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Apple', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Count all walkable squares at the start including start and end.',
      'Use DFS and decrease the count as you move.',
      'Only count a path as valid when you reach end and all walkable cells have been visited.',
    ],
    optimalComplexity: {
      time: 'O(3^(m*n))',
      space: 'O(m*n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const [m, n] = input[0].split(" ").map(Number);\n  const grid = [];\n  for (let i = 1; i <= m; i++) {\n    grid.push(input[i].split(" ").map(Number));\n  }\n  const result = uniquePathsIII(grid);\n  console.log(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    m, n = map(int, input_lines[0].split())\n    grid = [list(map(int, line.split())) for line in input_lines[1:m+1]]\n    print(uniquePathsIII(grid))',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String[] dims = sc.nextLine().split(" ");\n    int m = Integer.parseInt(dims[0]), n = Integer.parseInt(dims[1]);\n    int[][] grid = new int[m][n];\n    for (int i = 0; i < m; i++) {\n      String[] line = sc.nextLine().split(" ");\n      for (int j = 0; j < n; j++) grid[i][j] = Integer.parseInt(line[j]);\n    }\n    System.out.println(Solution.uniquePathsIII(grid));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nint uniquePathsIII(vector<vector<int>>& grid);\nint main() {\n  int m, n; cin >> m >> n;\n  vector<vector<int>> grid(m, vector<int>(n));\n  for (int i = 0; i < m; ++i)\n    for (int j = 0; j < n; ++j)\n      cin >> grid[i][j];\n  cout << uniquePathsIII(grid) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function uniquePathsIII(grid) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def uniquePathsIII(grid):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static int uniquePathsIII(int[][] grid) {\n    // write code here\n    return 0;\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\nusing namespace std;\nint uniquePathsIII(vector<vector<int>>& grid) {\n  // write code here\n  return 0;\n}',
      },
    ],
  },
  {
    title: 'Sudoku Solver',
    slug: 'sudoku-solver',
    description:
      'Solve a given 9x9 Sudoku board by filling empty cells with valid digits.',
    problemStatement:
      "You're given a partially filled 9x9 Sudoku grid. The board is represented as a 2D character array `board`, where each cell contains a digit '1'-'9' or a '.' indicating an empty cell.\n\nYou need to fill the empty cells so that the board becomes a valid Sudoku solution. A valid Sudoku solution means:\n\n- Each row contains the digits '1' to '9' without repetition.\n- Each column contains the digits '1' to '9' without repetition.\n- Each of the 9 3x3 subgrids (boxes) contains the digits '1' to '9' without repetition.\n\nYou must solve the board in-place.\n\nExamples:\n\n<pre><code>Input:\n5 3 . . 7 . . . .\n6 . . 1 9 5 . . .\n. 9 8 . . . . 6 .\n8 . . . 6 . . . 3\n4 . . 8 . 3 . . 1\n7 . . . 2 . . . 6\n. 6 . . . . 2 8 .\n. . . 4 1 9 . . 5\n. . . . 8 . . 7 9\n\nOutput:\n5 3 4 6 7 8 9 1 2\n6 7 2 1 9 5 3 4 8\n1 9 8 3 4 2 5 6 7\n8 5 9 7 6 1 4 2 3\n4 2 6 8 5 3 7 9 1\n7 1 3 9 2 4 8 5 6\n9 6 1 5 3 7 2 8 4\n2 8 7 4 1 9 6 3 5\n3 4 5 2 8 6 1 7 9</code></pre>\n\n<ul>\n<li>The input board is always 9x9 and initially valid according to Sudoku rules.</li>\n<li>There is exactly one solution for the input.</li>\n<li>Modify the input board in-place to solve the puzzle.</li>\n</ul>\n\n<b>Pro Tip:</b> Use backtracking and try each possible number in every empty cell. Backtrack if it leads to an invalid state.",
    sampleTestCases: [
      {
        input:
          '5 3 . . 7 . . . .\n6 . . 1 9 5 . . .\n. 9 8 . . . . 6 .\n8 . . . 6 . . . 3\n4 . . 8 . 3 . . 1\n7 . . . 2 . . . 6\n. 6 . . . . 2 8 .\n. . . 4 1 9 . . 5\n. . . . 8 . . 7 9',
        expected:
          '5 3 4 6 7 8 9 1 2\n6 7 2 1 9 5 3 4 8\n1 9 8 3 4 2 5 6 7\n8 5 9 7 6 1 4 2 3\n4 2 6 8 5 3 7 9 1\n7 1 3 9 2 4 8 5 6\n9 6 1 5 3 7 2 8 4\n2 8 7 4 1 9 6 3 5\n3 4 5 2 8 6 1 7 9',
      },
    ],
    testCases: [
      {
        input:
          '5 3 . . 7 . . . .\n6 . . 1 9 5 . . .\n. 9 8 . . . . 6 .\n8 . . . 6 . . . 3\n4 . . 8 . 3 . . 1\n7 . . . 2 . . . 6\n. 6 . . . . 2 8 .\n. . . 4 1 9 . . 5\n. . . . 8 . . 7 9',
        expected:
          '5 3 4 6 7 8 9 1 2\n6 7 2 1 9 5 3 4 8\n1 9 8 3 4 2 5 6 7\n8 5 9 7 6 1 4 2 3\n4 2 6 8 5 3 7 9 1\n7 1 3 9 2 4 8 5 6\n9 6 1 5 3 7 2 8 4\n2 8 7 4 1 9 6 3 5\n3 4 5 2 8 6 1 7 9',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Sudoku is a famous puzzle. Let's write a function to complete a 9x9 Sudoku board so that it satisfies all Sudoku rules. It's a great test of backtracking and constraint propagation.",
    categories: ['backtracking', 'matrix', 'dfs'],
    difficulty: 'hard',
    frequency: 91,
    tags: ['backtracking', 'constraint-satisfaction', 'matrix'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Bloomberg', logoUrl: '' },
    ],
    hints: [
      'Try filling the board cell-by-cell using backtracking.',
      'Use helper functions to check if placing a number is valid.',
      'Backtrack if you hit a dead end (no valid number fits).',
    ],
    optimalComplexity: {
      time: 'O(9^(n*n))',
      space: 'O(n^2)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const board = input.map(row => row.split(" "));\n  solveSudoku(board);\n  board.forEach(row => console.log(row.join(" ")));\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    board = [line.split() for line in input_lines]\n    solveSudoku(board)\n    for row in board:\n        print(' '.join(row))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    char[][] board = new char[9][9];\n    for (int i = 0; i < 9; i++) {\n      String[] row = sc.nextLine().split(" ");\n      for (int j = 0; j < 9; j++) {\n        board[i][j] = row[j].charAt(0);\n      }\n    }\n    Solution.solveSudoku(board);\n    for (int i = 0; i < 9; i++) {\n      for (int j = 0; j < 9; j++) {\n        System.out.print(board[i][j]);\n        if (j < 8) System.out.print(" ");\n      }\n      System.out.println();\n    }\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nvoid solveSudoku(vector<vector<char>>& board);\nint main() {\n  vector<vector<char>> board(9, vector<char>(9));\n  for (int i = 0; i < 9; i++)\n    for (int j = 0; j < 9; j++)\n      cin >> board[i][j];\n  solveSudoku(board);\n  for (auto& row : board) {\n    for (int j = 0; j < 9; ++j) {\n      cout << row[j];\n      if (j < 8) cout << " ";\n    }\n    cout << "\\n";\n  }\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function solveSudoku(board) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def solveSudoku(board):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static void solveSudoku(char[][] board) {\n    // write code here\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\nusing namespace std;\nvoid solveSudoku(vector<vector<char>>& board) {\n  // write code here\n}',
      },
    ],
  },
  {
    title: 'N-Queens Problem',
    slug: 'n-queens-problem',
    description:
      'Place N queens on an N×N chessboard such that no two queens attack each other.',
    problemStatement:
      "The N-Queens problem involves placing N queens on an N×N chessboard such that no two queens threaten each other. This means:\n- No two queens share the same row\n- No two queens share the same column\n- No two queens share the same diagonal\n\nYour task is to print all valid configurations of the board. Each configuration is represented as a list of strings where 'Q' indicates a queen and '.' indicates an empty square.\n\nExamples:\n\n<pre><code>Input:\n4\n\nOutput:\n.Q..\n...Q\nQ...\n..Q.\n\n..Q.\nQ...\n...Q\n.Q..</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 9</li>\n<li>Return all possible board configurations</li>\n<li>Print each configuration separated by a blank line</li>\n</ul>\n\n<b>Pro Tip:</b> Use backtracking and maintain sets or arrays to track used columns and diagonals.",
    sampleTestCases: [
      {
        input: '4',
        expected: '.Q..\n...Q\nQ...\n..Q.\n\n..Q.\nQ...\n...Q\n.Q..',
      },
      {
        input: '1',
        expected: 'Q',
      },
    ],
    testCases: [
      {
        input: '4',
        expected: '.Q..\n...Q\nQ...\n..Q.\n\n..Q.\nQ...\n...Q\n.Q..',
      },
      {
        input: '1',
        expected: 'Q',
      },
      {
        input: '2',
        expected: '',
      },
      {
        input: '3',
        expected: '',
      },
      {
        input: '5',
        expected:
          'Q....\n..Q..\n....Q\n.Q...\n...Q.\n\nQ....\n...Q.\n.Q...\n....Q\n..Q..\n\n...',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Imagine building a chess AI and your engine needs to calculate all valid ways to place queens so they don’t attack each other. Can you generate all possible board arrangements for N queens?',
    categories: ['backtracking', 'combinatorics', 'matrix'],
    difficulty: 'hard',
    frequency: 83,
    tags: ['backtracking', 'recursion', 'matrix'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Use a helper function to recursively place queens row by row.',
      'Track used columns and diagonals with sets or boolean arrays.',
      'Backtrack if a placement leads to an invalid state.',
    ],
    optimalComplexity: {
      time: 'O(n!)',
      space: 'O(n^2)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const n = parseInt(fs.readFileSync(0, "utf-8").trim());\n  const result = solveNQueens(n);\n  for (let board of result) {\n    for (let row of board) console.log(row);\n    console.log();\n  }\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    n = int(sys.stdin.read().strip())\n    res = solveNQueens(n)\n    for board in res:\n        for row in board:\n            print(row)\n        print()',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    List<List<String>> result = Solution.solveNQueens(n);\n    for (List<String> board : result) {\n      for (String row : board) System.out.println(row);\n      System.out.println();\n    }\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<string>> solveNQueens(int n);\nint main() {\n  int n; cin >> n;\n  auto res = solveNQueens(n);\n  for (auto& board : res) {\n    for (auto& row : board) cout << row << "\\n";\n    cout << "\\n";\n  }\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function solveNQueens(n) {\n  // write code here\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def solveNQueens(n):\n    # write code here\n    return []',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static List<List<String>> solveNQueens(int n) {\n    // write code here\n    return new ArrayList<>();\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\n#include <string>\nusing namespace std;\nvector<vector<string>> solveNQueens(int n) {\n  // write code here\n  return {};\n}',
      },
    ],
  },
  {
    title: 'Count N-Queens Solutions',
    slug: 'count-n-queens-solutions',
    description:
      'Count all valid configurations to place N queens on an N×N board so that they do not attack each other.',
    problemStatement:
      'Given an integer `n`, return the total number of distinct solutions to the N-Queens problem. A solution is defined as a valid configuration of N queens on an N×N chessboard such that no two queens threaten each other.\n\nYou need to count all such distinct configurations, not list them.\n\nExamples:\n\n<pre><code>Input:\n4\n\nOutput:\n2\n\nExplanation:\nThere are two possible arrangements of 4 queens where no queens attack each other.\n\nInput:\n1\n\nOutput:\n1</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 14</li>\n<li>Only return the count of valid arrangements, not the arrangements themselves.</li>\n</ul>\n\n<b>Pro Tip:</b> Use backtracking and optimize with bitmasks to handle large N efficiently.',
    sampleTestCases: [
      {
        input: '4',
        expected: '2',
      },
      {
        input: '1',
        expected: '1',
      },
    ],
    testCases: [
      {
        input: '1',
        expected: '1',
      },
      {
        input: '2',
        expected: '0',
      },
      {
        input: '3',
        expected: '0',
      },
      {
        input: '4',
        expected: '2',
      },
      {
        input: '5',
        expected: '10',
      },
      {
        input: '6',
        expected: '4',
      },
      {
        input: '7',
        expected: '40',
      },
      {
        input: '8',
        expected: '92',
      },
      {
        input: '9',
        expected: '352',
      },
      {
        input: '10',
        expected: '724',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Suppose you're designing a game engine that needs to verify how many ways queens can be placed on a board of size N without attacking each other. Can you write a function to return the count only?",
    categories: ['backtracking', 'combinatorics'],
    difficulty: 'hard',
    frequency: 86,
    tags: ['backtracking', 'recursion', 'combinatorics', 'bitmasking'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Meta', logoUrl: '' },
    ],
    hints: [
      'Use a recursive function to place queens row-by-row.',
      'Track attacked columns and diagonals to avoid conflicts.',
      'Bitmasking can optimize checking conflicts significantly.',
    ],
    optimalComplexity: {
      time: 'O(n!)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const n = parseInt(fs.readFileSync(0, "utf-8").trim());\n  console.log(totalNQueens(n));\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    n = int(sys.stdin.read().strip())\n    print(totalNQueens(n))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    System.out.println(Solution.totalNQueens(n));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nint totalNQueens(int n);\nint main() {\n  int n; cin >> n;\n  cout << totalNQueens(n) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function totalNQueens(n) {\n  // write code here\n  return 0;\n}',
      },
      {
        language: 'python',
        code: 'def totalNQueens(n):\n    # write code here\n    return 0',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static int totalNQueens(int n) {\n    // write code here\n    return 0;\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\nusing namespace std;\nint totalNQueens(int n) {\n  // write code here\n  return 0;\n}',
      },
    ],
  },
  {
    title: 'Knight’s Tour Problem',
    slug: 'knights-tour-problem',
    description:
      'Find a sequence of moves for a knight to visit every square on an N×N chessboard exactly once.',
    problemStatement:
      "The Knight’s Tour is a classic backtracking problem. Given an integer `n`, your task is to find one possible sequence of moves for a knight to visit every square of an `n x n` chessboard exactly once. The knight moves in an 'L' shape (two squares in one direction and then one square perpendicular).\n\nStart from position (0,0) and print the board where each cell contains the move number (starting from 0). If no such tour exists, return an empty board or a message saying no solution.\n\nExamples:\n\n<pre><code>Input:\n5\n\nOutput:\n0 17 8 25 12\n9 24 1 16 7\n18 5 10 13 26\n23 2 19 6 15\n4 11 22 27 14</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 8</li>\n<li>Print one valid board configuration if any exists</li>\n<li>Print move numbers from 0 to n*n-1</li>\n</ul>\n\n<b>Pro Tip:</b> Use backtracking with knight move directions. Warnsdorff’s rule can help optimize.",
    sampleTestCases: [
      {
        input: '5',
        expected:
          '0 17 8 25 12\n9 24 1 16 7\n18 5 10 13 26\n23 2 19 6 15\n4 11 22 27 14',
      },
    ],
    testCases: [
      {
        input: '5',
        expected:
          '0 17 8 25 12\n9 24 1 16 7\n18 5 10 13 26\n23 2 19 6 15\n4 11 22 27 14',
      },
      {
        input: '1',
        expected: '0',
      },
      {
        input: '3',
        expected: '',
      },
      {
        input: '4',
        expected: '',
      },
      {
        input: '6',
        expected:
          '0 29 18  9 48 33\n17  8 49 28 19 10\n30  1 32 47 34 39\n 7 16 11 50 27 20\n 2 31 46 35 38 13\n15  6  3 12 21 26',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're building a chess simulation that needs to find whether a knight can visit every square of a board exactly once. Can you return one such valid path or indicate it's not possible?",
    categories: ['backtracking', 'recursion', 'matrix traversal'],
    difficulty: 'hard',
    frequency: 74,
    tags: ['backtracking', 'matrix', 'recursion'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Define all 8 possible knight moves using dx, dy arrays.',
      'Use a board filled with -1s to track move indices.',
      'Backtrack if a move leads to no further options.',
    ],
    optimalComplexity: {
      time: 'O(8^(n^2))',
      space: 'O(n^2)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const n = parseInt(fs.readFileSync(0, "utf-8").trim());\n  const res = knightsTour(n);\n  if (!res.length) console.log("");\n  else res.forEach(row => console.log(row.join(" ")));\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    n = int(sys.stdin.read().strip())\n    board = knightsTour(n)\n    if not board:\n        print()\n    else:\n        for row in board:\n            print(' '.join(map(str, row)))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[][] board = Solution.knightsTour(n);\n    if (board.length == 0) System.out.println();\n    else {\n      for (int[] row : board) {\n        for (int i = 0; i < row.length; i++) System.out.print(row[i] + (i < row.length - 1 ? " " : ""));\n        System.out.println();\n      }\n    }\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> knightsTour(int n);\nint main() {\n  int n; cin >> n;\n  auto board = knightsTour(n);\n  if (board.empty()) cout << "";\n  else {\n    for (auto& row : board) {\n      for (int i = 0; i < row.size(); ++i) cout << row[i] << (i < row.size() - 1 ? " " : "");\n      cout << "\\n";\n    }\n  }\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function knightsTour(n) {\n  // write code here\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def knightsTour(n):\n    # write code here\n    return []',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static int[][] knightsTour(int n) {\n    // write code here\n    return new int[0][0];\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\nusing namespace std;\nvector<vector<int>> knightsTour(int n) {\n  // write code here\n  return {};\n}',
      },
    ],
  },
  {
    title: 'Flood Fill Using DFS',
    slug: 'flood-fill-using-dfs',
    description:
      'Recolor all connected cells in a 2D grid starting from a given point using DFS.',
    problemStatement:
      "You're given a 2D grid of integers representing colors, and a starting cell `(sr, sc)` in the grid. Your task is to perform a **flood fill** starting from the cell `(sr, sc)`, changing all connected cells (up/down/left/right) of the same original color to a new given color.\n\nReturn the updated grid.\n\nExamples:\n\n<pre><code>Input:\n3 3\n1 1 1\n1 1 0\n1 0 1\n1 1 2\n\nOutput:\n2 2 2\n2 2 0\n2 0 1\n\nExplanation:\nStart from (1,1) with color 1, fill connected 1s with 2.\n\nInput:\n2 2\n0 0\n0 0\n0 0 1\n\nOutput:\n1 1\n1 1</code></pre>\n\n<ul>\n<li>1 ≤ m, n ≤ 50</li>\n<li>0 ≤ grid[i][j], newColor ≤ 65535</li>\n<li>Start position will always be within grid bounds</li>\n</ul>\n\n<b>Pro Tip:</b> Use DFS or BFS to recursively change connected cells of the original color. Make sure to avoid revisiting or infinite loops.",
    sampleTestCases: [
      {
        input: '3 3\n1 1 1\n1 1 0\n1 0 1\n1 1 2',
        expected: '2 2 2\n2 2 0\n2 0 1',
      },
      {
        input: '2 2\n0 0\n0 0\n0 0 1',
        expected: '1 1\n1 1',
      },
    ],
    testCases: [
      {
        input: '3 3\n1 1 1\n1 1 0\n1 0 1\n1 1 2',
        expected: '2 2 2\n2 2 0\n2 0 1',
      },
      {
        input: '2 2\n0 0\n0 0\n0 0 1',
        expected: '1 1\n1 1',
      },
      {
        input: '3 3\n1 1 1\n1 2 0\n1 0 1\n1 1 3',
        expected: '3 3 3\n3 2 0\n3 0 1',
      },
      {
        input: '3 3\n1 2 2\n2 2 2\n2 2 1\n0 0 3',
        expected: '3 2 2\n2 2 2\n2 2 1',
      },
      {
        input: '1 1\n0\n0 0 2',
        expected: '2',
      },
      {
        input: '2 3\n1 1 0\n0 1 1\n0 1 9',
        expected: '1 1 0\n0 9 9',
      },
      {
        input: '3 4\n1 1 1 1\n1 0 0 1\n1 1 1 1\n1 1 8',
        expected: '8 8 8 8\n8 0 0 8\n8 8 8 8',
      },
      {
        input: '2 2\n1 1\n1 0\n0 0 3',
        expected: '1 1\n1 0',
      },
      {
        input: '2 2\n1 1\n1 1\n1 1 4',
        expected: '4 4\n4 4',
      },
      {
        input: '1 3\n2 2 2\n0 1 5',
        expected: '2 5 2',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re building a paint tool, and when a user clicks on a pixel, you need to fill the entire connected area of the same color with a new one. Can you write a flood-fill function using DFS?',
    categories: ['dfs', 'matrix', 'graph traversal'],
    difficulty: 'easy',
    frequency: 80,
    tags: ['dfs', 'matrix', 'graph traversal'],
    companies: [
      { name: 'Adobe', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Check if the current cell has the original color.',
      'Explore all four directions recursively.',
      'Avoid overwriting already-filled cells.',
    ],
    optimalComplexity: {
      time: 'O(m * n)',
      space: 'O(m * n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const lines = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const [m, n] = lines[0].split(" ").map(Number);\n  const image = lines.slice(1, m + 1).map(line => line.split(" ").map(Number));\n  const [sr, sc, newColor] = lines[m + 1].split(" ").map(Number);\n  const result = floodFill(image, sr, sc, newColor);\n  result.forEach(row => console.log(row.join(" ")));\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    m, n = map(int, lines[0].split())\n    image = [list(map(int, line.split())) for line in lines[1:m+1]]\n    sr, sc, newColor = map(int, lines[m+1].split())\n    result = floodFill(image, sr, sc, newColor)\n    for row in result:\n        print(' '.join(map(str, row)))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int m = sc.nextInt(), n = sc.nextInt();\n    int[][] image = new int[m][n];\n    for (int i = 0; i < m; i++)\n      for (int j = 0; j < n; j++)\n        image[i][j] = sc.nextInt();\n    int sr = sc.nextInt(), scn = sc.nextInt(), newColor = sc.nextInt();\n    int[][] result = Solution.floodFill(image, sr, scn, newColor);\n    for (int[] row : result) {\n      for (int i = 0; i < row.length; i++) System.out.print(row[i] + (i < row.length - 1 ? " " : ""));\n      System.out.println();\n    }\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor);\nint main() {\n  int m, n; cin >> m >> n;\n  vector<vector<int>> image(m, vector<int>(n));\n  for (int i = 0; i < m; ++i)\n    for (int j = 0; j < n; ++j)\n      cin >> image[i][j];\n  int sr, sc, newColor; cin >> sr >> sc >> newColor;\n  auto res = floodFill(image, sr, sc, newColor);\n  for (auto& row : res) {\n    for (int i = 0; i < row.size(); ++i) cout << row[i] << (i < row.size() - 1 ? " " : "");\n    cout << "\\n";\n  }\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function floodFill(image, sr, sc, newColor) {\n  // write code here\n  return image;\n}',
      },
      {
        language: 'python',
        code: 'def floodFill(image, sr, sc, newColor):\n    # write code here\n    return image',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n    // write code here\n    return image;\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\nusing namespace std;\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\n  // write code here\n  return image;\n}',
      },
    ],
  },
  {
    title: 'Josephus Problem',
    slug: 'josephus-problem',
    description:
      'Determine the safe position in the Josephus problem given n people and every k-th person eliminated.',
    problemStatement:
      'There are `n` people standing in a circle, numbered from `1` to `n`. Starting from the first person, you count each person clockwise and eliminate every `k`-th person. The circle shrinks after each elimination. This process continues until only one person remains. \n\nYour task is to find the safe position — the number of the person who will remain at the end.\n\nExamples:\n\n<pre><code>Input:\n7 3\n\nOutput:\n4\n\nExplanation:\nPeople are eliminated in this order: 3, 6, 2, 7, 5, 1. Person 4 survives.\n\nInput:\n5 2\n\nOutput:\n3</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 10^5</li>\n<li>1 ≤ k ≤ n</li>\n<li>Return the 1-based index of the safe position</li>\n</ul>\n\n<b>Pro Tip:</b> Use recursion or simulate the process iteratively. A well-known recurrence relation exists: `f(n, k) = (f(n - 1, k) + k) % n`, with base case `f(1, k) = 0` (0-indexed).',
    sampleTestCases: [
      {
        input: '7 3',
        expected: '4',
      },
      {
        input: '5 2',
        expected: '3',
      },
    ],
    testCases: [
      {
        input: '1 1',
        expected: '1',
      },
      {
        input: '2 1',
        expected: '2',
      },
      {
        input: '3 2',
        expected: '3',
      },
      {
        input: '4 2',
        expected: '1',
      },
      {
        input: '6 7',
        expected: '5',
      },
      {
        input: '10 1',
        expected: '10',
      },
      {
        input: '10 2',
        expected: '5',
      },
      {
        input: '20 5',
        expected: '3',
      },
      {
        input: '30 7',
        expected: '16',
      },
      {
        input: '100 13',
        expected: '34',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Imagine a deadly game where every k-th person in a circle is eliminated until one survives. Can you determine the safe position for survival?',
    categories: ['math', 'recursion', 'simulation'],
    difficulty: 'medium',
    frequency: 82,
    tags: ['math', 'recursion', 'circular array', 'simulation'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Try solving it recursively with base case 0 for 1 person.',
      'The recurrence f(n, k) = (f(n - 1, k) + k) % n gives position in 0-indexing.',
      'Convert 0-indexed answer to 1-based before returning.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [n, k] = fs.readFileSync(0, "utf-8").trim().split(" ").map(Number);\n  console.log(josephus(n, k));\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    n, k = map(int, sys.stdin.read().strip().split())\n    print(josephus(n, k))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n public static void main(String[] args) {\n   Scanner sc = new Scanner(System.in);\n   int n = sc.nextInt();\n   int k = sc.nextInt();\n   System.out.println(Solution.josephus(n, k));\n }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nint josephus(int n, int k);\nint main() {\n  int n, k; cin >> n >> k;\n  cout << josephus(n, k) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function josephus(n, k) {\n  // write code here\n  return -1;\n}',
      },
      {
        language: 'python',
        code: 'def josephus(n, k):\n    # write code here\n    return -1',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static int josephus(int n, int k) {\n    // write code here\n    return -1;\n  }\n}',
      },
      {
        language: 'cpp',
        code: 'int josephus(int n, int k) {\n  // write code here\n  return -1;\n}',
      },
    ],
  },
  {
    title: 'Josephus Problem',
    slug: 'josephus-problem',
    description:
      'Determine the safe position in the Josephus problem given n people and every k-th person eliminated.',
    problemStatement:
      'There are `n` people standing in a circle, numbered from `1` to `n`. Starting from the first person, you count each person clockwise and eliminate every `k`-th person. The circle shrinks after each elimination. This process continues until only one person remains. \n\nYour task is to find the safe position — the number of the person who will remain at the end.\n\nExamples:\n\n<pre><code>Input:\n7 3\n\nOutput:\n4\n\nExplanation:\nPeople are eliminated in this order: 3, 6, 2, 7, 5, 1. Person 4 survives.\n\nInput:\n5 2\n\nOutput:\n3</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 10^5</li>\n<li>1 ≤ k ≤ n</li>\n<li>Return the 1-based index of the safe position</li>\n</ul>\n\n<b>Pro Tip:</b> Use recursion or simulate the process iteratively. A well-known recurrence relation exists: `f(n, k) = (f(n - 1, k) + k) % n`, with base case `f(1, k) = 0` (0-indexed).',
    sampleTestCases: [
      {
        input: '7 3',
        expected: '4',
      },
      {
        input: '5 2',
        expected: '3',
      },
    ],
    testCases: [
      {
        input: '1 1',
        expected: '1',
      },
      {
        input: '2 1',
        expected: '2',
      },
      {
        input: '3 2',
        expected: '3',
      },
      {
        input: '4 2',
        expected: '1',
      },
      {
        input: '6 7',
        expected: '5',
      },
      {
        input: '10 1',
        expected: '10',
      },
      {
        input: '10 2',
        expected: '5',
      },
      {
        input: '20 5',
        expected: '3',
      },
      {
        input: '30 7',
        expected: '16',
      },
      {
        input: '100 13',
        expected: '34',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Imagine a deadly game where every k-th person in a circle is eliminated until one survives. Can you determine the safe position for survival?',
    categories: ['math', 'recursion', 'simulation'],
    difficulty: 'medium',
    frequency: 82,
    tags: ['math', 'recursion', 'circular array', 'simulation'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Try solving it recursively with base case 0 for 1 person.',
      'The recurrence f(n, k) = (f(n - 1, k) + k) % n gives position in 0-indexing.',
      'Convert 0-indexed answer to 1-based before returning.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [n, k] = fs.readFileSync(0, "utf-8").trim().split(" ").map(Number);\n  console.log(josephus(n, k));\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    n, k = map(int, sys.stdin.read().strip().split())\n    print(josephus(n, k))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n public static void main(String[] args) {\n   Scanner sc = new Scanner(System.in);\n   int n = sc.nextInt();\n   int k = sc.nextInt();\n   System.out.println(Solution.josephus(n, k));\n }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nint josephus(int n, int k);\nint main() {\n  int n, k; cin >> n >> k;\n  cout << josephus(n, k) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function josephus(n, k) {\n  // write code here\n  return -1;\n}',
      },
      {
        language: 'python',
        code: 'def josephus(n, k):\n    # write code here\n    return -1',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static int josephus(int n, int k) {\n    // write code here\n    return -1;\n  }\n}',
      },
      {
        language: 'cpp',
        code: 'int josephus(int n, int k) {\n  // write code here\n  return -1;\n}',
      },
    ],
  },
  {
    title: 'Tower of Hanoi',
    slug: 'tower-of-hanoi',
    description:
      'Print the sequence of moves to solve the Tower of Hanoi problem with n disks.',
    problemStatement:
      'The Tower of Hanoi is a classic recursive problem where you have three rods and `n` disks. The disks are initially stacked on the first rod in order of size (largest at the bottom, smallest at the top). Your task is to move all the disks to the third rod using the second rod as an auxiliary. \n\nYou can only move one disk at a time, and a larger disk can never be placed on top of a smaller disk. \n\nPrint each move as a line: "Move disk X from rod A to rod B".\n\nExamples:\n\n<pre><code>Input:\n2\n\nOutput:\nMove disk 1 from rod 1 to rod 2\nMove disk 2 from rod 1 to rod 3\nMove disk 1 from rod 2 to rod 3</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 20</li>\n<li>Use 1-based rod numbers: 1, 2, 3</li>\n</ul>\n\n<b>Pro Tip:</b> Use recursion: move n-1 disks to the auxiliary rod, move the largest to the target, then move the n-1 disks to the target.',
    sampleTestCases: [
      {
        input: '2',
        expected:
          'Move disk 1 from rod 1 to rod 2\nMove disk 2 from rod 1 to rod 3\nMove disk 1 from rod 2 to rod 3',
      },
      {
        input: '1',
        expected: 'Move disk 1 from rod 1 to rod 3',
      },
    ],
    testCases: [
      {
        input: '1',
        expected: 'Move disk 1 from rod 1 to rod 3',
      },
      {
        input: '2',
        expected:
          'Move disk 1 from rod 1 to rod 2\nMove disk 2 from rod 1 to rod 3\nMove disk 1 from rod 2 to rod 3',
      },
      {
        input: '3',
        expected:
          'Move disk 1 from rod 1 to rod 3\nMove disk 2 from rod 1 to rod 2\nMove disk 1 from rod 3 to rod 2\nMove disk 3 from rod 1 to rod 3\nMove disk 1 from rod 2 to rod 1\nMove disk 2 from rod 2 to rod 3\nMove disk 1 from rod 1 to rod 3',
      },
      {
        input: '4',
        expected:
          'Move disk 1 from rod 1 to rod 2\nMove disk 2 from rod 1 to rod 3\nMove disk 1 from rod 2 to rod 3\nMove disk 3 from rod 1 to rod 2\nMove disk 1 from rod 3 to rod 1\nMove disk 2 from rod 3 to rod 2\nMove disk 1 from rod 1 to rod 2\nMove disk 4 from rod 1 to rod 3\nMove disk 1 from rod 2 to rod 3\nMove disk 2 from rod 2 to rod 1\nMove disk 1 from rod 3 to rod 1\nMove disk 3 from rod 2 to rod 3\nMove disk 1 from rod 1 to rod 2\nMove disk 2 from rod 1 to rod 3\nMove disk 1 from rod 2 to rod 3',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'The Tower of Hanoi is a famous puzzle that tests your understanding of recursion. Can you write a function to print all the steps needed to solve it for n disks?',
    categories: ['recursion', 'backtracking'],
    difficulty: 'easy',
    frequency: 78,
    tags: ['recursion', 'math', 'divide and conquer'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Move n-1 disks to auxiliary rod first.',
      'Move the largest disk to target rod.',
      'Then move n-1 disks from auxiliary to target rod.',
    ],
    optimalComplexity: {
      time: 'O(2^n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const n = parseInt(fs.readFileSync(0, "utf-8").trim());\n  const moves = [];\n  towerOfHanoi(n, 1, 3, 2, moves);\n  for (let move of moves) console.log(move);\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    n = int(sys.stdin.read().strip())\n    moves = []\n    towerOfHanoi(n, 1, 3, 2, moves)\n    for move in moves:\n        print(move)",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    List<String> moves = new ArrayList<>();\n    Solution.towerOfHanoi(n, 1, 3, 2, moves);\n    for (String move : moves) System.out.println(move);\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nvoid towerOfHanoi(int n, int from, int to, int aux, vector<string>& moves);\nint main() {\n  int n; cin >> n;\n  vector<string> moves;\n  towerOfHanoi(n, 1, 3, 2, moves);\n  for (auto& m : moves) cout << m << "\\n";\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function towerOfHanoi(n, from, to, aux, moves) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def towerOfHanoi(n, from_rod, to_rod, aux_rod, moves):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static void towerOfHanoi(int n, int from, int to, int aux, List<String> moves) {\n    // write code here\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\n#include <string>\nusing namespace std;\nvoid towerOfHanoi(int n, int from, int to, int aux, vector<string>& moves) {\n  // write code here\n}',
      },
    ],
  },
  {
    title: 'Generate Gray Code',
    slug: 'generate-gray-code',
    description: 'Generate the n-bit Gray code sequence.',
    problemStatement:
      'The n-bit Gray code is a sequence of 2^n integers where:\n- The first number is 0\n- Each subsequent number differs from the previous one by exactly one bit\n- All numbers are distinct and cover the range from 0 to 2^n - 1\n\nReturn the Gray code sequence as a list of integers in order.\n\nExamples:\n\n<pre><code>Input:\n2\n\nOutput:\n[0, 1, 3, 2]\n\nExplanation:\nBinary representations:\n00 → 0\n01 → 1\n11 → 3\n10 → 2\n\nInput:\n3\n\nOutput:\n[0, 1, 3, 2, 6, 7, 5, 4]</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 16</li>\n<li>Return the sequence as an array of integers</li>\n<li>Use integer math, not strings</li>\n</ul>\n\n<b>Pro Tip:</b> Gray codes can be generated by `i ^ (i >> 1)` for i in range(0, 2^n).',
    sampleTestCases: [
      {
        input: '2',
        expected: '[0, 1, 3, 2]',
      },
      {
        input: '3',
        expected: '[0, 1, 3, 2, 6, 7, 5, 4]',
      },
    ],
    testCases: [
      {
        input: '1',
        expected: '[0, 1]',
      },
      {
        input: '2',
        expected: '[0, 1, 3, 2]',
      },
      {
        input: '3',
        expected: '[0, 1, 3, 2, 6, 7, 5, 4]',
      },
      {
        input: '4',
        expected: '[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8]',
      },
      {
        input: '5',
        expected:
          '[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16]',
      },
      {
        input: '6',
        expected:
          '[0,1,3,2,6,7,5,4,12,13,15,14,10,11,9,8,24,25,27,26,30,31,29,28,20,21,23,22,18,19,17,16,48,49,51,50,54,55,53,52,60,61,63,62,58,59,57,56,40,41,43,42,46,47,45,44,36,37,39,38,34,35,33,32]',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Gray code is useful in encoding and error minimization. Can you generate a Gray code sequence for n-bit binary numbers in minimal change order?',
    categories: ['bit manipulation', 'math'],
    difficulty: 'medium',
    frequency: 76,
    tags: ['bit manipulation', 'math', 'binary'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Qualcomm', logoUrl: '' },
    ],
    hints: [
      'The i-th Gray code value can be computed using i ^ (i >> 1).',
      'Gray code ensures only one bit flips at a time.',
      'You can precompute all values using a loop up to 2^n.',
    ],
    optimalComplexity: {
      time: 'O(2^n)',
      space: 'O(2^n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const n = parseInt(fs.readFileSync(0, "utf-8").trim());\n  const result = grayCode(n);\n  console.log("[" + result.join(", ") + "]");\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    n = int(sys.stdin.read().strip())\n    res = grayCode(n)\n    print(f\"[{', '.join(map(str, res))}]\")",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n public static void main(String[] args) {\n   Scanner sc = new Scanner(System.in);\n   int n = Integer.parseInt(sc.nextLine());\n   List<Integer> res = Solution.grayCode(n);\n   System.out.print("[");\n   for (int i = 0; i < res.size(); i++) {\n     System.out.print(res.get(i));\n     if (i < res.size() - 1) System.out.print(", ");\n   }\n   System.out.println("]");\n }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nvector<int> grayCode(int n);\nint main() {\n  int n; cin >> n;\n  auto res = grayCode(n);\n  cout << "[";\n  for (int i = 0; i < res.size(); ++i) cout << res[i] << (i < res.size() - 1 ? ", " : "");\n  cout << "]" << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function grayCode(n) {\n  // write code here\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def grayCode(n):\n    # write code here\n    return []',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static List<Integer> grayCode(int n) {\n    // write code here\n    return new ArrayList<>();\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\nusing namespace std;\nvector<int> grayCode(int n) {\n  // write code here\n  return {};\n}',
      },
    ],
  },
  {
    title: 'Word Break Problem',
    slug: 'word-break-problem',
    description:
      'Check if a string can be segmented into a space-separated sequence of one or more dictionary words.',
    problemStatement:
      'You\'re given a string `s` and a list of words called `wordDict`. Return `true` if `s` can be segmented into one or more words that all exist in `wordDict`. You may reuse dictionary words any number of times.\n\nExamples:\n\n<pre><code>Input:\nleetcode\n["leet", "code"]\n\nOutput:\ntrue\n\nExplanation:\nThe string can be segmented as "leet code"\n\nInput:\napplepenapple\n["apple", "pen"]\n\nOutput:\ntrue\n\nInput:\ncatsandog\n["cats", "dog", "sand", "and", "cat"]\n\nOutput:\nfalse</code></pre>\n\n<ul>\n<li>1 ≤ s.length ≤ 300</li>\n<li>1 ≤ wordDict.length ≤ 1000</li>\n<li>1 ≤ word.length ≤ 20</li>\n<li>All strings consist of lowercase English letters</li>\n<li>wordDict does not contain duplicates</li>\n</ul>\n\n<b>Pro Tip:</b> Use dynamic programming to check if any prefix of the string can be broken into words from the dictionary.',
    sampleTestCases: [
      {
        input: 'leetcode\nleet code',
        expected: 'true',
      },
      {
        input: 'applepenapple\napple pen',
        expected: 'true',
      },
      {
        input: 'catsandog\ncats dog sand and cat',
        expected: 'false',
      },
    ],
    testCases: [
      {
        input: 'leetcode\nleet code',
        expected: 'true',
      },
      {
        input: 'applepenapple\napple pen',
        expected: 'true',
      },
      {
        input: 'catsandog\ncats dog sand and cat',
        expected: 'false',
      },
      {
        input: 'catsanddog\ncat cats and dog',
        expected: 'true',
      },
      {
        input: 'pineapplepenapple\napple pen applepen pineapple pine',
        expected: 'true',
      },
      {
        input: 'aaaaaaa\naaa aa',
        expected: 'true',
      },
      {
        input: 'abcd\na bc d abc',
        expected: 'true',
      },
      {
        input: 'a\nb',
        expected: 'false',
      },
      {
        input:
          'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\na aaaa aa aaa aaaa aaaaa',
        expected: 'false',
      },
      {
        input: 'cars\ncar ca rs',
        expected: 'true',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're working on a language processing engine and need to check if a string can be split into dictionary words. Can you implement a function for that?",
    categories: ['dynamic programming', 'string'],
    difficulty: 'medium',
    frequency: 88,
    tags: ['dp', 'string', 'hash set'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Apple', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Use a boolean dp array where dp[i] is true if s[0..i-1] can be segmented.',
      'Try every possible word ending at position i.',
      'Use a HashSet for word lookup in O(1).',
    ],
    optimalComplexity: {
      time: 'O(n^2)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [s, dictLine] = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const wordDict = new Set(dictLine.split(" "));\n  console.log(wordBreak(s, Array.from(wordDict)));\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    s = lines[0]\n    wordDict = lines[1].split()\n    print(wordBreak(s, wordDict))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n public static void main(String[] args) {\n   Scanner sc = new Scanner(System.in);\n   String s = sc.nextLine();\n   String[] dictArr = sc.nextLine().split(" ");\n   List<String> wordDict = Arrays.asList(dictArr);\n   System.out.println(Solution.wordBreak(s, wordDict));\n }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nbool wordBreak(string s, vector<string>& wordDict);\nint main() {\n  string s; getline(cin, s);\n  string line; getline(cin, line);\n  istringstream iss(line);\n  vector<string> wordDict{istream_iterator<string>{iss}, {}};\n  cout << (wordBreak(s, wordDict) ? "true" : "false") << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function wordBreak(s, wordDict) {\n  // write code here\n  return false;\n}',
      },
      {
        language: 'python',
        code: 'def wordBreak(s, wordDict):\n    # write code here\n    return False',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static boolean wordBreak(String s, List<String> wordDict) {\n    // write code here\n    return false;\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\n#include <string>\nusing namespace std;\nbool wordBreak(string s, vector<string>& wordDict) {\n  // write code here\n  return false;\n}',
      },
    ],
  },
  {
    title: 'M Coloring Problem',
    slug: 'm-coloring-problem',
    description:
      'Determine if a graph can be colored with at most M colors such that no two adjacent vertices share the same color.',
    problemStatement:
      'Given an undirected graph represented by an adjacency matrix of size `n x n`, and an integer `m`, determine whether it is possible to color all vertices using at most `m` colors such that no two adjacent vertices share the same color.\n\nEach cell `graph[i][j] = 1` indicates an edge between vertex `i` and vertex `j`. Return `true` if a valid coloring exists, otherwise return `false`.\n\nExamples:\n\n<pre><code>Input:\n4 3\n0 1 1 1\n1 0 1 0\n1 1 0 1\n1 0 1 0\n\nOutput:\ntrue\n\nExplanation:\nIt is possible to color the graph using 3 colors.\n\nInput:\n4 2\n0 1 1 1\n1 0 1 0\n1 1 0 1\n1 0 1 0\n\nOutput:\nfalse</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 20</li>\n<li>1 ≤ m ≤ n</li>\n<li>graph[i][j] is 0 or 1</li>\n<li>graph[i][i] = 0 (no self-loops)</li>\n</ul>\n\n<b>Pro Tip:</b> Use backtracking to assign colors to each vertex and check for conflicts with adjacent nodes.',
    sampleTestCases: [
      {
        input: '4 3\n0 1 1 1\n1 0 1 0\n1 1 0 1\n1 0 1 0',
        expected: 'true',
      },
      {
        input: '4 2\n0 1 1 1\n1 0 1 0\n1 1 0 1\n1 0 1 0',
        expected: 'false',
      },
    ],
    testCases: [
      {
        input: '3 3\n0 1 1\n1 0 1\n1 1 0',
        expected: 'true',
      },
      {
        input: '3 2\n0 1 1\n1 0 1\n1 1 0',
        expected: 'false',
      },
      {
        input: '4 4\n0 1 0 1\n1 0 1 0\n0 1 0 1\n1 0 1 0',
        expected: 'true',
      },
      {
        input: '5 3\n0 1 1 0 0\n1 0 1 1 0\n1 1 0 1 1\n0 1 1 0 1\n0 0 1 1 0',
        expected: 'true',
      },
      {
        input: '5 2\n0 1 1 0 0\n1 0 1 1 0\n1 1 0 1 1\n0 1 1 0 1\n0 0 1 1 0',
        expected: 'false',
      },
      {
        input: '2 1\n0 1\n1 0',
        expected: 'false',
      },
      {
        input: '2 2\n0 1\n1 0',
        expected: 'true',
      },
      {
        input: '1 1\n0',
        expected: 'true',
      },
      {
        input: '4 2\n0 1 0 1\n1 0 1 0\n0 1 0 1\n1 0 1 0',
        expected: 'true',
      },
      {
        input: '4 1\n0 0 0 0\n0 0 0 0\n0 0 0 0\n0 0 0 0',
        expected: 'true',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Suppose you have a graph and want to assign colors to vertices such that no two adjacent ones have the same color. Can you determine if this is possible with at most M colors?',
    categories: ['graph', 'backtracking'],
    difficulty: 'medium',
    frequency: 79,
    tags: ['graph coloring', 'backtracking', 'recursion'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Use backtracking to try every color for each vertex.',
      'Ensure no adjacent vertex has the same color before assigning.',
      'If all vertices are colored successfully, return true.',
    ],
    optimalComplexity: {
      time: 'O(m^n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const lines = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const [n, m] = lines[0].split(" ").map(Number);\n  const graph = lines.slice(1, n + 1).map(row => row.split(" ").map(Number));\n  console.log(graphColoring(graph, m) ? "true" : "false");\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n, m = map(int, lines[0].split())\n    graph = [list(map(int, line.split())) for line in lines[1:n+1]]\n    print('true' if graphColoring(graph, m) else 'false')",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n public static void main(String[] args) {\n   Scanner sc = new Scanner(System.in);\n   int n = sc.nextInt(), m = sc.nextInt();\n   int[][] graph = new int[n][n];\n   for (int i = 0; i < n; i++)\n     for (int j = 0; j < n; j++)\n       graph[i][j] = sc.nextInt();\n   System.out.println(Solution.graphColoring(graph, m) ? "true" : "false");\n }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nbool graphColoring(vector<vector<int>>& graph, int m);\nint main() {\n  int n, m; cin >> n >> m;\n  vector<vector<int>> graph(n, vector<int>(n));\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j)\n      cin >> graph[i][j];\n  cout << (graphColoring(graph, m) ? "true" : "false") << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function graphColoring(graph, m) {\n  // write code here\n  return false;\n}',
      },
      {
        language: 'python',
        code: 'def graphColoring(graph, m):\n    # write code here\n    return False',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static boolean graphColoring(int[][] graph, int m) {\n    // write code here\n    return false;\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\nusing namespace std;\nbool graphColoring(vector<vector<int>>& graph, int m) {\n  // write code here\n  return false;\n}',
      },
    ],
  },
  {
    title: 'Tug of War (Min Difference Split)',
    slug: 'tug-of-war-min-difference-split',
    description:
      'Divide an array into two groups with minimal difference in their sums and equal size (or one extra element allowed).',
    problemStatement:
      'You are given an array of integers. Your task is to split it into two groups such that:\n- The number of elements in each group is equal or differs by at most one.\n- The absolute difference between the sums of the two groups is minimized.\n\nReturn the minimum possible difference.\n\nExamples:\n\n<pre><code>Input:\n[1, 2, 3, 4]\n\nOutput:\n0\n\nExplanation:\nGroup1 = [1, 4], Group2 = [2, 3] → sum1 = 5, sum2 = 5\n\nInput:\n[1, 2, 3, 9]\n\nOutput:\n3\n\nExplanation:\nGroup1 = [1, 2, 3], Group2 = [9] → sum1 = 6, sum2 = 9 → diff = 3</code></pre>\n\n<ul>\n<li>2 ≤ arr.length ≤ 30</li>\n<li>-10^4 ≤ arr[i] ≤ 10^4</li>\n</ul>\n\n<b>Pro Tip:</b> Use backtracking with pruning to try including/excluding elements and track minimal difference while maintaining group sizes.',
    sampleTestCases: [
      {
        input: '1 2 3 4',
        expected: '0',
      },
      {
        input: '1 2 3 9',
        expected: '3',
      },
    ],
    testCases: [
      {
        input: '1 2 3 4',
        expected: '0',
      },
      {
        input: '1 2 3 9',
        expected: '3',
      },
      {
        input: '1 6 11 5',
        expected: '1',
      },
      {
        input: '10 20 15 5 25',
        expected: '5',
      },
      {
        input: '4 5 6 7 8 9',
        expected: '1',
      },
      {
        input: '5 5 5 5',
        expected: '0',
      },
      {
        input: '1 2',
        expected: '1',
      },
      {
        input: '1 1 1 1 1',
        expected: '1',
      },
      {
        input: '1000 -1000 500 -500',
        expected: '0',
      },
      {
        input: '-10 -20 -30 10 20 30',
        expected: '0',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'In a game of tug of war, you want to divide players into two balanced teams based on strength. How would you split an array into two groups with minimal difference in total strength?',
    categories: ['backtracking', 'partition'],
    difficulty: 'hard',
    frequency: 75,
    tags: ['backtracking', 'subset sum', 'partition'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Track group sizes and sums as you recurse.',
      'Stop early if group sizes exceed allowed size.',
      'Track the minimal absolute difference found.',
    ],
    optimalComplexity: {
      time: 'O(2^n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const arr = fs.readFileSync(0, "utf-8").trim().split(" ").map(Number);\n  console.log(tugOfWar(arr));\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    arr = list(map(int, sys.stdin.read().strip().split()))\n    print(tugOfWar(arr))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n public static void main(String[] args) {\n   Scanner sc = new Scanner(System.in);\n   String[] tokens = sc.nextLine().split(" ");\n   int[] arr = new int[tokens.length];\n   for (int i = 0; i < tokens.length; i++) arr[i] = Integer.parseInt(tokens[i]);\n   System.out.println(Solution.tugOfWar(arr));\n }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nint tugOfWar(vector<int>& arr);\nint main() {\n  string line; getline(cin, line);\n  istringstream iss(line);\n  vector<int> arr{istream_iterator<int>{iss}, {}};\n  cout << tugOfWar(arr) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function tugOfWar(arr) {\n  // write code here\n  return 0;\n}',
      },
      {
        language: 'python',
        code: 'def tugOfWar(arr):\n    # write code here\n    return 0',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static int tugOfWar(int[] arr) {\n    // write code here\n    return 0;\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\nusing namespace std;\nint tugOfWar(vector<int>& arr) {\n  // write code here\n  return 0;\n}',
      },
    ],
  },
  {
    title: 'Tug of War (Min Difference Split)',
    slug: 'tug-of-war-min-difference-split',
    description:
      'Divide an array into two groups with minimal difference in their sums and equal size (or one extra element allowed).',
    problemStatement:
      'You are given an array of integers. Your task is to split it into two groups such that:\n- The number of elements in each group is equal or differs by at most one.\n- The absolute difference between the sums of the two groups is minimized.\n\nReturn the minimum possible difference.\n\nExamples:\n\n<pre><code>Input:\n[1, 2, 3, 4]\n\nOutput:\n0\n\nExplanation:\nGroup1 = [1, 4], Group2 = [2, 3] → sum1 = 5, sum2 = 5\n\nInput:\n[1, 2, 3, 9]\n\nOutput:\n3\n\nExplanation:\nGroup1 = [1, 2, 3], Group2 = [9] → sum1 = 6, sum2 = 9 → diff = 3</code></pre>\n\n<ul>\n<li>2 ≤ arr.length ≤ 30</li>\n<li>-10^4 ≤ arr[i] ≤ 10^4</li>\n</ul>\n\n<b>Pro Tip:</b> Use backtracking with pruning to try including/excluding elements and track minimal difference while maintaining group sizes.',
    sampleTestCases: [
      {
        input: '1 2 3 4',
        expected: '0',
      },
      {
        input: '1 2 3 9',
        expected: '3',
      },
    ],
    testCases: [
      {
        input: '1 2 3 4',
        expected: '0',
      },
      {
        input: '1 2 3 9',
        expected: '3',
      },
      {
        input: '1 6 11 5',
        expected: '1',
      },
      {
        input: '10 20 15 5 25',
        expected: '5',
      },
      {
        input: '4 5 6 7 8 9',
        expected: '1',
      },
      {
        input: '5 5 5 5',
        expected: '0',
      },
      {
        input: '1 2',
        expected: '1',
      },
      {
        input: '1 1 1 1 1',
        expected: '1',
      },
      {
        input: '1000 -1000 500 -500',
        expected: '0',
      },
      {
        input: '-10 -20 -30 10 20 30',
        expected: '0',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'In a game of tug of war, you want to divide players into two balanced teams based on strength. How would you split an array into two groups with minimal difference in total strength?',
    categories: ['backtracking', 'partition'],
    difficulty: 'hard',
    frequency: 75,
    tags: ['backtracking', 'subset sum', 'partition'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Track group sizes and sums as you recurse.',
      'Stop early if group sizes exceed allowed size.',
      'Track the minimal absolute difference found.',
    ],
    optimalComplexity: {
      time: 'O(2^n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const arr = fs.readFileSync(0, "utf-8").trim().split(" ").map(Number);\n  console.log(tugOfWar(arr));\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    arr = list(map(int, sys.stdin.read().strip().split()))\n    print(tugOfWar(arr))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n public static void main(String[] args) {\n   Scanner sc = new Scanner(System.in);\n   String[] tokens = sc.nextLine().split(" ");\n   int[] arr = new int[tokens.length];\n   for (int i = 0; i < tokens.length; i++) arr[i] = Integer.parseInt(tokens[i]);\n   System.out.println(Solution.tugOfWar(arr));\n }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nint tugOfWar(vector<int>& arr);\nint main() {\n  string line; getline(cin, line);\n  istringstream iss(line);\n  vector<int> arr{istream_iterator<int>{iss}, {}};\n  cout << tugOfWar(arr) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function tugOfWar(arr) {\n  // write code here\n  return 0;\n}',
      },
      {
        language: 'python',
        code: 'def tugOfWar(arr):\n    # write code here\n    return 0',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static int tugOfWar(int[] arr) {\n    // write code here\n    return 0;\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\nusing namespace std;\nint tugOfWar(vector<int>& arr) {\n  // write code here\n  return 0;\n}',
      },
    ],
  },
  {
    title: 'Count Ways to Place Tiles',
    slug: 'count-ways-to-place-tiles',
    description:
      'Find the number of ways to tile a 2 x n board using 2 x 1 tiles.',
    problemStatement:
      'You are given an integer `n`, representing the width of a 2 x n board. Your task is to count the number of ways to completely tile the board using 2 x 1 tiles. You can place each tile either vertically or horizontally.\n\nReturn the number of distinct ways to completely fill the board.\n\nExamples:\n\n<pre><code>Input:\n3\n\nOutput:\n3\n\nExplanation:\nThe 3 ways are:\n- Three vertical tiles\n- One horizontal + two vertical\n- Two vertical + one horizontal\n\nInput:\n4\n\nOutput:\n5</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 1000</li>\n<li>Return answer modulo 10^9 + 7</li>\n</ul>\n\n<b>Pro Tip:</b> This is a classic dynamic programming problem: the number of ways to tile n is the sum of ways to tile n-1 and n-2.',
    sampleTestCases: [
      {
        input: '3',
        expected: '3',
      },
      {
        input: '4',
        expected: '5',
      },
    ],
    testCases: [
      {
        input: '1',
        expected: '1',
      },
      {
        input: '2',
        expected: '2',
      },
      {
        input: '3',
        expected: '3',
      },
      {
        input: '4',
        expected: '5',
      },
      {
        input: '5',
        expected: '8',
      },
      {
        input: '10',
        expected: '89',
      },
      {
        input: '20',
        expected: '10946',
      },
      {
        input: '50',
        expected: '20365011074',
      },
      {
        input: '100',
        expected: '573147844013817084101',
      },
      {
        input: '500',
        expected: '139423224561697880139045716410001027',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You are building floor tiling software. Given a 2 x n board, how many ways can you completely tile it using only 2 x 1 tiles?',
    categories: ['dp', 'combinatorics'],
    difficulty: 'easy',
    frequency: 84,
    tags: ['dp', 'fibonacci', 'tiling'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'TCS', logoUrl: '' },
    ],
    hints: [
      'Let dp[i] be the number of ways to tile a 2 x i board.',
      'You can place a tile vertically (1 tile, reduce width by 1) or horizontally (2 tiles, reduce width by 2).',
      'Use modulo 10^9 + 7 for large answers.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const n = parseInt(fs.readFileSync(0, "utf-8").trim());\n  console.log(countWays(n));\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    n = int(sys.stdin.read().strip())\n    print(countWays(n))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n public static void main(String[] args) {\n   Scanner sc = new Scanner(System.in);\n   int n = sc.nextInt();\n   System.out.println(Solution.countWays(n));\n }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nint countWays(int n);\nint main() {\n  int n; cin >> n;\n  cout << countWays(n) << endl;\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function countWays(n) {\n  // write code here\n  return 0;\n}',
      },
      {
        language: 'python',
        code: 'def countWays(n):\n    # write code here\n    return 0',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static int countWays(int n) {\n    // write code here\n    return 0;\n  }\n}',
      },
      {
        language: 'cpp',
        code: 'int countWays(int n) {\n  // write code here\n  return 0;\n}',
      },
    ],
  },
  {
    title: 'Expression Add Operators',
    slug: 'expression-add-operators',
    description:
      'Insert +, -, or * between digits of a numeric string to form expressions that evaluate to a target.',
    problemStatement:
      'Given a string `num` consisting of digits and an integer `target`, insert binary operators (`+`, `-`, `*`) between the digits of `num` so that the resulting mathematical expression evaluates to `target`. Digits must remain in order, and operands must not contain leading zeros unless the operand is exactly \'0\'. Return all valid expressions that evaluate to the target.\n\nExamples:\n\n<pre><code>Input:\nnum = "123", target = 6\nOutput:\n["1+2+3", "1*2*3"]\n\nInput:\nnum = "232", target = 8\nOutput:\n["2*3+2", "2+3*2"]\n\nInput:\nnum = "105", target = 5\nOutput:\n["1*0+5", "10-5"]</code></pre>\n\n<ul>\n<li>1 ≤ num.length ≤ 10</li>\n<li>`num` consists only of digits 0–9</li>\n<li>Operands cannot have leading zeros unless they are \'0\'</li>\n</ul>\n\n<b>Pro Tip:</b> Use backtracking. Keep track of the current expression value, and specially handle multiplication by tracking the last operand (to apply correct precedence). Use DFS to explore all splits and operator placements.',
    sampleTestCases: [
      {
        input: '123\n6',
        expected: '["1+2+3", "1*2*3"]',
      },
      {
        input: '232\n8',
        expected: '["2*3+2", "2+3*2"]',
      },
      {
        input: '105\n5',
        expected: '["1*0+5", "10-5"]',
      },
    ],
    testCases: [
      {
        input: '123\n6',
        expected: '["1+2+3", "1*2*3"]',
      },
      {
        input: '232\n8',
        expected: '["2*3+2", "2+3*2"]',
      },
      {
        input: '105\n5',
        expected: '["1*0+5", "10-5"]',
      },
      {
        input: '00\n0',
        expected: '["0+0", "0-0", "0*0"]',
      },
      {
        input: '3456237490\n9191',
        expected: '[]',
      },
    ],
    topics: ['backtracking', 'string', 'math'],
    interviewExcerpt:
      'Suppose you have a numeric string and want to insert operators between its digits so that the expression equals a target value. You need to generate all valid expressions. How would you approach this?',
    categories: ['backtracking', 'dfs', 'string'],
    difficulty: 'hard',
    frequency: 92,
    tags: ['backtracking', 'operator precedence', 'string manipulation'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      "Avoid numbers with leading zero—unless the number is '0'.",
      'For multiplication, track the last operand to handle precedence correctly.',
      "Use DFS to build expression piece by piece and backtrack if it doesn't match target at end.",
    ],
    optimalComplexity: {
      time: 'O(n * 4^(n‑1))',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [num, targetStr] = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const target = parseInt(targetStr, 10);\n  const result = addOperators(num, target);\n  console.log(JSON.stringify(result));\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    num, target = sys.stdin.read().strip().split('\\n')\n    res = addOperators(num, int(target))\n    print(res)",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String num = sc.nextLine();\n    int target = Integer.parseInt(sc.nextLine());\n    List<String> res = Solution.addOperators(num, target);\n    System.out.println(res);\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nvector<string> addOperators(string num, int target);\nint main() {\n  string num;\n  int target;\n  getline(cin, num);\n  cin >> target;\n  auto res = addOperators(num, target);\n  cout << "[";\n  for (int i = 0; i < res.size(); i++) {\n    cout << \'"\' << res[i] << \'"\' << (i + 1 < res.size() ? ", " : "");\n  }\n  cout << "]";\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: "function addOperators(num, target) {\n  const result = [];\n  function dfs(index, path, calc, tail) {\n    if (index === num.length) {\n      if (calc === target) result.push(path);\n      return;\n    }\n    for (let i = index; i < num.length; i++) {\n      if (i !== index && num[index] === '0') break;\n      const strNum = num.substring(index, i + 1);\n      const curr = Number(strNum);\n      if (index === 0) {\n        dfs(i + 1, strNum, curr, curr);\n      } else {\n        dfs(i + 1, path + '+' + strNum, calc + curr, curr);\n        dfs(i + 1, path + '-' + strNum, calc - curr, -curr);\n        dfs(i + 1, path + '*' + strNum, calc - tail + tail * curr, tail * curr);\n      }\n    }\n  }\n  dfs(0, \"\", 0, 0);\n  return result;\n}",
      },
      {
        language: 'python',
        code: "def addOperators(num, target):\n    res = []\n    def dfs(index, path, calc, tail):\n        if index == len(num):\n            if calc == target:\n                res.append(path)\n            return\n        for i in range(index, len(num)):\n            if i != index and num[index] == '0':\n                break\n            curr_str = num[index:i+1]\n            curr = int(curr_str)\n            if index == 0:\n                dfs(i+1, curr_str, curr, curr)\n            else:\n                dfs(i+1, path+'+'+curr_str, calc+curr, curr)\n                dfs(i+1, path+'-'+curr_str, calc-curr, -curr)\n                dfs(i+1, path+'*'+curr_str, calc-tail+tail*curr, tail*curr)\n    dfs(0, \"\", 0, 0)\n    return res",
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static List<String> addOperators(String num, int target) {\n    List<String> res = new ArrayList<>();\n    dfs(num, target, 0, 0, 0, "", res);\n    return res;\n  }\n  private static void dfs(String num, int target, int index, long calc, long tail,\n                           String path, List<String> res) {\n    if (index == num.length()) {\n      if (calc == target) res.add(path);\n      return;\n    }\n    for (int i = index; i < num.length(); i++) {\n      if (i != index && num.charAt(index) == \'0\') break;\n      String currStr = num.substring(index, i + 1);\n      long curr = Long.parseLong(currStr);\n      if (index == 0) {\n        dfs(num, target, i + 1, curr, curr, currStr, res);\n      } else {\n        dfs(num, target, i + 1, calc + curr, curr, path + "+" + currStr, res);\n        dfs(num, target, i + 1, calc - curr, -curr, path + "-" + currStr, res);\n        dfs(num, target, i + 1, calc - tail + tail * curr, tail * curr, path + "*" + currStr, res);\n      }\n    }\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\n#include <string>\nusing namespace std;\nvoid dfs(const string &num, int target, int index, long calc, long tail, string path, vector<string> &res) {\n  if (index == num.size()) {\n    if (calc == target) res.push_back(path);\n    return;\n  }\n  for (int i = index; i < num.size(); i++) {\n    if (i != index && num[index] == \'0\') break;\n    string currStr = num.substr(index, i - index + 1);\n    long curr = stol(currStr);\n    if (index == 0) {\n      dfs(num, target, i+1, curr, curr, currStr, res);\n    } else {\n      dfs(num, target, i+1, calc + curr, curr, path + "+" + currStr, res);\n      dfs(num, target, i+1, calc - curr, -curr, path + "-" + currStr, res);\n      dfs(num, target, i+1, calc - tail + tail * curr, tail * curr, path + "*" + currStr, res);\n    }\n  }\n}\nvector<string> addOperators(string num, int target) {\n  vector<string> res;\n  dfs(num, target, 0, 0, 0, "", res);\n  return res;\n}',
      },
    ],
  },
  {
    title: 'Crossword Puzzle Solver',
    slug: 'crossword-puzzle-solver',
    description: 'Fill a crossword grid with given words using backtracking.',
    problemStatement:
      "You are given a rectangular grid of characters where each cell contains either a '+' (blocked) or '-' (empty). You are also given a list of words. Your task is to fill the grid by placing each word in one of the empty slots—horizontally (left to right) or vertically (top to bottom)—such that every empty slot is filled exactly by one word and the letters match at intersections. Return the completed grid.\n\nExamples:\n\n<pre><code>Input:\n+-++++++++\n+-++++++++\n+-++++++++\n+-----++++\n+-+++-++++\n+-+++-++++\n+++++-++++\n+++++-++++\n++++++++++\n----------\nWORD;HELLO;SOLVE\n\nOutput:\n+W++++++++\n+O++++++++\n+R++++++++\n+HELLO++++\n+L+++E++++\n+D+++L++++\n+++++L++++\n+++++O++++\n++++++++++\nSOLVE-----\n</code></pre>\n\n<ul>\n<li>Grid size is m×n where 1 ≤ m, n ≤ 10.</li>\n<li>Words count ≤ 10.</li>\n<li>Solution always exists.</li>\n</ul>\n\n<b>Pro Tip:</b> Use backtracking: find all horizontal and vertical word slots, try placing each word in suitable slots (matching letters, not conflicting), recurse, and backtrack if stuck.",
    sampleTestCases: [
      {
        input:
          '10 10\n+-++++++++\n+-++++++++\n+-++++++++\n+-----++++\n+-+++-++++\n+-+++-++++\n+++++-++++\n+++++-++++\n++++++++++\n----------\nWORD;HELLO;SOLVE',
        expected:
          '+W++++++++\n+O++++++++\n+R++++++++\n+HELLO++++\n+L+++E++++\n+D+++L++++\n+++++L++++\n+++++O++++\n++++++++++\nSOLVE-----',
      },
    ],
    testCases: [
      {
        input: '3 3\n---\n---\n---\nABC;DEF;GHI',
        expected: 'ABC\nDEF\nGHI',
      },
      {
        input: '4 4\n-+-+\n-+-+\n-+-+\n-+-+\nAB;CD;EF;GH',
        expected: 'A+-+\nB+-+\nC+-+\nD+-+',
      },
      {
        input: '5 5\n-----\n-+++ -\n-+++ -\n-+++ -\n-----\nHELLO;WORLD;GO;HOME',
        expected: 'HELLO\n+O++O\n+R++R\n+L++L\nWORLD',
      },
    ],
    topics: ['backtracking', 'dfs', 'string', 'matrix'],
    interviewExcerpt:
      'Given a crossword grid with blanks and a set of words, can you fill it so that all words fit perfectly in horizontal or vertical slots? How would you approach that systematically?',
    categories: ['backtracking', 'constraint satisfaction', 'matrix'],
    difficulty: 'hard',
    frequency: 65,
    tags: ['backtracking', 'grid', 'constraint checking'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      "First identify all contiguous '-' segments horizontally and vertically as slots.",
      'For each slot, try each unused word of matching length and check if letters fit.',
      'Use recursion: after placing a word, recurse; if stuck, undo placement and try the next.',
    ],
    optimalComplexity: {
      time: 'O(k! * m * n * L)',
      space: 'O(m * n + k)',
      note: 'k = number of words, L = average word length',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const [m, n] = input[0].split(" ").map(Number);\n  const grid = input.slice(1, 1 + m).map(line => line.split(\'\'));\n  const words = input[1 + m].split(\';\');\n  const result = crosswordSolver(grid, words);\n  result.forEach(row => console.log(row.join(\'\')));\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    m, n = map(int, lines[0].split())\n    grid = [list(lines[i]) for i in range(1, m+1)]\n    words = lines[m+1].split(';')\n    res = crosswordSolver(grid, words)\n    for row in res:\n        print(''.join(row))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int m = sc.nextInt(), n = sc.nextInt(); sc.nextLine();\n    char[][] grid = new char[m][n];\n    for (int i = 0; i < m; i++) grid[i] = sc.nextLine().toCharArray();\n    String[] words = sc.nextLine().split(";");\n    char[][] res = Solution.crosswordSolver(grid, words);\n    for (char[] row : res) System.out.println(new String(row));\n  }\n}',
      },
      {
        language: 'cpp',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nvector<string> crosswordSolver(vector<string>& grid, vector<string>& words);\nint main() {\n  int m, n; cin >> m >> n;\n  vector<string> grid(m);\n  for (int i = 0; i < m; i++) cin >> grid[i];\n  string line; cin >> line;\n  vector<string> words;\n  istringstream iss(line);\n  string w;\n  while (getline(iss, w, \';\')) words.push_back(w);\n  auto res = crosswordSolver(grid, words);\n  for (auto& row : res) cout << row << "\\n";\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function crosswordSolver(grid, words) {\n  // write code here\n  return grid;\n}',
      },
      {
        language: 'python',
        code: 'def crosswordSolver(grid, words):\n    # write code here\n    return grid',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static char[][] crosswordSolver(char[][] grid, String[] words) {\n    // write code here\n    return grid;\n  }\n}',
      },
      {
        language: 'cpp',
        code: 'vector<string> crosswordSolver(vector<string>& grid, vector<string>& words) {\n  // write code here\n  return grid;\n}',
      },
    ],
  },
  {
    title: 'Crossword Fill Word (DFS Backtracking)',
    slug: 'crossword-fill-word-dfs-backtracking',
    description:
      'Fill a given crossword grid with a list of words using depth-first search and backtracking.',
    problemStatement:
      "You are given a 10x10 crossword grid represented by an array of strings, where each cell is either:\n- '+' (a blocked cell), or\n- '-' (an empty cell to fill with letters).\n\nYou are also given a list of words separated by semicolons. Your task is to fill the grid with the words such that:\n- Each word fills a horizontal or vertical segment of consecutive '-' characters.\n- Each word fits exactly in its segment.\n- Letters at overlapping positions must match.\n\nReturn the completed crossword grid with all words placed appropriately.\n\nExamples:\n\n<pre><code>Input:\n+-++++++++\n+-++++++++\n+-++++++++\n+-----++++\n+-+++-++++\n+-+++-++++\n+++++-++++\n+++++-++++\n++++++++++\n----------\nPOLAND;LHASA;SPAIN;INDIA;NORWAY\n\nOutput:\n+P++++++++\n+O++++++++\n+L++++++++\n+SPAIN++++\n+D+++L++++\n+LHASA++++\n+++++N++++\n+++++D++++\n++++++++++\nINDIA-----</code></pre>\n\n<ul>\n<li>The grid is always 10x10.</li>\n<li>There are at most 10 words, all uppercase A–Z, length ≥ 2.</li>\n<li>Each word can be used exactly once.</li>\n<li>Solution always exists.</li>\n</ul>\n\n<b>Pro Tip:</b> Identify all word slots (horizontally/vertically), try to place words recursively, and backtrack if conflicts arise.",
    sampleTestCases: [
      {
        input:
          '+-++++++++\n+-++++++++\n+-++++++++\n+-----++++\n+-+++-++++\n+-+++-++++\n+++++-++++\n+++++-++++\n++++++++++\n----------\nPOLAND;LHASA;SPAIN;INDIA;NORWAY',
        expected:
          '+P++++++++\n+O++++++++\n+L++++++++\n+SPAIN++++\n+D+++L++++\n+LHASA++++\n+++++N++++\n+++++D++++\n++++++++++\nINDIA-----',
      },
    ],
    testCases: [
      {
        input:
          '+-++++++++\n+-++++++++\n+-++++++++\n+-----++++\n+-+++-++++\n+-+++-++++\n+++++-++++\n+++++-++++\n++++++++++\n----------\nPOLAND;LHASA;SPAIN;INDIA;NORWAY',
        expected:
          '+P++++++++\n+O++++++++\n+L++++++++\n+SPAIN++++\n+D+++L++++\n+LHASA++++\n+++++N++++\n+++++D++++\n++++++++++\nINDIA-----',
      },
      {
        input:
          '++++++++++\n+------+++\n+++-++++++\n+++-++++++\n+++-----++\n+++-++-+++\n++++++-+++\n++++++-+++\n++++++-+++\n++++++++++\nICELAND;MEXICO;PANAMA;ALMATY',
        expected:
          '++++++++++\n+ICELAND++\n+++E++++++\n+++X++++++\n+++ICO+++PANAMA\n+++C++M+++\n++++++E+++\n++++++X+++\n++++++I+++\n++++++++++',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're designing a crossword game. Can you write a function to fill a grid using a set of words with exact fit in available slots, ensuring intersections align correctly?",
    categories: ['backtracking', 'dfs', 'constraint satisfaction'],
    difficulty: 'hard',
    frequency: 70,
    tags: ['backtracking', 'dfs', 'grid', 'constraint-checking'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Detect all horizontal and vertical word slots first.',
      'Try placing each unused word recursively.',
      'Backtrack and restore grid state on conflict.',
    ],
    optimalComplexity: {
      time: 'O(k! * m * n)',
      space: 'O(k + m * n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const lines = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const grid = lines.slice(0, 10).map(line => line.split(\'\'));\n  const words = lines[10].split(\';\');\n  const result = crosswordFill(grid, words);\n  for (const row of result) console.log(row.join(\'\'));\n}\nmain();',
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    grid = [list(line) for line in lines[:10]]\n    words = lines[10].split(';')\n    res = crosswordFill(grid, words)\n    for row in res:\n        print(''.join(row))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    char[][] grid = new char[10][10];\n    for (int i = 0; i < 10; i++) grid[i] = sc.nextLine().toCharArray();\n    String[] words = sc.nextLine().split(";");\n    char[][] res = Solution.crosswordFill(grid, words);\n    for (char[] row : res) System.out.println(new String(row));\n  }\n}',
      },
      {
        language: 'cpp',
        code: "#include <bits/stdc++.h>\nusing namespace std;\nvector<string> crosswordFill(vector<string>& grid, vector<string>& words);\nint main() {\n  vector<string> grid(10);\n  for (int i = 0; i < 10; i++) getline(cin, grid[i]);\n  string wordLine; getline(cin, wordLine);\n  vector<string> words;\n  istringstream iss(wordLine);\n  string w;\n  while (getline(iss, w, ';')) words.push_back(w);\n  auto res = crosswordFill(grid, words);\n  for (auto& row : res) cout << row << '\\n';\n  return 0;\n}",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function crosswordFill(grid, words) {\n  // write code here\n  return grid;\n}',
      },
      {
        language: 'python',
        code: 'def crosswordFill(grid, words):\n    # write code here\n    return grid',
      },
      {
        language: 'java',
        code: 'class Solution {\n  public static char[][] crosswordFill(char[][] grid, String[] words) {\n    // write code here\n    return grid;\n  }\n}',
      },
      {
        language: 'cpp',
        code: 'vector<string> crosswordFill(vector<string>& grid, vector<string>& words) {\n  // write code here\n  return grid;\n}',
      },
    ],
  },
  {
    title: 'Binary Tree Inorder Traversal',
    slug: 'binary-tree-inorder-traversal',
    description:
      'Traverse a binary tree in inorder (left-root-right) order and return the sequence of visited node values.',
    problemStatement:
      'Given the root of a binary tree, return its inorder traversal as a list of integers.\n\nInorder traversal means visiting the left subtree, then the current node, and then the right subtree.\n\nExamples:\n\n<pre><code>Input:\n[1,null,2,3]\n\nOutput:\n[1,3,2]\n\nExplanation:\nThe tree structure is:\n    1\n     \\\n      2\n     /\n    3\n\nThe inorder traversal is: left (null), root (1), left (3), root (2), right (null) → [1,3,2]</code></pre>\n\n<ul>\n<li>0 ≤ Number of nodes ≤ 100</li>\n<li>-100 ≤ Node values ≤ 100</li>\n</ul>\n\n<b>Pro Tip:</b> Use recursion or an iterative stack approach to simulate the traversal. Inorder is typically used to retrieve data from a BST in sorted order.',
    sampleTestCases: [
      {
        input: '1 null 2 3',
        expected: '1 3 2',
      },
      {
        input: '',
        expected: '',
      },
    ],
    testCases: [
      {
        input: '1 null 2 3',
        expected: '1 3 2',
      },
      {
        input: '5 3 6 1 4',
        expected: '1 3 4 5 6',
      },
      {
        input: '2 1 3',
        expected: '1 2 3',
      },
      {
        input: '1',
        expected: '1',
      },
      {
        input: '',
        expected: '',
      },
      {
        input: '1 2 null 3',
        expected: '3 2 1',
      },
      {
        input: '1 null 2 null 3',
        expected: '1 2 3',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you implement the classic inorder traversal for a binary tree? You may use recursion or simulate the call stack using iteration.',
    categories: ['tree', 'dfs'],
    difficulty: 'easy',
    frequency: 95,
    tags: ['inorder', 'dfs', 'binary tree'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Visit the left child, then the current node, then the right child.',
      "Use a stack to simulate recursion if you're doing it iteratively.",
      'In BSTs, this traversal gives sorted values.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\nfunction buildTreeFromLevelOrder(data) {\n  if (!data.length) return null;\n  const nodes = data.split(\' \').map(x => (x === \'null\' ? null : new TreeNode(parseInt(x))));\n  let i = 0, j = 1;\n  while (j < nodes.length) {\n    if (nodes[i] !== null) {\n      nodes[i].left = nodes[j++] || null;\n      if (j < nodes.length) nodes[i].right = nodes[j++] || null;\n    } else i++;\n    i++;\n  }\n  return nodes[0];\n}\nconst fs = require("fs");\nfunction main() {\n  const data = fs.readFileSync(0, "utf-8").trim();\n  const root = buildTreeFromLevelOrder(data);\n  const result = inorderTraversal(root);\n  console.log(result.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(data):\n    if not data: return None\n    vals = data.split()\n    nodes = [TreeNode(int(v)) if v != 'null' else None for v in vals]\n    i = 0\n    for j in range(1, len(nodes), 2):\n        if nodes[i]:\n            if j < len(nodes): nodes[i].left = nodes[j]\n            if j+1 < len(nodes): nodes[i].right = nodes[j+1]\n        i += 1\n    return nodes[0]\n\nif __name__ == '__main__':\n    import sys\n    data = sys.stdin.read().strip()\n    root = build_tree(data)\n    res = inorderTraversal(root)\n    print(' '.join(map(str, res)))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\nclass TreeNode {\n  int val;\n  TreeNode left, right;\n  TreeNode(int x) { val = x; }\n}\nclass Solution {\n  public static TreeNode buildTree(String[] data) {\n    if (data.length == 0 || data[0].equals("null")) return null;\n    TreeNode[] nodes = new TreeNode[data.length];\n    for (int i = 0; i < data.length; i++) {\n      if (!data[i].equals("null")) nodes[i] = new TreeNode(Integer.parseInt(data[i]));\n    }\n    for (int i = 0, j = 1; j < data.length; i++) {\n      if (nodes[i] != null) {\n        if (j < data.length) nodes[i].left = nodes[j++];\n        if (j < data.length) nodes[i].right = nodes[j++];\n      }\n    }\n    return nodes[0];\n  }\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String[] vals = sc.nextLine().split(" ");\n    TreeNode root = buildTree(vals);\n    List<Integer> result = inorderTraversal(root);\n    for (int v : result) System.out.print(v + " ");\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  // No standard tree builder for C — assume static tree in tests\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\nusing namespace std;\nstruct TreeNode {\n  int val;\n  TreeNode *left, *right;\n  TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nTreeNode* buildTree(const vector<string>& vals) {\n  if (vals.empty() || vals[0] == "null") return nullptr;\n  TreeNode* root = new TreeNode(stoi(vals[0]));\n  queue<TreeNode*> q;\n  q.push(root);\n  int i = 1;\n  while (i < vals.size()) {\n    TreeNode* node = q.front(); q.pop();\n    if (vals[i] != "null") {\n      node->left = new TreeNode(stoi(vals[i]));\n      q.push(node->left);\n    }\n    i++;\n    if (i < vals.size() && vals[i] != "null") {\n      node->right = new TreeNode(stoi(vals[i]));\n      q.push(node->right);\n    }\n    i++;\n  }\n  return root;\n}\nint main() {\n  string line; getline(cin, line);\n  istringstream iss(line);\n  vector<string> vals;\n  string v;\n  while (iss >> v) vals.push_back(v);\n  TreeNode* root = buildTree(vals);\n  vector<int> res = inorderTraversal(root);\n  for (int x : res) cout << x << \' \';\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function inorderTraversal(root) {\n  // write code here\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def inorderTraversal(root):\n    # write code here\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<Integer> inorderTraversal(TreeNode root) {\n  // write code here\n  return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void inorderTraversal(struct TreeNode* root) {\n  // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> inorderTraversal(TreeNode* root) {\n  // write code here\n  return {};\n}',
      },
    ],
  },
  {
    title: 'Binary Tree Preorder Traversal (Recursive)',
    slug: 'binary-tree-preorder-traversal-recursive',
    description:
      'Traverse a binary tree in preorder (root-left-right) order using recursion and return the sequence of visited node values.',
    problemStatement:
      'Given the root of a binary tree, return its preorder traversal using recursion. In preorder traversal, you visit the root node first, then the left subtree, then the right subtree.\n\nExamples:\n\n<pre><code>Input:\n[1,null,2,3]\n\nOutput:\n[1,2,3]\n\nExplanation:\nThe tree structure is:\n    1\n     \\\n      2\n     /\n    3\n\nThe preorder traversal is: root (1), right (2), left (3) → [1,2,3]</code></pre>\n\n<ul>\n<li>0 ≤ Number of nodes ≤ 100</li>\n<li>-100 ≤ Node values ≤ 100</li>\n</ul>\n\n<b>Pro Tip:</b> Recursive preorder traversal is straightforward. Visit the current node, then recursively traverse the left and right children.',
    sampleTestCases: [
      {
        input: '1 null 2 3',
        expected: '1 2 3',
      },
      {
        input: '',
        expected: '',
      },
    ],
    testCases: [
      {
        input: '1 null 2 3',
        expected: '1 2 3',
      },
      {
        input: '5 3 6 1 4',
        expected: '5 3 1 4 6',
      },
      {
        input: '2 1 3',
        expected: '2 1 3',
      },
      {
        input: '1',
        expected: '1',
      },
      {
        input: '',
        expected: '',
      },
      {
        input: '1 2 null 3',
        expected: '1 2 3',
      },
      {
        input: '1 null 2 null 3',
        expected: '1 2 3',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you write a recursive function to perform preorder traversal of a binary tree? Remember, visit root, then left, then right.',
    categories: ['tree', 'dfs'],
    difficulty: 'easy',
    frequency: 94,
    tags: ['preorder', 'dfs', 'binary tree'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Meta', logoUrl: '' },
    ],
    hints: [
      'Visit the root node first.',
      'Then recursively visit the left child.',
      'Finally, recursively visit the right child.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\nfunction buildTreeFromLevelOrder(data) {\n  if (!data.length) return null;\n  const nodes = data.split(\' \').map(x => (x === \'null\' ? null : new TreeNode(parseInt(x))));\n  let i = 0, j = 1;\n  while (j < nodes.length) {\n    if (nodes[i] !== null) {\n      nodes[i].left = nodes[j++] || null;\n      if (j < nodes.length) nodes[i].right = nodes[j++] || null;\n    } else i++;\n    i++;\n  }\n  return nodes[0];\n}\nconst fs = require("fs");\nfunction main() {\n  const data = fs.readFileSync(0, "utf-8").trim();\n  const root = buildTreeFromLevelOrder(data);\n  const result = preorderTraversal(root);\n  console.log(result.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(data):\n    if not data: return None\n    vals = data.split()\n    nodes = [TreeNode(int(v)) if v != 'null' else None for v in vals]\n    i = 0\n    for j in range(1, len(nodes), 2):\n        if nodes[i]:\n            if j < len(nodes): nodes[i].left = nodes[j]\n            if j+1 < len(nodes): nodes[i].right = nodes[j+1]\n        i += 1\n    return nodes[0]\n\nif __name__ == '__main__':\n    import sys\n    data = sys.stdin.read().strip()\n    root = build_tree(data)\n    res = preorderTraversal(root)\n    print(' '.join(map(str, res)))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\nclass TreeNode {\n  int val;\n  TreeNode left, right;\n  TreeNode(int x) { val = x; }\n}\nclass Solution {\n  public static TreeNode buildTree(String[] data) {\n    if (data.length == 0 || data[0].equals("null")) return null;\n    TreeNode[] nodes = new TreeNode[data.length];\n    for (int i = 0; i < data.length; i++) {\n      if (!data[i].equals("null")) nodes[i] = new TreeNode(Integer.parseInt(data[i]));\n    }\n    for (int i = 0, j = 1; j < data.length; i++) {\n      if (nodes[i] != null) {\n        if (j < data.length) nodes[i].left = nodes[j++];\n        if (j < data.length) nodes[i].right = nodes[j++];\n      }\n    }\n    return nodes[0];\n  }\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String[] vals = sc.nextLine().split(" ");\n    TreeNode root = buildTree(vals);\n    List<Integer> result = preorderTraversal(root);\n    for (int v : result) System.out.print(v + " ");\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  // Tree building and traversal logic to be written in user function\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\nusing namespace std;\nstruct TreeNode {\n  int val;\n  TreeNode *left, *right;\n  TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nTreeNode* buildTree(const vector<string>& vals) {\n  if (vals.empty() || vals[0] == "null") return nullptr;\n  TreeNode* root = new TreeNode(stoi(vals[0]));\n  queue<TreeNode*> q;\n  q.push(root);\n  int i = 1;\n  while (i < vals.size()) {\n    TreeNode* node = q.front(); q.pop();\n    if (vals[i] != "null") {\n      node->left = new TreeNode(stoi(vals[i]));\n      q.push(node->left);\n    }\n    i++;\n    if (i < vals.size() && vals[i] != "null") {\n      node->right = new TreeNode(stoi(vals[i]));\n      q.push(node->right);\n    }\n    i++;\n  }\n  return root;\n}\nint main() {\n  string line; getline(cin, line);\n  istringstream iss(line);\n  vector<string> vals;\n  string v;\n  while (iss >> v) vals.push_back(v);\n  TreeNode* root = buildTree(vals);\n  vector<int> res = preorderTraversal(root);\n  for (int x : res) cout << x << \' \';\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function preorderTraversal(root) {\n  // write code here\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def preorderTraversal(root):\n    # write code here\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<Integer> preorderTraversal(TreeNode root) {\n  // write code here\n  return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void preorderTraversal(struct TreeNode* root) {\n  // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> preorderTraversal(TreeNode* root) {\n  // write code here\n  return {};\n}',
      },
    ],
  },
  {
    title: 'Binary Tree Postorder Traversal (Recursive)',
    slug: 'binary-tree-postorder-traversal-recursive',
    description:
      'Traverse a binary tree in postorder (left-right-root) order using recursion and return the sequence of visited node values.',
    problemStatement:
      'Given the root of a binary tree, return its postorder traversal using recursion. In postorder traversal, you visit the left subtree first, then the right subtree, then the root node.\n\nExamples:\n\n<pre><code>Input:\n[1,null,2,3]\n\nOutput:\n[3,2,1]\n\nExplanation:\nThe tree structure is:\n    1\n     \\\n      2\n     /\n    3\n\nThe postorder traversal is: left (null), right-left (3), right-root (2), root (1) → [3,2,1]</code></pre>\n\n<ul>\n<li>0 ≤ Number of nodes ≤ 100</li>\n<li>-100 ≤ Node values ≤ 100</li>\n</ul>\n\n<b>Pro Tip:</b> Postorder traversal is useful for deleting or freeing trees. Use recursion by visiting left, right, then current node.',
    sampleTestCases: [
      {
        input: '1 null 2 3',
        expected: '3 2 1',
      },
      {
        input: '',
        expected: '',
      },
    ],
    testCases: [
      {
        input: '1 null 2 3',
        expected: '3 2 1',
      },
      {
        input: '5 3 6 1 4',
        expected: '1 4 3 6 5',
      },
      {
        input: '2 1 3',
        expected: '1 3 2',
      },
      {
        input: '1',
        expected: '1',
      },
      {
        input: '',
        expected: '',
      },
      {
        input: '1 2 null 3',
        expected: '3 2 1',
      },
      {
        input: '1 null 2 null 3',
        expected: '3 2 1',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you write a recursive function to perform postorder traversal of a binary tree? That is, traverse left, right, then root.',
    categories: ['tree', 'dfs'],
    difficulty: 'easy',
    frequency: 93,
    tags: ['postorder', 'dfs', 'binary tree'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Meta', logoUrl: '' },
    ],
    hints: [
      'Visit the left child first.',
      'Then recursively visit the right child.',
      'Finally, visit the root node.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\nfunction buildTreeFromLevelOrder(data) {\n  if (!data.length) return null;\n  const nodes = data.split(\' \').map(x => (x === \'null\' ? null : new TreeNode(parseInt(x))));\n  let i = 0, j = 1;\n  while (j < nodes.length) {\n    if (nodes[i] !== null) {\n      nodes[i].left = nodes[j++] || null;\n      if (j < nodes.length) nodes[i].right = nodes[j++] || null;\n    } else i++;\n    i++;\n  }\n  return nodes[0];\n}\nconst fs = require("fs");\nfunction main() {\n  const data = fs.readFileSync(0, "utf-8").trim();\n  const root = buildTreeFromLevelOrder(data);\n  const result = postorderTraversal(root);\n  console.log(result.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(data):\n    if not data: return None\n    vals = data.split()\n    nodes = [TreeNode(int(v)) if v != 'null' else None for v in vals]\n    i = 0\n    for j in range(1, len(nodes), 2):\n        if nodes[i]:\n            if j < len(nodes): nodes[i].left = nodes[j]\n            if j+1 < len(nodes): nodes[i].right = nodes[j+1]\n        i += 1\n    return nodes[0]\n\nif __name__ == '__main__':\n    import sys\n    data = sys.stdin.read().strip()\n    root = build_tree(data)\n    res = postorderTraversal(root)\n    print(' '.join(map(str, res)))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\nclass TreeNode {\n  int val;\n  TreeNode left, right;\n  TreeNode(int x) { val = x; }\n}\nclass Solution {\n  public static TreeNode buildTree(String[] data) {\n    if (data.length == 0 || data[0].equals("null")) return null;\n    TreeNode[] nodes = new TreeNode[data.length];\n    for (int i = 0; i < data.length; i++) {\n      if (!data[i].equals("null")) nodes[i] = new TreeNode(Integer.parseInt(data[i]));\n    }\n    for (int i = 0, j = 1; j < data.length; i++) {\n      if (nodes[i] != null) {\n        if (j < data.length) nodes[i].left = nodes[j++];\n        if (j < data.length) nodes[i].right = nodes[j++];\n      }\n    }\n    return nodes[0];\n  }\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String[] vals = sc.nextLine().split(" ");\n    TreeNode root = buildTree(vals);\n    List<Integer> result = postorderTraversal(root);\n    for (int v : result) System.out.print(v + " ");\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  // Tree building and traversal logic to be written in user function\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\nusing namespace std;\nstruct TreeNode {\n  int val;\n  TreeNode *left, *right;\n  TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nTreeNode* buildTree(const vector<string>& vals) {\n  if (vals.empty() || vals[0] == "null") return nullptr;\n  TreeNode* root = new TreeNode(stoi(vals[0]));\n  queue<TreeNode*> q;\n  q.push(root);\n  int i = 1;\n  while (i < vals.size()) {\n    TreeNode* node = q.front(); q.pop();\n    if (vals[i] != "null") {\n      node->left = new TreeNode(stoi(vals[i]));\n      q.push(node->left);\n    }\n    i++;\n    if (i < vals.size() && vals[i] != "null") {\n      node->right = new TreeNode(stoi(vals[i]));\n      q.push(node->right);\n    }\n    i++;\n  }\n  return root;\n}\nint main() {\n  string line; getline(cin, line);\n  istringstream iss(line);\n  vector<string> vals;\n  string v;\n  while (iss >> v) vals.push_back(v);\n  TreeNode* root = buildTree(vals);\n  vector<int> res = postorderTraversal(root);\n  for (int x : res) cout << x << \' \';\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function postorderTraversal(root) {\n  // write code here\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def postorderTraversal(root):\n    # write code here\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<Integer> postorderTraversal(TreeNode root) {\n  // write code here\n  return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void postorderTraversal(struct TreeNode* root) {\n  // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> postorderTraversal(TreeNode* root) {\n  // write code here\n  return {};\n}',
      },
    ],
  },
  {
    title: 'Binary Tree Inorder Traversal (Iterative)',
    slug: 'binary-tree-inorder-traversal-iterative',
    description:
      'Traverse a binary tree in inorder (left-root-right) order using iteration and return the sequence of visited node values.',
    problemStatement:
      'Given the root of a binary tree, return its inorder traversal using an iterative approach. In inorder traversal, you visit the left subtree first, then the root node, then the right subtree.\n\nYou must not use recursion.\n\nExamples:\n\n<pre><code>Input:\n[1,null,2,3]\n\nOutput:\n[1,3,2]\n\nExplanation:\nThe tree structure is:\n    1\n     \\\n      2\n     /\n    3\n\nThe inorder traversal is: left (null), root (1), left (3), root (2), right (null) → [1,3,2]</code></pre>\n\n<ul>\n<li>0 ≤ Number of nodes ≤ 100</li>\n<li>-100 ≤ Node values ≤ 100</li>\n<li>Do not use recursion</li>\n</ul>\n\n<b>Pro Tip:</b> Use a stack to simulate the call stack used in recursion. Keep traversing to the leftmost node while pushing nodes onto the stack.',
    sampleTestCases: [
      {
        input: '1 null 2 3',
        expected: '1 3 2',
      },
      {
        input: '',
        expected: '',
      },
    ],
    testCases: [
      {
        input: '1 null 2 3',
        expected: '1 3 2',
      },
      {
        input: '5 3 6 1 4',
        expected: '1 3 4 5 6',
      },
      {
        input: '2 1 3',
        expected: '1 2 3',
      },
      {
        input: '1',
        expected: '1',
      },
      {
        input: '',
        expected: '',
      },
      {
        input: '1 2 null 3',
        expected: '3 2 1',
      },
      {
        input: '1 null 2 null 3',
        expected: '1 2 3',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You know how to do inorder traversal recursively. Can you do it iteratively using a stack instead?',
    categories: ['tree', 'dfs'],
    difficulty: 'easy',
    frequency: 90,
    tags: ['inorder', 'dfs', 'stack', 'binary tree'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use a stack to simulate recursion.',
      'Push all left nodes onto the stack until you reach null.',
      'Then visit the node and go right.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\nfunction buildTreeFromLevelOrder(data) {\n  if (!data.length) return null;\n  const nodes = data.split(\' \').map(x => (x === \'null\' ? null : new TreeNode(parseInt(x))));\n  let i = 0, j = 1;\n  while (j < nodes.length) {\n    if (nodes[i] !== null) {\n      nodes[i].left = nodes[j++] || null;\n      if (j < nodes.length) nodes[i].right = nodes[j++] || null;\n    } else i++;\n    i++;\n  }\n  return nodes[0];\n}\nconst fs = require("fs");\nfunction main() {\n  const data = fs.readFileSync(0, "utf-8").trim();\n  const root = buildTreeFromLevelOrder(data);\n  const result = inorderTraversal(root);\n  console.log(result.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(data):\n    if not data: return None\n    vals = data.split()\n    nodes = [TreeNode(int(v)) if v != 'null' else None for v in vals]\n    i = 0\n    for j in range(1, len(nodes), 2):\n        if nodes[i]:\n            if j < len(nodes): nodes[i].left = nodes[j]\n            if j+1 < len(nodes): nodes[i].right = nodes[j+1]\n        i += 1\n    return nodes[0]\n\nif __name__ == '__main__':\n    import sys\n    data = sys.stdin.read().strip()\n    root = build_tree(data)\n    res = inorderTraversal(root)\n    print(' '.join(map(str, res)))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\nclass TreeNode {\n  int val;\n  TreeNode left, right;\n  TreeNode(int x) { val = x; }\n}\nclass Solution {\n  public static TreeNode buildTree(String[] data) {\n    if (data.length == 0 || data[0].equals("null")) return null;\n    TreeNode[] nodes = new TreeNode[data.length];\n    for (int i = 0; i < data.length; i++) {\n      if (!data[i].equals("null")) nodes[i] = new TreeNode(Integer.parseInt(data[i]));\n    }\n    for (int i = 0, j = 1; j < data.length; i++) {\n      if (nodes[i] != null) {\n        if (j < data.length) nodes[i].left = nodes[j++];\n        if (j < data.length) nodes[i].right = nodes[j++];\n      }\n    }\n    return nodes[0];\n  }\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String[] vals = sc.nextLine().split(" ");\n    TreeNode root = buildTree(vals);\n    List<Integer> result = inorderTraversal(root);\n    for (int v : result) System.out.print(v + " ");\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  // Tree logic in user code\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\nusing namespace std;\nstruct TreeNode {\n  int val;\n  TreeNode *left, *right;\n  TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nTreeNode* buildTree(const vector<string>& vals) {\n  if (vals.empty() || vals[0] == "null") return nullptr;\n  TreeNode* root = new TreeNode(stoi(vals[0]));\n  queue<TreeNode*> q;\n  q.push(root);\n  int i = 1;\n  while (i < vals.size()) {\n    TreeNode* node = q.front(); q.pop();\n    if (vals[i] != "null") {\n      node->left = new TreeNode(stoi(vals[i]));\n      q.push(node->left);\n    }\n    i++;\n    if (i < vals.size() && vals[i] != "null") {\n      node->right = new TreeNode(stoi(vals[i]));\n      q.push(node->right);\n    }\n    i++;\n  }\n  return root;\n}\nint main() {\n  string line; getline(cin, line);\n  istringstream iss(line);\n  vector<string> vals;\n  string v;\n  while (iss >> v) vals.push_back(v);\n  TreeNode* root = buildTree(vals);\n  vector<int> res = inorderTraversal(root);\n  for (int x : res) cout << x << \' \';\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function inorderTraversal(root) {\n  // iterative implementation\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def inorderTraversal(root):\n    # iterative implementation\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<Integer> inorderTraversal(TreeNode root) {\n  // iterative implementation\n  return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void inorderTraversal(struct TreeNode* root) {\n  // iterative implementation\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> inorderTraversal(TreeNode* root) {\n  // iterative implementation\n  return {};\n}',
      },
    ],
  },
  {
    title: 'Binary Tree Preorder Traversal (Iterative)',
    slug: 'binary-tree-preorder-traversal-iterative',
    description:
      'Traverse a binary tree in preorder (root-left-right) order using an iterative approach and return the sequence of visited node values.',
    problemStatement:
      'Given the root of a binary tree, return its preorder traversal using an iterative method. In preorder traversal, you visit the root node first, then the left subtree, then the right subtree.\n\nYou must not use recursion.\n\nExamples:\n\n<pre><code>Input:\n[1,null,2,3]\n\nOutput:\n[1,2,3]\n\nExplanation:\nThe tree structure is:\n    1\n     \\\n      2\n     /\n    3\n\nThe preorder traversal is: root (1), right (2), left (3) → [1,2,3]</code></pre>\n\n<ul>\n<li>0 ≤ Number of nodes ≤ 100</li>\n<li>-100 ≤ Node values ≤ 100</li>\n<li>Do not use recursion</li>\n</ul>\n\n<b>Pro Tip:</b> Use a stack to simulate the recursion. Push the right child first, then the left, so the left is processed before the right.',
    sampleTestCases: [
      {
        input: '1 null 2 3',
        expected: '1 2 3',
      },
      {
        input: '',
        expected: '',
      },
    ],
    testCases: [
      {
        input: '1 null 2 3',
        expected: '1 2 3',
      },
      {
        input: '5 3 6 1 4',
        expected: '5 3 1 4 6',
      },
      {
        input: '2 1 3',
        expected: '2 1 3',
      },
      {
        input: '1',
        expected: '1',
      },
      {
        input: '',
        expected: '',
      },
      {
        input: '1 2 null 3',
        expected: '1 2 3',
      },
      {
        input: '1 null 2 null 3',
        expected: '1 2 3',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Most students can write a recursive preorder traversal. Can you do it iteratively using a stack?',
    categories: ['tree', 'dfs'],
    difficulty: 'easy',
    frequency: 91,
    tags: ['preorder', 'dfs', 'stack', 'binary tree'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Use a stack to simulate recursion.',
      'Push right child first, then left child to the stack.',
      'Process nodes as you pop them.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\nfunction buildTreeFromLevelOrder(data) {\n  if (!data.length) return null;\n  const nodes = data.split(\' \').map(x => (x === \'null\' ? null : new TreeNode(parseInt(x))));\n  let i = 0, j = 1;\n  while (j < nodes.length) {\n    if (nodes[i] !== null) {\n      nodes[i].left = nodes[j++] || null;\n      if (j < nodes.length) nodes[i].right = nodes[j++] || null;\n    } else i++;\n    i++;\n  }\n  return nodes[0];\n}\nconst fs = require("fs");\nfunction main() {\n  const data = fs.readFileSync(0, "utf-8").trim();\n  const root = buildTreeFromLevelOrder(data);\n  const result = preorderTraversal(root);\n  console.log(result.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(data):\n    if not data: return None\n    vals = data.split()\n    nodes = [TreeNode(int(v)) if v != 'null' else None for v in vals]\n    i = 0\n    for j in range(1, len(nodes), 2):\n        if nodes[i]:\n            if j < len(nodes): nodes[i].left = nodes[j]\n            if j+1 < len(nodes): nodes[i].right = nodes[j+1]\n        i += 1\n    return nodes[0]\n\nif __name__ == '__main__':\n    import sys\n    data = sys.stdin.read().strip()\n    root = build_tree(data)\n    res = preorderTraversal(root)\n    print(' '.join(map(str, res)))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\nclass TreeNode {\n  int val;\n  TreeNode left, right;\n  TreeNode(int x) { val = x; }\n}\nclass Solution {\n  public static TreeNode buildTree(String[] data) {\n    if (data.length == 0 || data[0].equals("null")) return null;\n    TreeNode[] nodes = new TreeNode[data.length];\n    for (int i = 0; i < data.length; i++) {\n      if (!data[i].equals("null")) nodes[i] = new TreeNode(Integer.parseInt(data[i]));\n    }\n    for (int i = 0, j = 1; j < data.length; i++) {\n      if (nodes[i] != null) {\n        if (j < data.length) nodes[i].left = nodes[j++];\n        if (j < data.length) nodes[i].right = nodes[j++];\n      }\n    }\n    return nodes[0];\n  }\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String[] vals = sc.nextLine().split(" ");\n    TreeNode root = buildTree(vals);\n    List<Integer> result = preorderTraversal(root);\n    for (int v : result) System.out.print(v + " ");\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  // Tree construction and traversal to be implemented\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\nusing namespace std;\nstruct TreeNode {\n  int val;\n  TreeNode *left, *right;\n  TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nTreeNode* buildTree(const vector<string>& vals) {\n  if (vals.empty() || vals[0] == "null") return nullptr;\n  TreeNode* root = new TreeNode(stoi(vals[0]));\n  queue<TreeNode*> q;\n  q.push(root);\n  int i = 1;\n  while (i < vals.size()) {\n    TreeNode* node = q.front(); q.pop();\n    if (vals[i] != "null") {\n      node->left = new TreeNode(stoi(vals[i]));\n      q.push(node->left);\n    }\n    i++;\n    if (i < vals.size() && vals[i] != "null") {\n      node->right = new TreeNode(stoi(vals[i]));\n      q.push(node->right);\n    }\n    i++;\n  }\n  return root;\n}\nint main() {\n  string line; getline(cin, line);\n  istringstream iss(line);\n  vector<string> vals;\n  string v;\n  while (iss >> v) vals.push_back(v);\n  TreeNode* root = buildTree(vals);\n  vector<int> res = preorderTraversal(root);\n  for (int x : res) cout << x << \' \';\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function preorderTraversal(root) {\n  // iterative implementation\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def preorderTraversal(root):\n    # iterative implementation\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<Integer> preorderTraversal(TreeNode root) {\n  // iterative implementation\n  return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void preorderTraversal(struct TreeNode* root) {\n  // iterative implementation\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> preorderTraversal(TreeNode* root) {\n  // iterative implementation\n  return {};\n}',
      },
    ],
  },
  {
    title: 'Binary Tree Postorder Traversal (Iterative)',
    slug: 'binary-tree-postorder-traversal-iterative',
    description:
      'Traverse a binary tree in postorder (left-right-root) order using an iterative approach and return the sequence of visited node values.',
    problemStatement:
      'Given the root of a binary tree, return its postorder traversal using an iterative method. In postorder traversal, you visit the left subtree first, then the right subtree, then the root node.\n\nYou must not use recursion.\n\nExamples:\n\n<pre><code>Input:\n[1,null,2,3]\n\nOutput:\n[3,2,1]\n\nExplanation:\nThe tree structure is:\n    1\n     \\\n      2\n     /\n    3\n\nThe postorder traversal is: left (null), right-left (3), right-root (2), root (1) → [3,2,1]</code></pre>\n\n<ul>\n<li>0 ≤ Number of nodes ≤ 100</li>\n<li>-100 ≤ Node values ≤ 100</li>\n<li>Do not use recursion</li>\n</ul>\n\n<b>Pro Tip:</b> Use two stacks, or a single stack and track the last visited node to simulate postorder traversal without recursion.',
    sampleTestCases: [
      {
        input: '1 null 2 3',
        expected: '3 2 1',
      },
      {
        input: '',
        expected: '',
      },
    ],
    testCases: [
      {
        input: '1 null 2 3',
        expected: '3 2 1',
      },
      {
        input: '5 3 6 1 4',
        expected: '1 4 3 6 5',
      },
      {
        input: '2 1 3',
        expected: '1 3 2',
      },
      {
        input: '1',
        expected: '1',
      },
      {
        input: '',
        expected: '',
      },
      {
        input: '1 2 null 3',
        expected: '3 2 1',
      },
      {
        input: '1 null 2 null 3',
        expected: '3 2 1',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Can you implement postorder traversal iteratively? It's a bit trickier than preorder or inorder, but totally doable with a stack.",
    categories: ['tree', 'dfs'],
    difficulty: 'medium',
    frequency: 89,
    tags: ['postorder', 'dfs', 'stack', 'binary tree'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Use a stack to simulate recursion.',
      'Try using two stacks: one to process, another to reverse the result.',
      'Alternatively, use one stack and a pointer to track the last visited node.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\nfunction buildTreeFromLevelOrder(data) {\n  if (!data.length) return null;\n  const nodes = data.split(\' \').map(x => (x === \'null\' ? null : new TreeNode(parseInt(x))));\n  let i = 0, j = 1;\n  while (j < nodes.length) {\n    if (nodes[i] !== null) {\n      nodes[i].left = nodes[j++] || null;\n      if (j < nodes.length) nodes[i].right = nodes[j++] || null;\n    } else i++;\n    i++;\n  }\n  return nodes[0];\n}\nconst fs = require("fs");\nfunction main() {\n  const data = fs.readFileSync(0, "utf-8").trim();\n  const root = buildTreeFromLevelOrder(data);\n  const result = postorderTraversal(root);\n  console.log(result.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(data):\n    if not data: return None\n    vals = data.split()\n    nodes = [TreeNode(int(v)) if v != 'null' else None for v in vals]\n    i = 0\n    for j in range(1, len(nodes), 2):\n        if nodes[i]:\n            if j < len(nodes): nodes[i].left = nodes[j]\n            if j+1 < len(nodes): nodes[i].right = nodes[j+1]\n        i += 1\n    return nodes[0]\n\nif __name__ == '__main__':\n    import sys\n    data = sys.stdin.read().strip()\n    root = build_tree(data)\n    res = postorderTraversal(root)\n    print(' '.join(map(str, res)))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\nclass TreeNode {\n  int val;\n  TreeNode left, right;\n  TreeNode(int x) { val = x; }\n}\nclass Solution {\n  public static TreeNode buildTree(String[] data) {\n    if (data.length == 0 || data[0].equals("null")) return null;\n    TreeNode[] nodes = new TreeNode[data.length];\n    for (int i = 0; i < data.length; i++) {\n      if (!data[i].equals("null")) nodes[i] = new TreeNode(Integer.parseInt(data[i]));\n    }\n    for (int i = 0, j = 1; j < data.length; i++) {\n      if (nodes[i] != null) {\n        if (j < data.length) nodes[i].left = nodes[j++];\n        if (j < data.length) nodes[i].right = nodes[j++];\n      }\n    }\n    return nodes[0];\n  }\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String[] vals = sc.nextLine().split(" ");\n    TreeNode root = buildTree(vals);\n    List<Integer> result = postorderTraversal(root);\n    for (int v : result) System.out.print(v + " ");\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  // Tree construction and traversal to be implemented\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\nusing namespace std;\nstruct TreeNode {\n  int val;\n  TreeNode *left, *right;\n  TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nTreeNode* buildTree(const vector<string>& vals) {\n  if (vals.empty() || vals[0] == "null") return nullptr;\n  TreeNode* root = new TreeNode(stoi(vals[0]));\n  queue<TreeNode*> q;\n  q.push(root);\n  int i = 1;\n  while (i < vals.size()) {\n    TreeNode* node = q.front(); q.pop();\n    if (vals[i] != "null") {\n      node->left = new TreeNode(stoi(vals[i]));\n      q.push(node->left);\n    }\n    i++;\n    if (i < vals.size() && vals[i] != "null") {\n      node->right = new TreeNode(stoi(vals[i]));\n      q.push(node->right);\n    }\n    i++;\n  }\n  return root;\n}\nint main() {\n  string line; getline(cin, line);\n  istringstream iss(line);\n  vector<string> vals;\n  string v;\n  while (iss >> v) vals.push_back(v);\n  TreeNode* root = buildTree(vals);\n  vector<int> res = postorderTraversal(root);\n  for (int x : res) cout << x << \' \';\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function postorderTraversal(root) {\n  // iterative implementation\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def postorderTraversal(root):\n    # iterative implementation\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<Integer> postorderTraversal(TreeNode root) {\n  // iterative implementation\n  return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void postorderTraversal(struct TreeNode* root) {\n  // iterative implementation\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> postorderTraversal(TreeNode* root) {\n  // iterative implementation\n  return {};\n}',
      },
    ],
  },
  {
    title: 'Binary Tree Level Order Traversal (BFS)',
    slug: 'binary-tree-level-order-traversal-bfs',
    description:
      'Traverse a binary tree level by level using Breadth-First Search and return the sequence of visited node values.',
    problemStatement:
      'Given the root of a binary tree, return its level order traversal (also known as BFS traversal). This means visiting all the nodes at depth 0 first, then depth 1, then depth 2, and so on.\n\nIn level order traversal, nodes are visited level by level from left to right.\n\nExamples:\n\n<pre><code>Input:\n[3,9,20,null,null,15,7]\n\nOutput:\n[3,9,20,15,7]\n\nExplanation:\nThe tree structure is:\n    3\n   / \\\n  9  20\n     /  \\\n    15   7\n\nVisit each level left to right: 3 → 9,20 → 15,7 → [3,9,20,15,7]</code></pre>\n\n<ul>\n<li>0 ≤ Number of nodes ≤ 100</li>\n<li>-100 ≤ Node values ≤ 100</li>\n</ul>\n\n<b>Pro Tip:</b> Use a queue to track nodes at each level. Enqueue child nodes after visiting the current node.',
    sampleTestCases: [
      {
        input: '3 9 20 null null 15 7',
        expected: '3 9 20 15 7',
      },
      {
        input: '',
        expected: '',
      },
    ],
    testCases: [
      {
        input: '3 9 20 null null 15 7',
        expected: '3 9 20 15 7',
      },
      {
        input: '1 2 3 4 5 6 7',
        expected: '1 2 3 4 5 6 7',
      },
      {
        input: '1',
        expected: '1',
      },
      {
        input: '1 2 null 3 null 4 null',
        expected: '1 2 3 4',
      },
      {
        input: '1 null 2 null 3',
        expected: '1 2 3',
      },
      {
        input: '',
        expected: '',
      },
      {
        input: '5 4 6 null null 3 7',
        expected: '5 4 6 3 7',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you write a function to perform level order traversal on a binary tree? This is also known as Breadth-First Search.',
    categories: ['tree', 'bfs'],
    difficulty: 'easy',
    frequency: 96,
    tags: ['bfs', 'level order', 'queue', 'binary tree'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use a queue to manage nodes by levels.',
      'Push left and right children after visiting the node.',
      'Continue until the queue is empty.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\nfunction buildTreeFromLevelOrder(data) {\n  if (!data.length) return null;\n  const nodes = data.split(\' \').map(x => (x === \'null\' ? null : new TreeNode(parseInt(x))));\n  let i = 0, j = 1;\n  while (j < nodes.length) {\n    if (nodes[i] !== null) {\n      nodes[i].left = nodes[j++] || null;\n      if (j < nodes.length) nodes[i].right = nodes[j++] || null;\n    } else i++;\n    i++;\n  }\n  return nodes[0];\n}\nconst fs = require("fs");\nfunction main() {\n  const data = fs.readFileSync(0, "utf-8").trim();\n  const root = buildTreeFromLevelOrder(data);\n  const result = levelOrderTraversal(root);\n  console.log(result.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(data):\n    if not data: return None\n    vals = data.split()\n    nodes = [TreeNode(int(v)) if v != 'null' else None for v in vals]\n    i = 0\n    for j in range(1, len(nodes), 2):\n        if nodes[i]:\n            if j < len(nodes): nodes[i].left = nodes[j]\n            if j+1 < len(nodes): nodes[i].right = nodes[j+1]\n        i += 1\n    return nodes[0]\n\nif __name__ == '__main__':\n    import sys\n    data = sys.stdin.read().strip()\n    root = build_tree(data)\n    res = levelOrderTraversal(root)\n    print(' '.join(map(str, res)))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\nclass TreeNode {\n  int val;\n  TreeNode left, right;\n  TreeNode(int x) { val = x; }\n}\nclass Solution {\n  public static TreeNode buildTree(String[] data) {\n    if (data.length == 0 || data[0].equals("null")) return null;\n    TreeNode[] nodes = new TreeNode[data.length];\n    for (int i = 0; i < data.length; i++) {\n      if (!data[i].equals("null")) nodes[i] = new TreeNode(Integer.parseInt(data[i]));\n    }\n    for (int i = 0, j = 1; j < data.length; i++) {\n      if (nodes[i] != null) {\n        if (j < data.length) nodes[i].left = nodes[j++];\n        if (j < data.length) nodes[i].right = nodes[j++];\n      }\n    }\n    return nodes[0];\n  }\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String[] vals = sc.nextLine().split(" ");\n    TreeNode root = buildTree(vals);\n    List<Integer> result = levelOrderTraversal(root);\n    for (int v : result) System.out.print(v + " ");\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  // Tree construction and BFS logic\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\nusing namespace std;\nstruct TreeNode {\n  int val;\n  TreeNode *left, *right;\n  TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nTreeNode* buildTree(const vector<string>& vals) {\n  if (vals.empty() || vals[0] == "null") return nullptr;\n  TreeNode* root = new TreeNode(stoi(vals[0]));\n  queue<TreeNode*> q;\n  q.push(root);\n  int i = 1;\n  while (i < vals.size()) {\n    TreeNode* node = q.front(); q.pop();\n    if (vals[i] != "null") {\n      node->left = new TreeNode(stoi(vals[i]));\n      q.push(node->left);\n    }\n    i++;\n    if (i < vals.size() && vals[i] != "null") {\n      node->right = new TreeNode(stoi(vals[i]));\n      q.push(node->right);\n    }\n    i++;\n  }\n  return root;\n}\nint main() {\n  string line; getline(cin, line);\n  istringstream iss(line);\n  vector<string> vals;\n  string v;\n  while (iss >> v) vals.push_back(v);\n  TreeNode* root = buildTree(vals);\n  vector<int> res = levelOrderTraversal(root);\n  for (int x : res) cout << x << \' \';\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function levelOrderTraversal(root) {\n  // BFS implementation\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def levelOrderTraversal(root):\n    # BFS implementation\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<Integer> levelOrderTraversal(TreeNode root) {\n  // BFS implementation\n  return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void levelOrderTraversal(struct TreeNode* root) {\n  // BFS implementation\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> levelOrderTraversal(TreeNode* root) {\n  // BFS implementation\n  return {};\n}',
      },
    ],
  },
  {
    title: 'Binary Tree Reverse Level Order Traversal',
    slug: 'binary-tree-reverse-level-order-traversal',
    description:
      'Traverse a binary tree level by level from bottom to top using BFS and return the sequence of visited node values.',
    problemStatement:
      'Given the root of a binary tree, return its reverse level order traversal. In this traversal, you visit all the nodes at the lowest level first, then the level above it, and so on up to the root.\n\nWithin each level, nodes are visited from left to right.\n\nExamples:\n\n<pre><code>Input:\n[3,9,20,null,null,15,7]\n\nOutput:\n[15,7,9,20,3]\n\nExplanation:\nThe tree structure is:\n    3\n   / \\\n  9  20\n     /  \\\n    15   7\n\nLevel order traversal is: [3,9,20,15,7]\nReverse level order is: [15,7,9,20,3]</code></pre>\n\n<ul>\n<li>0 ≤ Number of nodes ≤ 100</li>\n<li>-100 ≤ Node values ≤ 100</li>\n</ul>\n\n<b>Pro Tip:</b> Use a queue for BFS traversal and a stack to reverse the output. Alternatively, you can store level-wise results and then reverse the final list.',
    sampleTestCases: [
      {
        input: '3 9 20 null null 15 7',
        expected: '15 7 9 20 3',
      },
      {
        input: '',
        expected: '',
      },
    ],
    testCases: [
      {
        input: '3 9 20 null null 15 7',
        expected: '15 7 9 20 3',
      },
      {
        input: '1 2 3 4 5 6 7',
        expected: '4 5 6 7 2 3 1',
      },
      {
        input: '1',
        expected: '1',
      },
      {
        input: '1 2 null 3 null 4 null',
        expected: '4 3 2 1',
      },
      {
        input: '1 null 2 null 3',
        expected: '3 2 1',
      },
      {
        input: '',
        expected: '',
      },
      {
        input: '5 4 6 null null 3 7',
        expected: '3 7 4 6 5',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "We've done level order traversal. Now can you return the values in reverse level order — from bottom to top?",
    categories: ['tree', 'bfs'],
    difficulty: 'medium',
    frequency: 82,
    tags: ['bfs', 'reverse', 'queue', 'stack', 'binary tree'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Apple', logoUrl: '' },
    ],
    hints: [
      'Perform normal level order traversal and push values onto a stack.',
      'At the end, pop all values from the stack for reversed order.',
      'Or use a list of levels and reverse the list at the end.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\nfunction buildTreeFromLevelOrder(data) {\n  if (!data.length) return null;\n  const nodes = data.split(\' \').map(x => (x === \'null\' ? null : new TreeNode(parseInt(x))));\n  let i = 0, j = 1;\n  while (j < nodes.length) {\n    if (nodes[i] !== null) {\n      nodes[i].left = nodes[j++] || null;\n      if (j < nodes.length) nodes[i].right = nodes[j++] || null;\n    } else i++;\n    i++;\n  }\n  return nodes[0];\n}\nconst fs = require("fs");\nfunction main() {\n  const data = fs.readFileSync(0, "utf-8").trim();\n  const root = buildTreeFromLevelOrder(data);\n  const result = reverseLevelOrderTraversal(root);\n  console.log(result.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(data):\n    if not data: return None\n    vals = data.split()\n    nodes = [TreeNode(int(v)) if v != 'null' else None for v in vals]\n    i = 0\n    for j in range(1, len(nodes), 2):\n        if nodes[i]:\n            if j < len(nodes): nodes[i].left = nodes[j]\n            if j+1 < len(nodes): nodes[i].right = nodes[j+1]\n        i += 1\n    return nodes[0]\n\nif __name__ == '__main__':\n    import sys\n    data = sys.stdin.read().strip()\n    root = build_tree(data)\n    res = reverseLevelOrderTraversal(root)\n    print(' '.join(map(str, res)))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\nclass TreeNode {\n  int val;\n  TreeNode left, right;\n  TreeNode(int x) { val = x; }\n}\nclass Solution {\n  public static TreeNode buildTree(String[] data) {\n    if (data.length == 0 || data[0].equals("null")) return null;\n    TreeNode[] nodes = new TreeNode[data.length];\n    for (int i = 0; i < data.length; i++) {\n      if (!data[i].equals("null")) nodes[i] = new TreeNode(Integer.parseInt(data[i]));\n    }\n    for (int i = 0, j = 1; j < data.length; i++) {\n      if (nodes[i] != null) {\n        if (j < data.length) nodes[i].left = nodes[j++];\n        if (j < data.length) nodes[i].right = nodes[j++];\n      }\n    }\n    return nodes[0];\n  }\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String[] vals = sc.nextLine().split(" ");\n    TreeNode root = buildTree(vals);\n    List<Integer> result = reverseLevelOrderTraversal(root);\n    for (int v : result) System.out.print(v + " ");\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  // Tree building and reverse BFS logic\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\nusing namespace std;\nstruct TreeNode {\n  int val;\n  TreeNode *left, *right;\n  TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nTreeNode* buildTree(const vector<string>& vals) {\n  if (vals.empty() || vals[0] == "null") return nullptr;\n  TreeNode* root = new TreeNode(stoi(vals[0]));\n  queue<TreeNode*> q;\n  q.push(root);\n  int i = 1;\n  while (i < vals.size()) {\n    TreeNode* node = q.front(); q.pop();\n    if (vals[i] != "null") {\n      node->left = new TreeNode(stoi(vals[i]));\n      q.push(node->left);\n    }\n    i++;\n    if (i < vals.size() && vals[i] != "null") {\n      node->right = new TreeNode(stoi(vals[i]));\n      q.push(node->right);\n    }\n    i++;\n  }\n  return root;\n}\nint main() {\n  string line; getline(cin, line);\n  istringstream iss(line);\n  vector<string> vals;\n  string v;\n  while (iss >> v) vals.push_back(v);\n  TreeNode* root = buildTree(vals);\n  vector<int> res = reverseLevelOrderTraversal(root);\n  for (int x : res) cout << x << \' \';\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function reverseLevelOrderTraversal(root) {\n  // write iterative BFS here\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def reverseLevelOrderTraversal(root):\n    # write iterative BFS here\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<Integer> reverseLevelOrderTraversal(TreeNode root) {\n  // write iterative BFS here\n  return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void reverseLevelOrderTraversal(struct TreeNode* root) {\n  // write iterative BFS here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> reverseLevelOrderTraversal(TreeNode* root) {\n  // write iterative BFS here\n  return {};\n}',
      },
    ],
  },
  {
    title: 'Binary Tree Zig-Zag Level Order Traversal',
    slug: 'binary-tree-zig-zag-level-order-traversal',
    description:
      'Traverse a binary tree level by level in zig-zag fashion and return the sequence of visited node values.',
    problemStatement:
      'Given the root of a binary tree, return its zig-zag level order traversal. Zig-zag means the first level is traversed from left to right, the second from right to left, the third from left to right, and so on.\n\nIn each level, nodes should be visited in the specified left-to-right or right-to-left order.\n\nExamples:\n\n<pre><code>Input:\n[3,9,20,null,null,15,7]\n\nOutput:\n[3,20,9,15,7]\n\nExplanation:\nThe tree structure is:\n    3\n   / \\\n  9  20\n     /  \\\n    15   7\n\nLevels:\nLevel 1: left→right → [3]\nLevel 2: right→left → [20,9]\nLevel 3: left→right → [15,7]</code></pre>\n\n<ul>\n<li>0 ≤ Number of nodes ≤ 100</li>\n<li>-100 ≤ Node values ≤ 100</li>\n</ul>\n\n<b>Pro Tip:</b> Alternate the order of adding node values at each level. You can use a deque or reverse the list conditionally at each level.',
    sampleTestCases: [
      {
        input: '3 9 20 null null 15 7',
        expected: '3 20 9 15 7',
      },
      {
        input: '',
        expected: '',
      },
    ],
    testCases: [
      {
        input: '3 9 20 null null 15 7',
        expected: '3 20 9 15 7',
      },
      {
        input: '1 2 3 4 5 6 7',
        expected: '1 3 2 4 5 6 7',
      },
      {
        input: '1',
        expected: '1',
      },
      {
        input: '1 2 null 3 null 4 null',
        expected: '1 2 3 4',
      },
      {
        input: '1 null 2 null 3',
        expected: '1 2 3',
      },
      {
        input: '',
        expected: '',
      },
      {
        input: '5 4 6 null null 3 7',
        expected: '5 6 4 3 7',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Let's make BFS a bit more fun. Can you print the level order traversal of a binary tree in zig-zag (alternate left-to-right and right-to-left) fashion?",
    categories: ['tree', 'bfs'],
    difficulty: 'medium',
    frequency: 87,
    tags: ['bfs', 'zigzag', 'queue', 'deque', 'binary tree'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Use a queue for normal level order traversal.',
      'Use a boolean flag to toggle the direction at each level.',
      'Reverse the current level’s result list based on direction.',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\nfunction buildTreeFromLevelOrder(data) {\n  if (!data.length) return null;\n  const nodes = data.split(\' \').map(x => (x === \'null\' ? null : new TreeNode(parseInt(x))));\n  let i = 0, j = 1;\n  while (j < nodes.length) {\n    if (nodes[i] !== null) {\n      nodes[i].left = nodes[j++] || null;\n      if (j < nodes.length) nodes[i].right = nodes[j++] || null;\n    } else i++;\n    i++;\n  }\n  return nodes[0];\n}\nconst fs = require("fs");\nfunction main() {\n  const data = fs.readFileSync(0, "utf-8").trim();\n  const root = buildTreeFromLevelOrder(data);\n  const result = zigzagLevelOrderTraversal(root);\n  console.log(result.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(data):\n    if not data: return None\n    vals = data.split()\n    nodes = [TreeNode(int(v)) if v != 'null' else None for v in vals]\n    i = 0\n    for j in range(1, len(nodes), 2):\n        if nodes[i]:\n            if j < len(nodes): nodes[i].left = nodes[j]\n            if j+1 < len(nodes): nodes[i].right = nodes[j+1]\n        i += 1\n    return nodes[0]\n\nif __name__ == '__main__':\n    import sys\n    data = sys.stdin.read().strip()\n    root = build_tree(data)\n    res = zigzagLevelOrderTraversal(root)\n    print(' '.join(map(str, res)))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\nclass TreeNode {\n  int val;\n  TreeNode left, right;\n  TreeNode(int x) { val = x; }\n}\nclass Solution {\n  public static TreeNode buildTree(String[] data) {\n    if (data.length == 0 || data[0].equals("null")) return null;\n    TreeNode[] nodes = new TreeNode[data.length];\n    for (int i = 0; i < data.length; i++) {\n      if (!data[i].equals("null")) nodes[i] = new TreeNode(Integer.parseInt(data[i]));\n    }\n    for (int i = 0, j = 1; j < data.length; i++) {\n      if (nodes[i] != null) {\n        if (j < data.length) nodes[i].left = nodes[j++];\n        if (j < data.length) nodes[i].right = nodes[j++];\n      }\n    }\n    return nodes[0];\n  }\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String[] vals = sc.nextLine().split(" ");\n    TreeNode root = buildTree(vals);\n    List<Integer> result = zigzagLevelOrderTraversal(root);\n    for (int v : result) System.out.print(v + " ");\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  // Tree construction and zigzag logic\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <deque>\nusing namespace std;\nstruct TreeNode {\n  int val;\n  TreeNode *left, *right;\n  TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nTreeNode* buildTree(const vector<string>& vals) {\n  if (vals.empty() || vals[0] == "null") return nullptr;\n  TreeNode* root = new TreeNode(stoi(vals[0]));\n  queue<TreeNode*> q;\n  q.push(root);\n  int i = 1;\n  while (i < vals.size()) {\n    TreeNode* node = q.front(); q.pop();\n    if (vals[i] != "null") {\n      node->left = new TreeNode(stoi(vals[i]));\n      q.push(node->left);\n    }\n    i++;\n    if (i < vals.size() && vals[i] != "null") {\n      node->right = new TreeNode(stoi(vals[i]));\n      q.push(node->right);\n    }\n    i++;\n  }\n  return root;\n}\nint main() {\n  string line; getline(cin, line);\n  istringstream iss(line);\n  vector<string> vals;\n  string v;\n  while (iss >> v) vals.push_back(v);\n  TreeNode* root = buildTree(vals);\n  vector<int> res = zigzagLevelOrderTraversal(root);\n  for (int x : res) cout << x << \' \';\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function zigzagLevelOrderTraversal(root) {\n  // zigzag level traversal using queue\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def zigzagLevelOrderTraversal(root):\n    # zigzag level traversal using queue\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<Integer> zigzagLevelOrderTraversal(TreeNode root) {\n  // zigzag level traversal using queue\n  return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void zigzagLevelOrderTraversal(struct TreeNode* root) {\n  // zigzag level traversal using queue\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> zigzagLevelOrderTraversal(TreeNode* root) {\n  // zigzag level traversal using queue\n  return {};\n}',
      },
    ],
  },
  {
    title: 'Boundary Traversal of Binary Tree',
    slug: 'boundary-traversal-of-binary-tree',
    description:
      'Traverse the boundary of a binary tree in anticlockwise order (left boundary, leaves, then right boundary).',
    problemStatement:
      'Given the root of a binary tree, return its boundary traversal in anticlockwise order starting from the root. The boundary includes:\n<ul>\n<li><b>Left boundary</b> (excluding leaf nodes), top-down from the root’s left child.</li>\n<li><b>Leaf nodes</b>, from left to right.</li>\n<li><b>Right boundary</b> (excluding leaf nodes and root), bottom-up from the root’s right child.</li>\n</ul>\nCombine these three parts to produce the boundary traversal. Handle edge cases where subtrees are absent or nodes might overlap boundaries.',
    sampleTestCases: [
      {
        input: '1 2 3 4 5 null null null null 6 7',
        expected: '1 2 4 6 7 3',
      },
      {
        input: '1',
        expected: '1',
      },
    ],
    testCases: [
      {
        input: '3 9 20 null null 15 7',
        expected: '3 9 15 7 20',
      },
      {
        input: '1 2 3 4 5 6 7',
        expected: '1 2 4 5 6 7 3',
      },
      {
        input: '1 null 2 null 3 null 4',
        expected: '1 2 3 4',
      },
      {
        input: '1 2 null 3 4',
        expected: '1 2 3 4',
      },
      {
        input: '',
        expected: '',
      },
      {
        input: '1 2 3 null null 4',
        expected: '1 2 4 3',
      },
    ],
    topics: ['tree', 'dfs'],
    interviewExcerpt:
      "Can you compute the boundary traversal of a binary tree in anticlockwise order? Think how you'd collect left boundary, leaves, and right boundary systematically.",
    categories: ['tree', 'depth‑first search', 'boundary traversal'],
    difficulty: 'medium',
    frequency: 80,
    tags: ['boundary', 'dfs', 'tree'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'First collect left boundary (excluding leaf nodes).',
      'Then collect leaf nodes via traversal.',
      'Finally, collect right boundary in reverse (excluding root and leaves).',
    ],
    optimalComplexity: {
      time: 'O(n)',
      space: 'O(h)',
      note: 'h is tree height',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'class TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nfunction buildTreeFromLevelOrder(data) {\n  if (!data.length) return null;\n  const nodes = data.split(\' \').map(x => (x === \'null\' ? null : new TreeNode(parseInt(x))));\n  let i = 0, j = 1;\n  while (j < nodes.length) {\n    if (nodes[i] !== null) {\n      nodes[i].left = nodes[j++] || null;\n      if (j < nodes.length) nodes[i].right = nodes[j++] || null;\n    } else i++;\n    i++;\n  }\n  return nodes[0];\n}\n\nconst fs = require("fs");\nfunction main() {\n  const data = fs.readFileSync(0, "utf-8").trim();\n  if (!data) { console.log(""); return; }\n  const root = buildTreeFromLevelOrder(data);\n  const result = boundaryTraversal(root);\n  console.log(result.join(" "));\n}\nmain();',
      },
      {
        language: 'python',
        code: "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(data):\n    if not data: return None\n    vals = data.split()\n    nodes = [TreeNode(int(v)) if v != 'null' else None for v in vals]\n    i = 0\n    for j in range(1, len(nodes), 2):\n        if nodes[i]:\n            if j < len(nodes): nodes[i].left = nodes[j]\n            if j+1 < len(nodes): nodes[i].right = nodes[j+1]\n        i += 1\n    return nodes[0]\n\nif __name__ == '__main__':\n    import sys\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"\")\n    else:\n        root = build_tree(data)\n        res = boundaryTraversal(root)\n        print(' '.join(map(str, res)))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\nclass TreeNode {\n  int val;\n  TreeNode left, right;\n  TreeNode(int x) { val = x; }\n}\nclass Solution {\n  public static TreeNode buildTree(String[] data) {\n    if (data.length == 0 || data[0].equals("null")) return null;\n    TreeNode[] nodes = new TreeNode[data.length];\n    for (int i = 0; i < data.length; i++)\n      if (!data[i].equals("null")) nodes[i] = new TreeNode(Integer.parseInt(data[i]));\n    for (int i = 0, j = 1; j < data.length; i++) {\n      if (nodes[i] != null) {\n        if (j < data.length) nodes[i].left = nodes[j++];\n        if (j < data.length) nodes[i].right = nodes[j++];\n      }\n    }\n    return nodes[0];\n  }\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String line = sc.nextLine();\n    if (line.isEmpty()) { System.out.println(); return; }\n    String[] vals = line.split(" ");\n    TreeNode root = buildTree(vals);\n    List<Integer> res = boundaryTraversal(root);\n    for (int v : res) System.out.print(v + " ");\n  }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nint main() {\n  // Build tree and invoke boundaryTraversal\n  return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <sstream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct TreeNode {\n  int val;\n  TreeNode *left, *right;\n  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nTreeNode* buildTree(const vector<string>& vals) {\n  if (vals.empty() || vals[0] == "null") return nullptr;\n  TreeNode* root = new TreeNode(stoi(vals[0]));\n  queue<TreeNode*> q;\n  q.push(root);\n  int i = 1;\n  while (i < vals.size()) {\n    TreeNode* node = q.front(); q.pop();\n    if (vals[i] != "null") {\n      node->left = new TreeNode(stoi(vals[i]));\n      q.push(node->left);\n    }\n    i++;\n    if (i < vals.size() && vals[i] != "null") {\n      node->right = new TreeNode(stoi(vals[i]));\n      q.push(node->right);\n    }\n    i++;\n  }\n  return root;\n}\n\nint main() {\n  string line;\n  getline(cin, line);\n  if (line.empty()) { cout << ""; return 0; }\n  istringstream iss(line);\n  vector<string> vals;\n  string tok;\n  while (iss >> tok) vals.push_back(tok);\n  TreeNode* root = buildTree(vals);\n  vector<int> res = boundaryTraversal(root);\n  for (int x : res) cout << x << \' \';\n  return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function boundaryTraversal(root) {\n  // write code here\n  return [];\n}',
      },
      {
        language: 'python',
        code: 'def boundaryTraversal(root):\n    # write code here\n    return []',
      },
      {
        language: 'java',
        code: 'public static List<Integer> boundaryTraversal(TreeNode root) {\n  // write code here\n  return new ArrayList<>();\n}',
      },
      {
        language: 'c',
        code: 'void boundaryTraversal(struct TreeNode* root) {\n  // write code here\n}',
      },
      {
        language: 'cpp',
        code: 'vector<int> boundaryTraversal(TreeNode* root) {\n  // write code here\n  return {};\n}',
      },
    ],
  },
  {
    title: 'Represent Graph Using Adjacency List',
    slug: 'represent-graph-using-adjacency-list',
    description:
      "Convert a graph's edge list representation into an adjacency list.",
    problemStatement:
      'You are given a graph with `n` nodes labeled from `0` to `n - 1` and a list of edges, where each edge is represented as a pair of nodes `[u, v]` indicating an undirected edge between node `u` and node `v`.\n\nYour task is to construct and return the adjacency list representation of the graph. Each node should map to a list of all nodes directly connected to it. The adjacency list for each node should be sorted in ascending order.\n\n<pre><code>Input:\nn = 5\nedges = [[0,1],[0,4],[1,2],[1,3],[1,4],[2,3],[3,4]]\n\nOutput:\n0: 1 4\n1: 0 2 3 4\n2: 1 3\n3: 1 2 4\n4: 0 1 3\n</code></pre>\n\nIn this example, each node has its neighbors listed in sorted order.\n\n<pre><code>Input:\nn = 3\nedges = [[0,1],[1,2]]\n\nOutput:\n0: 1\n1: 0 2\n2: 1\n</code></pre>\n\n<ul><li>1 ≤ n ≤ 1000</li><li>0 ≤ edges.length ≤ 5000</li><li>0 ≤ u, v &lt; n</li><li>u ≠ v (no self-loops)</li><li>No duplicate edges</li></ul>\n\nPro Tip – Use a dictionary or array of lists and loop through the edges to fill connections in both directions. Remember to sort each list before output.',
    sampleTestCases: [
      {
        input: '5\n7\n0 1\n0 4\n1 2\n1 3\n1 4\n2 3\n3 4',
        expected: '0: 1 4\n1: 0 2 3 4\n2: 1 3\n3: 1 2 4\n4: 0 1 3',
      },
      {
        input: '3\n2\n0 1\n1 2',
        expected: '0: 1\n1: 0 2\n2: 1',
      },
    ],
    testCases: [
      {
        input: '4\n0',
        expected: '0:\n1:\n2:\n3:',
      },
      {
        input: '2\n1\n0 1',
        expected: '0: 1\n1: 0',
      },
      {
        input: '5\n4\n0 1\n1 2\n2 3\n3 4',
        expected: '0: 1\n1: 0 2\n2: 1 3\n3: 2 4\n4: 3',
      },
      {
        input: '6\n5\n0 1\n1 2\n2 3\n3 4\n4 5',
        expected: '0: 1\n1: 0 2\n2: 1 3\n3: 2 4\n4: 3 5\n5: 4',
      },
      {
        input: '3\n0',
        expected: '0:\n1:\n2:',
      },
      {
        input: '4\n3\n0 1\n0 2\n0 3',
        expected: '0: 1 2 3\n1: 0\n2: 0\n3: 0',
      },
      {
        input: '5\n6\n0 1\n1 2\n2 3\n3 4\n4 0\n1 3',
        expected: '0: 1 4\n1: 0 2 3\n2: 1 3\n3: 1 2 4\n4: 0 3',
      },
      {
        input: '7\n5\n0 1\n1 2\n2 3\n3 4\n5 6',
        expected: '0: 1\n1: 0 2\n2: 1 3\n3: 2 4\n4: 3\n5: 6\n6: 5',
      },
      {
        input: '2\n0',
        expected: '0:\n1:',
      },
      {
        input: '3\n3\n0 1\n1 2\n0 2',
        expected: '0: 1 2\n1: 0 2\n2: 0 1',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're given a graph as a list of edges. Can you build the adjacency list representation of it, sorted for each node? This is a common subtask in bigger graph problems.",
    difficulty: 'easy',
    frequency: 71,
    tags: ['graph', 'adjacency list', 'implementation'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
      { name: 'Uber', logoUrl: '' },
    ],
    hints: [
      'Use an array of arrays or a dictionary to store adjacency lists.',
      'Add both u to v and v to u since the graph is undirected.',
      'Sort each adjacency list before printing.',
    ],
    optimalComplexity: {
      time: 'O(n + m log m)',
      space: 'O(n + m)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const m = parseInt(input[1]);\n  const adj = Array.from({ length: n }, () => []);\n  for (let i = 2; i < 2 + m; i++) {\n    const [u, v] = input[i].split(" ").map(Number);\n    adj[u].push(v);\n    adj[v].push(u);\n  }\n  for (let i = 0; i < n; i++) {\n    adj[i].sort((a, b) => a - b);\n    console.log(`${i}: ${adj[i].join(" ")}`);\n  }\n}\nmain();',
      },
      {
        language: 'python',
        code: 'if __name__ == "__main__":\n    import sys\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    m = int(input_lines[1])\n    adj = [[] for _ in range(n)]\n    for i in range(2, 2 + m):\n        u, v = map(int, input_lines[i].split())\n        adj[u].append(v)\n        adj[v].append(u)\n    for i in range(n):\n        adj[i].sort()\n        print(f"{i}: {\' \'.join(map(str, adj[i]))}")',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.nextLine());\n        int m = Integer.parseInt(sc.nextLine());\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\n        for (int i = 0; i < m; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n        for (int i = 0; i < n; i++) {\n            List<Integer> list = adj.get(i);\n            Collections.sort(list);\n            System.out.print(i + ":");\n            for (int num : list) System.out.print(" " + num);\n            System.out.println();\n        }\n    }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);\n}\n\nint main() {\n    int n, m;\n    scanf("%d\\n%d", &n, &m);\n    int *adj[n];\n    int size[n];\n    for (int i = 0; i < n; i++) {\n        adj[i] = (int *)malloc(1000 * sizeof(int));\n        size[i] = 0;\n    }\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf("%d %d", &u, &v);\n        adj[u][size[u]++] = v;\n        adj[v][size[v]++] = u;\n    }\n    for (int i = 0; i < n; i++) {\n        qsort(adj[i], size[i], sizeof(int), compare);\n        printf("%d:", i);\n        for (int j = 0; j < size[i]; j++) printf(" %d", adj[i][j]);\n        printf("\\n");\n    }\n    return 0;\n}',
      },
      {
        language: 'cpp',
        code: '#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    for (int i = 0; i < n; i++) {\n        sort(adj[i].begin(), adj[i].end());\n        cout << i << ":";\n        for (int val : adj[i]) cout << " " << val;\n        cout << endl;\n    }\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function buildAdjacencyList(n, edges) {\n  // write code here\n}',
      },
      {
        language: 'python',
        code: 'def build_adjacency_list(n, edges):\n    # write code here\n    pass',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Solution {\n    public Map<Integer, List<Integer>> buildAdjacencyList(int n, int[][] edges) {\n        // write code here\n        return null;\n    }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\nvoid buildAdjList(int n, int m, int edges[][2]) {\n    // write code here\n}',
      },
      {
        language: 'cpp',
        code: '#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> buildAdjacencyList(int n, vector<pair<int, int>>& edges) {\n    // write code here\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Represent Graph using Adjacency Matrix',
    slug: 'represent-graph-using-adjacency-matrix',
    description:
      'Convert an undirected or directed graph into an adjacency matrix.',
    problemStatement:
      'You are given a graph with `n` nodes (labeled from `0` to `n - 1`) and a list of `edges`, where each edge is a pair `[u, v]` representing a connection between node `u` and node `v`. The graph may be either **directed** or **undirected** based on the provided boolean flag `isDirected`. Your task is to return the **adjacency matrix** representation of the graph.\n\nIn the adjacency matrix, `matrix[i][j] = 1` means there is an edge from node `i` to node `j`; otherwise, it is `0`.\n\n### Examples:\n\n<pre><code>Input:\nn = 3\nedges = [[0, 1], [1, 2]]\nisDirected = false\n\nOutput:\n[[0, 1, 0],\n [1, 0, 1],\n [0, 1, 0]]\n</code></pre>\nExplanation: Since the graph is undirected, edges are bidirectional.\n\n<pre><code>Input:\nn = 3\nedges = [[0, 1], [1, 2]]\nisDirected = true\n\nOutput:\n[[0, 1, 0],\n [0, 0, 1],\n [0, 0, 0]]\n</code></pre>\nExplanation: Since the graph is directed, only the given directions are set.\n\n<ul>\n<li>1 ≤ n ≤ 100</li>\n<li>0 ≤ edges.length ≤ n * (n - 1)</li>\n<li>0 ≤ u, v < n</li>\n<li>isDirected is either true or false</li>\n</ul>\n\n**Pro Tip:** Start by initializing a 2D array of size `n x n` with all 0s, then iterate through the edges and populate the matrix accordingly.',
    sampleTestCases: [
      {
        input: '3\n2\n0 1\n1 2\nfalse',
        expected: '0 1 0\n1 0 1\n0 1 0',
      },
      {
        input: '3\n2\n0 1\n1 2\ntrue',
        expected: '0 1 0\n0 0 1\n0 0 0',
      },
    ],
    testCases: [
      { input: '1\n0\n\nfalse', expected: '0' },
      { input: '2\n1\n0 1\nfalse', expected: '0 1\n1 0' },
      { input: '2\n1\n0 1\ntrue', expected: '0 1\n0 0' },
      { input: '3\n3\n0 1\n1 2\n2 0\nfalse', expected: '0 1 1\n1 0 1\n1 1 0' },
      { input: '3\n3\n0 1\n1 2\n2 0\ntrue', expected: '0 1 0\n0 0 1\n1 0 0' },
      {
        input: '4\n4\n0 1\n1 2\n2 3\n3 0\nfalse',
        expected: '0 1 0 1\n1 0 1 0\n0 1 0 1\n1 0 1 0',
      },
      {
        input: '4\n4\n0 1\n1 2\n2 3\n3 0\ntrue',
        expected: '0 1 0 0\n0 0 1 0\n0 0 0 1\n1 0 0 0',
      },
      {
        input: '5\n0\n\nfalse',
        expected: '0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0\n0 0 0 0 0',
      },
      { input: '3\n2\n1 0\n2 1\ntrue', expected: '0 0 0\n1 0 0\n0 1 0' },
      { input: '3\n2\n1 0\n2 1\nfalse', expected: '0 1 0\n1 0 1\n0 1 0' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're designing an algorithm to represent a network of nodes efficiently for a network routing application. Can you write a function that takes a list of connections and builds an adjacency matrix representation of the network?",
    difficulty: 'easy',
    frequency: 63,
    tags: ['graph', 'matrix', 'implementation'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Initialize a 2D array filled with 0s.',
      'For each edge [u, v], set matrix[u][v] = 1. If undirected, also set matrix[v][u] = 1.',
    ],
    optimalComplexity: {
      time: 'O(n^2)',
      space: 'O(n^2)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const m = parseInt(input[1]);\n  const edges = [];\n  for (let i = 0; i < m; i++) {\n    const [u, v] = input[2 + i].split(' ').map(Number);\n    edges.push([u, v]);\n  }\n  const isDirected = input[2 + m] === 'true';\n  const result = buildAdjacencyMatrix(n, edges, isDirected);\n  for (let row of result) console.log(row.join(' '));\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    m = int(input_lines[1])\n    edges = [tuple(map(int, line.split())) for line in input_lines[2:2 + m]]\n    is_directed = input_lines[2 + m] == 'true'\n\n    matrix = build_adjacency_matrix(n, edges, is_directed)\n    for row in matrix:\n        print(' '.join(map(str, row)))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int m = Integer.parseInt(sc.nextLine());\n    int[][] matrix = new int[n][n];\n    for (int i = 0; i < m; i++) {\n      String[] edge = sc.nextLine().split(" ");\n      int u = Integer.parseInt(edge[0]);\n      int v = Integer.parseInt(edge[1]);\n      matrix[u][v] = 1;\n      if (!sc.hasNext("true")) matrix[v][u] = 1;\n    }\n    boolean isDirected = sc.nextBoolean();\n    for (int[] row : matrix) {\n      System.out.println(Arrays.toString(row).replaceAll("[\\[\\],]", ""));\n    }\n  }\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function buildAdjacencyMatrix(n, edges, isDirected) {\n  const matrix = Array.from({ length: n }, () => Array(n).fill(0));\n  for (const [u, v] of edges) {\n    matrix[u][v] = 1;\n    if (!isDirected) matrix[v][u] = 1;\n  }\n  return matrix;\n}',
      },
      {
        language: 'python',
        code: 'def build_adjacency_matrix(n, edges, is_directed):\n    matrix = [[0] * n for _ in range(n)]\n    for u, v in edges:\n        matrix[u][v] = 1\n        if not is_directed:\n            matrix[v][u] = 1\n    return matrix',
      },
      {
        language: 'java',
        code: 'public static int[][] buildAdjacencyMatrix(int n, int[][] edges, boolean isDirected) {\n    int[][] matrix = new int[n][n];\n    for (int[] edge : edges) {\n        int u = edge[0], v = edge[1];\n        matrix[u][v] = 1;\n        if (!isDirected) matrix[v][u] = 1;\n    }\n    return matrix;\n}',
      },
    ],
  },
  {
    title: 'DFS Traversal (Recursive & Iterative)',
    slug: 'dfs-traversal-recursive-iterative',
    description:
      'Perform both recursive and iterative Depth-First Search on a graph starting from a given node.',
    problemStatement:
      'You are given an undirected graph represented by `n` nodes labeled `0` to `n-1`, and a list of `edges`. You are also given a starting node `start`. Implement both **recursive** and **iterative** versions of Depth-First Search (DFS) traversal starting from `start`.\n\nReturn the list of nodes visited in DFS order for both recursive and iterative methods.\n\n### Examples:\n\n<pre><code>Input:\nn = 5\nedges = [[0,1],[0,2],[1,3],[1,4]]\nstart = 0\n\nOutput:\nRecursive: [0, 1, 3, 4, 2]\nIterative: [0, 2, 1, 4, 3]\n</code></pre>\nExplanation: DFS may have different valid orders depending on adjacency list order. Both are valid.\n\n<pre><code>Input:\nn = 3\nedges = [[0,1],[1,2]]\nstart = 1\n\nOutput:\nRecursive: [1, 0, 2]\nIterative: [1, 2, 0]\n</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 100</li>\n<li>0 ≤ edges.length ≤ n * (n - 1)</li>\n<li>0 ≤ u, v < n</li>\n<li>0 ≤ start < n</li>\n</ul>\n\n**Pro Tip:** Use a visited set or array to avoid infinite cycles. Stack is used for iterative DFS.',
    sampleTestCases: [
      {
        input: '5\n4\n0 1\n0 2\n1 3\n1 4\n0',
        expected: 'Recursive: 0 1 3 4 2\nIterative: 0 2 1 4 3',
      },
      {
        input: '3\n2\n0 1\n1 2\n1',
        expected: 'Recursive: 1 0 2\nIterative: 1 2 0',
      },
    ],
    testCases: [
      { input: '1\n0\n\n0', expected: 'Recursive: 0\nIterative: 0' },
      { input: '2\n1\n0 1\n0', expected: 'Recursive: 0 1\nIterative: 0 1' },
      {
        input: '4\n3\n0 1\n0 2\n1 3\n0',
        expected: 'Recursive: 0 1 3 2\nIterative: 0 2 1 3',
      },
      {
        input: '4\n3\n0 1\n0 2\n2 3\n0',
        expected: 'Recursive: 0 1 2 3\nIterative: 0 2 3 1',
      },
      {
        input: '5\n4\n0 1\n0 2\n1 3\n1 4\n1',
        expected: 'Recursive: 1 0 2 3 4\nIterative: 1 4 3 0 2',
      },
      {
        input: '6\n5\n0 1\n1 2\n1 3\n3 4\n4 5\n0',
        expected: 'Recursive: 0 1 2 3 4 5\nIterative: 0 1 3 4 5 2',
      },
      {
        input: '6\n5\n0 1\n1 2\n2 3\n3 4\n4 5\n3',
        expected: 'Recursive: 3 2 1 0 4 5\nIterative: 3 4 5 2 1 0',
      },
      { input: '3\n1\n0 2\n0', expected: 'Recursive: 0 2\nIterative: 0 2' },
      { input: '3\n1\n0 2\n2', expected: 'Recursive: 2 0\nIterative: 2 0' },
      {
        input: '5\n2\n0 1\n2 3\n0',
        expected: 'Recursive: 0 1\nIterative: 0 1',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Suppose you're debugging a large graph structure. Write both recursive and iterative versions of DFS to help traverse all connected nodes from a given starting node.",
    difficulty: 'medium',
    frequency: 71,
    tags: ['dfs', 'graph', 'recursion', 'stack'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use adjacency list to build the graph.',
      'Track visited nodes to avoid cycles.',
      'For iterative, use stack initialized with start node.',
    ],
    optimalComplexity: {
      time: 'O(n + e)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const m = parseInt(input[1]);\n  const edges = [];\n  for (let i = 0; i < m; i++) {\n    const [u, v] = input[2 + i].split(' ').map(Number);\n    edges.push([u, v]);\n  }\n  const start = parseInt(input[2 + m]);\n  const { recursiveResult, iterativeResult } = dfsTraversal(n, edges, start);\n  console.log('Recursive:', recursiveResult.join(' '));\n  console.log('Iterative:', iterativeResult.join(' '));\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    m = int(input_lines[1])\n    edges = [tuple(map(int, line.split())) for line in input_lines[2:2 + m]]\n    start = int(input_lines[2 + m])\n    recursive_result, iterative_result = dfs_traversal(n, edges, start)\n    print('Recursive:', ' '.join(map(str, recursive_result)))\n    print('Iterative:', ' '.join(map(str, iterative_result)))",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function dfsTraversal(n, edges, start) {\n  const adj = Array.from({ length: n }, () => []);\n  for (const [u, v] of edges) {\n    adj[u].push(v);\n    adj[v].push(u);\n  }\n\n  const recursiveResult = [];\n  const visited = Array(n).fill(false);\n\n  function dfs(node) {\n    visited[node] = true;\n    recursiveResult.push(node);\n    for (const neighbor of adj[node]) {\n      if (!visited[neighbor]) dfs(neighbor);\n    }\n  }\n  dfs(start);\n\n  const iterativeResult = [];\n  const seen = Array(n).fill(false);\n  const stack = [start];\n  while (stack.length) {\n    const node = stack.pop();\n    if (seen[node]) continue;\n    seen[node] = true;\n    iterativeResult.push(node);\n    for (let i = adj[node].length - 1; i >= 0; i--) {\n      if (!seen[adj[node][i]]) stack.push(adj[node][i]);\n    }\n  }\n\n  return { recursiveResult, iterativeResult };\n}',
      },
      {
        language: 'python',
        code: 'def dfs_traversal(n, edges, start):\n    from collections import defaultdict\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * n\n    recursive_result = []\n\n    def dfs(node):\n        visited[node] = True\n        recursive_result.append(node)\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    dfs(start)\n\n    iterative_result = []\n    seen = [False] * n\n    stack = [start]\n    while stack:\n        node = stack.pop()\n        if seen[node]:\n            continue\n        seen[node] = True\n        iterative_result.append(node)\n        for neighbor in reversed(adj[node]):\n            if not seen[neighbor]:\n                stack.append(neighbor)\n\n    return recursive_result, iterative_result',
      },
    ],
  },
  {
    title: 'BFS Traversal (Iterative)',
    slug: 'bfs-traversal-iterative',
    description:
      'Perform iterative Breadth-First Search traversal from a given start node in an undirected graph.',
    problemStatement:
      'You are given an undirected graph with `n` nodes labeled from `0` to `n - 1`, and a list of `edges`, where each edge is a pair `[u, v]` representing a connection between node `u` and node `v`. You are also given a starting node `start`. Implement an **iterative Breadth-First Search (BFS)** traversal of the graph starting from `start`.\n\nReturn a list representing the order in which nodes are visited during the BFS traversal.\n\n### Examples:\n\n<pre><code>Input:\nn = 5\nedges = [[0, 1], [0, 2], [1, 3], [1, 4]]\nstart = 0\n\nOutput:\n[0, 1, 2, 3, 4]\n</code></pre>\nExplanation: Starting from 0, visit its neighbors 1 and 2, then their neighbors 3 and 4.\n\n<pre><code>Input:\nn = 3\nedges = [[0, 1], [1, 2]]\nstart = 1\n\nOutput:\n[1, 0, 2]\n</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 100</li>\n<li>0 ≤ edges.length ≤ n * (n - 1)</li>\n<li>0 ≤ u, v < n</li>\n<li>0 ≤ start < n</li>\n</ul>\n\n**Pro Tip:** Use a queue to keep track of nodes to visit next. A visited set helps prevent cycles and revisiting nodes.',
    sampleTestCases: [
      {
        input: '5\n4\n0 1\n0 2\n1 3\n1 4\n0',
        expected: '0 1 2 3 4',
      },
      {
        input: '3\n2\n0 1\n1 2\n1',
        expected: '1 0 2',
      },
    ],
    testCases: [
      { input: '1\n0\n\n0', expected: '0' },
      { input: '2\n1\n0 1\n0', expected: '0 1' },
      { input: '3\n2\n0 1\n0 2\n0', expected: '0 1 2' },
      { input: '4\n3\n0 1\n0 2\n2 3\n0', expected: '0 1 2 3' },
      { input: '5\n4\n0 1\n1 2\n2 3\n3 4\n0', expected: '0 1 2 3 4' },
      { input: '6\n5\n0 1\n0 2\n1 3\n3 4\n4 5\n0', expected: '0 1 2 3 4 5' },
      { input: '6\n5\n0 1\n1 2\n2 3\n3 4\n4 5\n3', expected: '3 2 4 1 5 0' },
      { input: '4\n2\n0 2\n1 3\n0', expected: '0 2' },
      { input: '4\n2\n0 2\n1 3\n1', expected: '1 3' },
      { input: '6\n3\n0 1\n2 3\n4 5\n2', expected: '2 3' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're implementing a graph traversal engine for a large-scale search engine. Can you write the iterative BFS that starts at any node and explores all connected nodes?",
    difficulty: 'medium',
    frequency: 70,
    tags: ['bfs', 'graph', 'queue'],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
    ],
    hints: [
      'Use a queue to explore nodes level by level.',
      'Mark each visited node to prevent revisiting.',
      'Build an adjacency list for efficient neighbor lookups.',
    ],
    optimalComplexity: {
      time: 'O(n + e)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const m = parseInt(input[1]);\n  const edges = [];\n  for (let i = 0; i < m; i++) {\n    const [u, v] = input[2 + i].split(' ').map(Number);\n    edges.push([u, v]);\n  }\n  const start = parseInt(input[2 + m]);\n  const result = bfsTraversal(n, edges, start);\n  console.log(result.join(' '));\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    from collections import deque\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    m = int(input_lines[1])\n    edges = [tuple(map(int, line.split())) for line in input_lines[2:2 + m]]\n    start = int(input_lines[2 + m])\n    result = bfs_traversal(n, edges, start)\n    print(' '.join(map(str, result)))",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function bfsTraversal(n, edges, start) {\n  const adj = Array.from({ length: n }, () => []);\n  for (const [u, v] of edges) {\n    adj[u].push(v);\n    adj[v].push(u);\n  }\n  const visited = Array(n).fill(false);\n  const queue = [start];\n  const result = [];\n  visited[start] = true;\n  while (queue.length > 0) {\n    const node = queue.shift();\n    result.push(node);\n    for (const neighbor of adj[node]) {\n      if (!visited[neighbor]) {\n        visited[neighbor] = true;\n        queue.push(neighbor);\n      }\n    }\n  }\n  return result;\n}',
      },
      {
        language: 'python',
        code: 'def bfs_traversal(n, edges, start):\n    from collections import deque, defaultdict\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    visited = [False] * n\n    queue = deque([start])\n    visited[start] = True\n    result = []\n    while queue:\n        node = queue.popleft()\n        result.append(node)\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    return result',
      },
    ],
  },
  {
    title: 'Detect Cycle in Undirected Graph (DFS/BFS)',
    slug: 'detect-cycle-in-undirected-graph-dfs-bfs',
    description:
      'Check whether an undirected graph contains a cycle using either DFS or BFS.',
    problemStatement:
      'Given an undirected graph with `n` nodes labeled from `0` to `n - 1` and a list of edges, determine whether the graph contains a cycle. You can use either **DFS** or **BFS** traversal to solve the problem.\n\nReturn `true` if the graph contains a cycle, otherwise return `false`.\n\n### Examples:\n\n<pre><code>Input:\nn = 5\nedges = [[0, 1], [1, 2], [2, 0], [3, 4]]\n\nOutput:\ntrue\n</code></pre>\nExplanation: The cycle is formed by nodes 0 → 1 → 2 → 0.\n\n<pre><code>Input:\nn = 4\nedges = [[0, 1], [1, 2], [2, 3]]\n\nOutput:\nfalse\n</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 100</li>\n<li>0 ≤ edges.length ≤ n * (n - 1)</li>\n<li>0 ≤ u, v < n</li>\n</ul>\n\n**Pro Tip:** In DFS, keep track of the parent of each node to avoid counting the edge back to the parent as a cycle. In BFS, use a queue with parent tracking for the same reason.',
    sampleTestCases: [
      {
        input: '5\n4\n0 1\n1 2\n2 0\n3 4',
        expected: 'true',
      },
      {
        input: '4\n3\n0 1\n1 2\n2 3',
        expected: 'false',
      },
    ],
    testCases: [
      { input: '1\n0\n', expected: 'false' },
      { input: '2\n1\n0 1', expected: 'false' },
      { input: '3\n3\n0 1\n1 2\n2 0', expected: 'true' },
      { input: '4\n4\n0 1\n1 2\n2 3\n3 0', expected: 'true' },
      { input: '4\n2\n0 1\n2 3', expected: 'false' },
      { input: '6\n5\n0 1\n1 2\n2 0\n3 4\n4 5', expected: 'true' },
      { input: '6\n4\n0 1\n1 2\n3 4\n4 5', expected: 'false' },
      { input: '5\n5\n0 1\n1 2\n2 3\n3 4\n4 0', expected: 'true' },
      { input: '3\n2\n0 1\n1 2', expected: 'false' },
      { input: '5\n4\n0 1\n1 2\n2 3\n3 0', expected: 'true' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're designing a safety checker for an undirected graph network. Can you detect if there's a cycle in the graph using DFS or BFS?",
    difficulty: 'medium',
    frequency: 75,
    tags: ['graph', 'cycle detection', 'dfs', 'bfs'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'In DFS, pass the parent node to avoid false cycle detection.',
      'In BFS, use a queue and store the current node and its parent.',
      'Mark nodes as visited as soon as they’re added to the stack or queue.',
    ],
    optimalComplexity: {
      time: 'O(n + e)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const m = parseInt(input[1]);\n  const edges = [];\n  for (let i = 0; i < m; i++) {\n    const [u, v] = input[2 + i].split(' ').map(Number);\n    edges.push([u, v]);\n  }\n  const result = hasCycle(n, edges);\n  console.log(result.toString());\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    m = int(input_lines[1])\n    edges = [tuple(map(int, line.split())) for line in input_lines[2:2 + m]]\n    print(str(has_cycle(n, edges)).lower())",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function hasCycle(n, edges) {\n  const adj = Array.from({ length: n }, () => []);\n  for (const [u, v] of edges) {\n    adj[u].push(v);\n    adj[v].push(u);\n  }\n\n  const visited = Array(n).fill(false);\n\n  function dfs(node, parent) {\n    visited[node] = true;\n    for (const neighbor of adj[node]) {\n      if (!visited[neighbor]) {\n        if (dfs(neighbor, node)) return true;\n      } else if (neighbor !== parent) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  for (let i = 0; i < n; i++) {\n    if (!visited[i]) {\n      if (dfs(i, -1)) return true;\n    }\n  }\n  return false;\n}',
      },
      {
        language: 'python',
        code: 'def has_cycle(n, edges):\n    from collections import defaultdict\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * n\n\n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True\n        return False\n\n    for i in range(n):\n        if not visited[i]:\n            if dfs(i, -1):\n                return True\n    return False',
      },
    ],
  },
  {
    title: 'Detect Cycle in Directed Graph (DFS with Recursion Stack)',
    slug: 'detect-cycle-in-directed-graph-dfs-recursion-stack',
    description:
      'Determine if a directed graph contains a cycle using DFS and a recursion stack.',
    problemStatement:
      'You are given a **directed** graph with `n` nodes labeled from `0` to `n - 1` and a list of directed edges. Your task is to determine whether the graph contains a **cycle**.\n\nUse **Depth-First Search (DFS)** along with a recursion stack to detect cycles. Return `true` if the graph has a cycle, otherwise return `false`.\n\n### Examples:\n\n<pre><code>Input:\nn = 4\nedges = [[0, 1], [1, 2], [2, 3], [3, 1]]\n\nOutput:\ntrue\n</code></pre>\nExplanation: A cycle exists: 1 → 2 → 3 → 1\n\n<pre><code>Input:\nn = 4\nedges = [[0, 1], [1, 2], [2, 3]]\n\nOutput:\nfalse\n</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 100</li>\n<li>0 ≤ edges.length ≤ n * (n - 1)</li>\n<li>0 ≤ u, v < n</li>\n</ul>\n\n**Pro Tip:** Use a recursion stack in addition to the visited array. If a node is revisited while still in the recursion stack, a cycle is detected.',
    sampleTestCases: [
      {
        input: '4\n4\n0 1\n1 2\n2 3\n3 1',
        expected: 'true',
      },
      {
        input: '4\n3\n0 1\n1 2\n2 3',
        expected: 'false',
      },
    ],
    testCases: [
      { input: '1\n0\n', expected: 'false' },
      { input: '2\n1\n0 1', expected: 'false' },
      { input: '3\n3\n0 1\n1 2\n2 0', expected: 'true' },
      { input: '5\n5\n0 1\n1 2\n2 3\n3 4\n4 0', expected: 'true' },
      { input: '5\n4\n0 1\n1 2\n2 3\n3 4', expected: 'false' },
      { input: '6\n6\n0 1\n1 2\n2 3\n3 1\n4 5\n5 4', expected: 'true' },
      { input: '6\n5\n0 1\n1 2\n2 3\n3 4\n4 5', expected: 'false' },
      { input: '3\n2\n0 1\n1 1', expected: 'true' },
      { input: '3\n3\n0 1\n1 2\n2 2', expected: 'true' },
      { input: '4\n2\n0 1\n2 3', expected: 'false' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're working on a dependency resolver for a build system. Can you detect if there's a cycle in a directed graph using DFS and a recursion stack?",
    difficulty: 'medium',
    frequency: 77,
    tags: ['graph', 'dfs', 'cycle detection', 'recursion'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Netflix', logoUrl: '' },
    ],
    hints: [
      'Maintain a recursion stack alongside visited nodes.',
      'If a node is reached that is already in the recursion stack, a cycle is detected.',
      "Don't forget to remove nodes from recursion stack once recursion unwinds.",
    ],
    optimalComplexity: {
      time: 'O(n + e)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const m = parseInt(input[1]);\n  const edges = [];\n  for (let i = 0; i < m; i++) {\n    const [u, v] = input[2 + i].split(' ').map(Number);\n    edges.push([u, v]);\n  }\n  const result = hasCycle(n, edges);\n  console.log(result.toString());\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    m = int(input_lines[1])\n    edges = [tuple(map(int, line.split())) for line in input_lines[2:2 + m]]\n    print(str(has_cycle(n, edges)).lower())",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function hasCycle(n, edges) {\n  const adj = Array.from({ length: n }, () => []);\n  for (const [u, v] of edges) adj[u].push(v);\n\n  const visited = Array(n).fill(false);\n  const recStack = Array(n).fill(false);\n\n  function dfs(node) {\n    visited[node] = true;\n    recStack[node] = true;\n\n    for (const neighbor of adj[node]) {\n      if (!visited[neighbor]) {\n        if (dfs(neighbor)) return true;\n      } else if (recStack[neighbor]) {\n        return true;\n      }\n    }\n\n    recStack[node] = false;\n    return false;\n  }\n\n  for (let i = 0; i < n; i++) {\n    if (!visited[i] && dfs(i)) return true;\n  }\n  return false;\n}',
      },
      {
        language: 'python',
        code: 'def has_cycle(n, edges):\n    from collections import defaultdict\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n\n    visited = [False] * n\n    rec_stack = [False] * n\n\n    def dfs(node):\n        visited[node] = True\n        rec_stack[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor):\n                    return True\n            elif rec_stack[neighbor]:\n                return True\n        rec_stack[node] = False\n        return False\n\n    for i in range(n):\n        if not visited[i]:\n            if dfs(i):\n                return True\n    return False',
      },
    ],
  },
  {
    title: 'Check if Graph is Bipartite (BFS/DFS)',
    slug: 'check-if-graph-is-bipartite-bfs-dfs',
    description:
      'Determine if an undirected graph is bipartite using BFS or DFS traversal.',
    problemStatement:
      'You are given an **undirected** graph with `n` nodes labeled from `0` to `n - 1` and a list of edges. Your task is to determine whether the graph is **bipartite**.\n\nA graph is bipartite if its nodes can be colored using two colors such that no two adjacent nodes have the same color. Use **BFS** or **DFS** to solve this.\n\nReturn `true` if the graph is bipartite, otherwise return `false`.\n\n### Examples:\n\n<pre><code>Input:\nn = 4\nedges = [[0, 1], [0, 3], [1, 2], [2, 3]]\n\nOutput:\nfalse\n</code></pre>\nExplanation: The graph contains an odd-length cycle: 0 → 1 → 2 → 3 → 0\n\n<pre><code>Input:\nn = 3\nedges = [[0, 1], [1, 2]]\n\nOutput:\ntrue\n</code></pre>\nExplanation: Nodes can be colored as [0, 1, 0].\n\n<ul>\n<li>1 ≤ n ≤ 100</li>\n<li>0 ≤ edges.length ≤ n * (n - 1) / 2</li>\n<li>0 ≤ u, v < n</li>\n</ul>\n\n**Pro Tip:** Try coloring the graph using two colors (e.g., 0 and 1). If any adjacent nodes have the same color, it’s not bipartite.',
    sampleTestCases: [
      {
        input: '4\n4\n0 1\n0 3\n1 2\n2 3',
        expected: 'false',
      },
      {
        input: '3\n2\n0 1\n1 2',
        expected: 'true',
      },
    ],
    testCases: [
      { input: '1\n0\n', expected: 'true' },
      { input: '2\n1\n0 1', expected: 'true' },
      { input: '3\n3\n0 1\n1 2\n2 0', expected: 'false' },
      { input: '4\n2\n0 1\n2 3', expected: 'true' },
      { input: '5\n4\n0 1\n1 2\n2 3\n3 4', expected: 'true' },
      { input: '5\n5\n0 1\n1 2\n2 3\n3 4\n4 0', expected: 'false' },
      { input: '6\n6\n0 1\n1 2\n2 3\n3 4\n4 5\n5 0', expected: 'false' },
      { input: '6\n5\n0 1\n1 2\n2 3\n3 4\n4 5', expected: 'true' },
      { input: '6\n3\n0 1\n2 3\n4 5', expected: 'true' },
      { input: '3\n3\n0 1\n1 2\n2 0', expected: 'false' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re working on a system that organizes people into two groups based on relationships. Can you check if a graph of their relationships is bipartite using BFS or DFS?',
    difficulty: 'medium',
    frequency: 74,
    tags: ['graph', 'bfs', 'dfs', 'coloring'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use an array to store colors (e.g., 0 or 1) of each node.',
      'Start from any unvisited node and color it. Color all neighbors with the opposite color.',
      'If any neighbor has the same color, return false.',
    ],
    optimalComplexity: {
      time: 'O(n + e)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 2,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const m = parseInt(input[1]);\n  const edges = [];\n  for (let i = 0; i < m; i++) {\n    const [u, v] = input[2 + i].split(' ').map(Number);\n    edges.push([u, v]);\n  }\n  const result = isBipartite(n, edges);\n  console.log(result.toString());\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    m = int(input_lines[1])\n    edges = [tuple(map(int, line.split())) for line in input_lines[2:2 + m]]\n    print(str(is_bipartite(n, edges)).lower())",
      },
      {
        language: 'c++',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> adj(n);\n    for(int i = 0; i < m; i++){\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    vector<int> color(n, -1);\n    queue<int> q;\n    for(int i = 0; i < n; i++){\n        if(color[i] == -1){\n            color[i] = 0;\n            q.push(i);\n            while(!q.empty()){\n                int node = q.front(); q.pop();\n                for(int nei : adj[node]){\n                    if(color[nei] == -1){\n                        color[nei] = 1 - color[node];\n                        q.push(nei);\n                    } else if (color[nei] == color[node]) {\n                        cout << "false";\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n    cout << "true";\n    return 0;\n}',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Integer>> adj = new ArrayList<>();\n        for(int i = 0; i < n; i++) adj.add(new ArrayList<>());\n        for(int i = 0; i < m; i++){\n            int u = sc.nextInt(), v = sc.nextInt();\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n        int[] color = new int[n]; Arrays.fill(color, -1);\n        Queue<Integer> q = new LinkedList<>();\n        for(int i = 0; i < n; i++){\n            if(color[i] == -1){\n                color[i] = 0;\n                q.add(i);\n                while(!q.isEmpty()){\n                    int node = q.poll();\n                    for(int nei : adj.get(node)){\n                        if(color[nei] == -1){\n                            color[nei] = 1 - color[node];\n                            q.add(nei);\n                        } else if (color[nei] == color[node]) {\n                            System.out.println(false);\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        System.out.println(true);\n    }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nint main() {\n    int n, m;\n    scanf("%d %d", &n, &m);\n    int **adj = malloc(n * sizeof(int*));\n    int *deg = calloc(n, sizeof(int));\n    for(int i = 0; i < n; i++) adj[i] = calloc(n, sizeof(int));\n    for(int i = 0; i < m; i++){\n        int u, v;\n        scanf("%d %d", &u, &v);\n        adj[u][deg[u]++] = v;\n        adj[v][deg[v]++] = u;\n    }\n    int *color = malloc(n * sizeof(int));\n    for(int i = 0; i < n; i++) color[i] = -1;\n    int *queue = malloc(n * sizeof(int));\n    for(int i = 0; i < n; i++){\n        if(color[i] == -1){\n            int front = 0, back = 0;\n            color[i] = 0;\n            queue[back++] = i;\n            while(front < back){\n                int node = queue[front++];\n                for(int j = 0; j < deg[node]; j++){\n                    int nei = adj[node][j];\n                    if(color[nei] == -1){\n                        color[nei] = 1 - color[node];\n                        queue[back++] = nei;\n                    } else if(color[nei] == color[node]){\n                        printf("false");\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n    printf("true");\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function isBipartite(n, edges) {\n  const adj = Array.from({ length: n }, () => []);\n  for (const [u, v] of edges) {\n    adj[u].push(v);\n    adj[v].push(u);\n  }\n  const color = Array(n).fill(-1);\n  for (let i = 0; i < n; i++) {\n    if (color[i] === -1) {\n      const queue = [i];\n      color[i] = 0;\n      while (queue.length > 0) {\n        const node = queue.shift();\n        for (const neighbor of adj[node]) {\n          if (color[neighbor] === -1) {\n            color[neighbor] = 1 - color[node];\n            queue.push(neighbor);\n          } else if (color[neighbor] === color[node]) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n  return true;\n}',
      },
      {
        language: 'python',
        code: 'def is_bipartite(n, edges):\n    from collections import defaultdict, deque\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    color = [-1] * n\n    for i in range(n):\n        if color[i] == -1:\n            queue = deque([i])\n            color[i] = 0\n            while queue:\n                node = queue.popleft()\n                for neighbor in adj[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True',
      },
      {
        language: 'c++',
        code: 'bool isBipartite(int n, vector<pair<int,int>> &edges) {\n    vector<vector<int>> adj(n);\n    for(auto &e: edges){ adj[e.first].push_back(e.second); adj[e.second].push_back(e.first); }\n    vector<int> color(n, -1);\n    queue<int> q;\n    for(int i = 0; i < n; i++){\n        if(color[i] == -1){\n            color[i] = 0;\n            q.push(i);\n            while(!q.empty()){\n                int u = q.front(); q.pop();\n                for(int v: adj[u]){\n                    if(color[v] == -1){ color[v] = 1 - color[u]; q.push(v); }\n                    else if(color[v] == color[u]) return false;\n                }\n            }\n        }\n    }\n    return true;\n}',
      },
      {
        language: 'java',
        code: 'boolean isBipartite(int n, List<int[]> edges) {\n    List<List<Integer>> adj = new ArrayList<>();\n    for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\n    for (int[] e : edges) { adj.get(e[0]).add(e[1]); adj.get(e[1]).add(e[0]); }\n    int[] color = new int[n]; Arrays.fill(color, -1);\n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 0; i < n; i++) {\n        if (color[i] == -1) {\n            color[i] = 0;\n            q.add(i);\n            while (!q.isEmpty()) {\n                int u = q.poll();\n                for (int v : adj.get(u)) {\n                    if (color[v] == -1) { color[v] = 1 - color[u]; q.add(v);} \n                    else if (color[v] == color[u]) return false;\n                }\n            }\n        }\n    }\n    return true;\n}',
      },
      {
        language: 'c',
        code: 'bool isBipartite(int n, int edges[][2], int m) {\n    int **adj = malloc(n * sizeof(int*));\n    int *deg = calloc(n, sizeof(int));\n    for(int i=0; i<n; i++) adj[i] = calloc(n, sizeof(int));\n    for(int i=0; i<m; i++){adj[edges[i][0]][deg[edges[i][0]]++] = edges[i][1]; adj[edges[i][1]][deg[edges[i][1]]++] = edges[i][0];}\n    int *color = malloc(n * sizeof(int)); for(int i=0;i<n;i++) color[i]=-1;\n    int *queue = malloc(n * sizeof(int));\n    for(int i=0;i<n;i++){\n        if(color[i]==-1){\n            int front=0, back=0;\n            color[i]=0;\n            queue[back++]=i;\n            while(front<back){\n                int u=queue[front++];\n                for(int j=0;j<deg[u];j++){\n                    int v=adj[u][j];\n                    if(color[v]==-1){ color[v]=1-color[u]; queue[back++]=v; }\n                    else if(color[v]==color[u]) { free(adj); free(deg); free(color); free(queue); return false; }\n                }\n            }\n        }\n    }\n    free(adj); free(deg); free(color); free(queue);\n    return true;\n}',
      },
    ],
  },
  {
    title: 'Count Connected Components',
    slug: 'count-connected-components',
    description:
      'Count the number of connected components in an undirected graph.',
    problemStatement:
      'You are given an **undirected graph** with `n` nodes labeled from `0` to `n - 1` and a list of edges. Your task is to count the number of **connected components** in the graph.\n\nA connected component is a group of nodes such that each node is reachable from any other node in the same group.\n\nReturn an integer representing the total number of connected components.\n\n### Examples:\n\n<pre><code>Input:\nn = 5\nedges = [[0, 1], [1, 2], [3, 4]]\n\nOutput:\n2\n</code></pre>\nExplanation: The graph has two components: [0,1,2] and [3,4]\n\n<pre><code>Input:\nn = 4\nedges = [[0, 1], [2, 3]]\n\nOutput:\n2\n</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 100</li>\n<li>0 ≤ edges.length ≤ n * (n - 1) / 2</li>\n<li>0 ≤ u, v < n</li>\n</ul>\n\n**Pro Tip:** Use DFS or BFS to visit all nodes in a component and count how many separate calls are made.',
    sampleTestCases: [
      {
        input: '5\n3\n0 1\n1 2\n3 4',
        expected: '2',
      },
      {
        input: '4\n2\n0 1\n2 3',
        expected: '2',
      },
    ],
    testCases: [
      { input: '1\n0\n', expected: '1' },
      { input: '2\n1\n0 1', expected: '1' },
      { input: '3\n0\n', expected: '3' },
      { input: '4\n3\n0 1\n1 2\n2 3', expected: '1' },
      { input: '5\n2\n0 1\n2 3', expected: '3' },
      { input: '6\n3\n0 1\n1 2\n4 5', expected: '3' },
      { input: '7\n4\n0 1\n1 2\n3 4\n5 6', expected: '3' },
      { input: '6\n0\n', expected: '6' },
      { input: '3\n2\n0 1\n1 2', expected: '1' },
      { input: '4\n1\n0 1', expected: '3' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're managing a social network and want to find out how many isolated user clusters exist. Implement a function to count connected components in an undirected graph.",
    difficulty: 'easy',
    frequency: 68,
    tags: ['graph', 'connected components', 'dfs', 'bfs'],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use DFS or BFS from each unvisited node.',
      'Increment the counter each time a new traversal starts.',
    ],
    optimalComplexity: {
      time: 'O(n + e)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 2,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const m = parseInt(input[1]);\n  const edges = [];\n  for (let i = 0; i < m; i++) {\n    edges.push(input[2 + i].split(' ').map(Number));\n  }\n  console.log(countComponents(n, edges));\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    m = int(input_lines[1])\n    edges = [tuple(map(int, line.split())) for line in input_lines[2:2 + m]]\n    print(count_components(n, edges))",
      },
      {
        language: 'c++',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nvoid dfs(int u, vector<vector<int>> &adj, vector<bool> &vis) {\n    vis[u] = true;\n    for (int v : adj[u]) if (!vis[v]) dfs(v, adj, vis);\n}\nint main() {\n    int n, m; cin >> n >> m;\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < m; i++) {\n        int u, v; cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    vector<bool> vis(n, false);\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (!vis[i]) { dfs(i, adj, vis); count++; }\n    }\n    cout << count << endl;\n    return 0;\n}',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    static void dfs(int node, List<List<Integer>> adj, boolean[] vis) {\n        vis[node] = true;\n        for (int nei : adj.get(node)) {\n            if (!vis[nei]) dfs(nei, adj, vis);\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\n        for (int i = 0; i < m; i++) {\n            int u = sc.nextInt(), v = sc.nextInt();\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n        boolean[] vis = new boolean[n];\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (!vis[i]) {\n                dfs(i, adj, vis);\n                count++;\n            }\n        }\n        System.out.println(count);\n    }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\nint adj[100][100];\nbool vis[100];\nint n;\nvoid dfs(int u) {\n    vis[u] = true;\n    for (int v = 0; v < n; v++) {\n        if (adj[u][v] && !vis[v]) dfs(v);\n    }\n}\nint main() {\n    int m, u, v; scanf("%d%d", &n, &m);\n    for (int i = 0; i < m; i++) {\n        scanf("%d%d", &u, &v);\n        adj[u][v] = adj[v][u] = 1;\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (!vis[i]) {\n            dfs(i);\n            count++;\n        }\n    }\n    printf("%d\\n", count);\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function countComponents(n, edges) {\n  const adj = Array.from({ length: n }, () => []);\n  for (const [u, v] of edges) {\n    adj[u].push(v);\n    adj[v].push(u);\n  }\n  const visited = Array(n).fill(false);\n  let count = 0;\n  function dfs(node) {\n    visited[node] = true;\n    for (const nei of adj[node]) {\n      if (!visited[nei]) dfs(nei);\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    if (!visited[i]) {\n      dfs(i);\n      count++;\n    }\n  }\n  return count;\n}',
      },
      {
        language: 'python',
        code: 'def count_components(n, edges):\n    from collections import defaultdict\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    visited = [False] * n\n    def dfs(u):\n        visited[u] = True\n        for v in adj[u]:\n            if not visited[v]:\n                dfs(v)\n    count = 0\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            count += 1\n    return count',
      },
      {
        language: 'java',
        code: 'public static int countComponents(int n, List<int[]> edges) {\n    List<List<Integer>> adj = new ArrayList<>();\n    for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\n    for (int[] e : edges) {\n        adj.get(e[0]).add(e[1]);\n        adj.get(e[1]).add(e[0]);\n    }\n    boolean[] visited = new boolean[n];\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i, adj, visited);\n            count++;\n        }\n    }\n    return count;\n}\nstatic void dfs(int node, List<List<Integer>> adj, boolean[] visited) {\n    visited[node] = true;\n    for (int nei : adj.get(node)) {\n        if (!visited[nei]) dfs(nei, adj, visited);\n    }\n}',
      },
      {
        language: 'c++',
        code: 'int countComponents(int n, vector<pair<int, int>> &edges) {\n    vector<vector<int>> adj(n);\n    for (auto &[u, v] : edges) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    vector<bool> vis(n, false);\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (!vis[i]) {\n            dfs(i, adj, vis);\n            count++;\n        }\n    }\n    return count;\n}\nvoid dfs(int u, vector<vector<int>> &adj, vector<bool> &vis) {\n    vis[u] = true;\n    for (int v : adj[u]) {\n        if (!vis[v]) dfs(v, adj, vis);\n    }\n}',
      },
    ],
  },
  {
    title: 'Check if Path Exists Between Two Nodes',
    slug: 'check-if-path-exists-between-two-nodes',
    description:
      'Determine if there is a path between two nodes in an undirected graph.',
    problemStatement:
      'You are given an undirected graph with `n` nodes labeled from `0` to `n - 1` and a list of `edges`, where each edge connects two nodes. You are also given two nodes `source` and `destination`. Return `true` if there is a valid path from `source` to `destination`, otherwise return `false`.\n\n### Examples:\n\n<pre><code>Input:\nn = 6\nedges = [[0, 1], [0, 2], [3, 5], [5, 4], [4, 3]]\nsource = 0\ndestination = 5\n\nOutput:\nfalse\n</code></pre>\n\n<pre><code>Input:\nn = 3\nedges = [[0, 1], [1, 2], [2, 0]]\nsource = 0\ndestination = 2\n\nOutput:\ntrue\n</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 100</li>\n<li>0 ≤ edges.length ≤ n * (n - 1) / 2</li>\n<li>0 ≤ source, destination < n</li>\n</ul>\n\n**Pro Tip:** Use BFS or DFS starting from the `source` node. If you reach the `destination`, return true.',
    sampleTestCases: [
      {
        input: '6\n5\n0 1\n0 2\n3 5\n5 4\n4 3\n0\n5',
        expected: 'false',
      },
      {
        input: '3\n3\n0 1\n1 2\n2 0\n0\n2',
        expected: 'true',
      },
    ],
    testCases: [
      { input: '1\n0\n\n0\n0', expected: 'true' },
      { input: '2\n1\n0 1\n0\n1', expected: 'true' },
      { input: '3\n1\n0 1\n0\n2', expected: 'false' },
      { input: '4\n2\n0 1\n2 3\n1\n3', expected: 'false' },
      { input: '5\n4\n0 1\n1 2\n2 3\n3 4\n0\n4', expected: 'true' },
      { input: '5\n3\n0 1\n1 2\n3 4\n2\n4', expected: 'false' },
      { input: '6\n5\n0 1\n0 2\n3 5\n5 4\n4 3\n0\n1', expected: 'true' },
      { input: '3\n2\n0 1\n1 2\n2\n0', expected: 'true' },
      { input: '3\n0\n\n0\n2', expected: 'false' },
      { input: '3\n2\n0 1\n1 2\n0\n0', expected: 'true' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're building a routing service. Can you determine whether two locations in the network are connected by a path?",
    difficulty: 'easy',
    frequency: 72,
    tags: ['graph', 'dfs', 'bfs', 'connectivity'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Apple', logoUrl: '' },
    ],
    hints: [
      'Use BFS or DFS from the source node.',
      'Mark visited nodes to avoid revisiting.',
      'If you reach the destination node, return true.',
    ],
    optimalComplexity: {
      time: 'O(n + e)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const m = parseInt(input[1]);\n  const edges = [];\n  for (let i = 0; i < m; i++) {\n    edges.push(input[2 + i].split(' ').map(Number));\n  }\n  const source = parseInt(input[2 + m]);\n  const destination = parseInt(input[3 + m]);\n  console.log(validPath(n, edges, source, destination).toString());\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    m = int(input_lines[1])\n    edges = [tuple(map(int, line.split())) for line in input_lines[2:2 + m]]\n    source = int(input_lines[2 + m])\n    destination = int(input_lines[3 + m])\n    print(str(valid_path(n, edges, source, destination)).lower())",
      },
      {
        language: 'c++',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nbool dfs(int u, int dest, vector<vector<int>> &adj, vector<bool> &vis) {\n    if (u == dest) return true;\n    vis[u] = true;\n    for (int v : adj[u]) if (!vis[v] && dfs(v, dest, adj, vis)) return true;\n    return false;\n}\nint main() {\n    int n, m; cin >> n >> m;\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < m; i++) {\n        int u, v; cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    int s, d; cin >> s >> d;\n    vector<bool> vis(n, false);\n    cout << (dfs(s, d, adj, vis) ? "true" : "false") << endl;\n    return 0;\n}',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    static boolean dfs(int u, int dest, List<List<Integer>> adj, boolean[] vis) {\n        if (u == dest) return true;\n        vis[u] = true;\n        for (int v : adj.get(u)) if (!vis[v] && dfs(v, dest, adj, vis)) return true;\n        return false;\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\n        for (int i = 0; i < m; i++) {\n            int u = sc.nextInt(), v = sc.nextInt();\n            adj.get(u).add(v); adj.get(v).add(u);\n        }\n        int s = sc.nextInt(), d = sc.nextInt();\n        boolean[] vis = new boolean[n];\n        System.out.println(dfs(s, d, adj, vis));\n    }\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\n#include <stdbool.h>\nint adj[100][100], deg[100], n;\nbool vis[100];\nbool dfs(int u, int dest) {\n    if (u == dest) return true;\n    vis[u] = true;\n    for (int i = 0; i < deg[u]; i++) {\n        int v = adj[u][i];\n        if (!vis[v] && dfs(v, dest)) return true;\n    }\n    return false;\n}\nint main() {\n    int m, u, v, s, d; scanf("%d %d", &n, &m);\n    for (int i = 0; i < m; i++) {\n        scanf("%d %d", &u, &v);\n        adj[u][deg[u]++] = v;\n        adj[v][deg[v]++] = u;\n    }\n    scanf("%d %d", &s, &d);\n    printf("%s\\n", dfs(s, d) ? "true" : "false");\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function validPath(n, edges, source, destination) {\n  const adj = Array.from({ length: n }, () => []);\n  for (const [u, v] of edges) {\n    adj[u].push(v);\n    adj[v].push(u);\n  }\n  const visited = new Set();\n  function dfs(node) {\n    if (node === destination) return true;\n    visited.add(node);\n    for (const nei of adj[node]) {\n      if (!visited.has(nei)) {\n        if (dfs(nei)) return true;\n      }\n    }\n    return false;\n  }\n  return dfs(source);\n}',
      },
      {
        language: 'python',
        code: 'def valid_path(n, edges, source, destination):\n    from collections import defaultdict\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    visited = set()\n    def dfs(node):\n        if node == destination:\n            return True\n        visited.add(node)\n        for nei in adj[node]:\n            if nei not in visited:\n                if dfs(nei):\n                    return True\n        return False\n    return dfs(source)',
      },
      {
        language: 'java',
        code: 'boolean validPath(int n, List<int[]> edges, int source, int destination) {\n    List<List<Integer>> adj = new ArrayList<>();\n    for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\n    for (int[] e : edges) {\n        adj.get(e[0]).add(e[1]);\n        adj.get(e[1]).add(e[0]);\n    }\n    boolean[] vis = new boolean[n];\n    return dfs(source, destination, adj, vis);\n}\nboolean dfs(int u, int dest, List<List<Integer>> adj, boolean[] vis) {\n    if (u == dest) return true;\n    vis[u] = true;\n    for (int v : adj.get(u)) {\n        if (!vis[v] && dfs(v, dest, adj, vis)) return true;\n    }\n    return false;\n}',
      },
      {
        language: 'c++',
        code: 'bool validPath(int n, vector<pair<int, int>> &edges, int source, int destination) {\n    vector<vector<int>> adj(n);\n    for (auto &[u, v] : edges) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    vector<bool> vis(n, false);\n    return dfs(source, destination, adj, vis);\n}\nbool dfs(int u, int dest, vector<vector<int>> &adj, vector<bool> &vis) {\n    if (u == dest) return true;\n    vis[u] = true;\n    for (int v : adj[u]) if (!vis[v] && dfs(v, dest, adj, vis)) return true;\n    return false;\n}',
      },
    ],
  },
  {
    title: 'Clone a Graph',
    slug: 'clone-a-graph',
    description: 'Create a deep copy of a connected undirected graph.',
    problemStatement:
      'You are given a reference to a node in a connected **undirected graph**. Each node contains an integer value and a list of its neighbors.\n\nYour task is to **clone** the graph. Return the **deep copy** (clone) of the given node. The cloned graph should have the same structure and values as the original but must be made up of **new nodes**.\n\nEach node is of the following structure:\n\n<pre><code>class Node {\n  int val;\n  List<Node> neighbors;\n}\n</code></pre>\n\n### Examples:\n\n<pre><code>Input:\n4\n1 2\n2 3\n3 4\n4 1\n\nOutput:\nCloned graph structure matches original.\n</code></pre>\n\n<ul>\n<li>1 ≤ Number of nodes ≤ 100</li>\n<li>Each node has a unique value from 1 to 100.</li>\n<li>The graph is connected.</li>\n</ul>\n\n**Pro Tip:** Use a hash map to track already cloned nodes to avoid infinite recursion and maintain correct references.',
    sampleTestCases: [
      {
        input: '4\n1 2\n2 3\n3 4\n4 1',
        expected: 'Cloned graph structure matches original.',
      },
    ],
    testCases: [
      { input: '1\n1 1', expected: 'Cloned graph structure matches original.' },
      { input: '2\n1 2', expected: 'Cloned graph structure matches original.' },
      {
        input: '3\n1 2\n2 3\n3 1',
        expected: 'Cloned graph structure matches original.',
      },
      {
        input: '4\n1 2\n1 3\n1 4',
        expected: 'Cloned graph structure matches original.',
      },
      {
        input: '5\n1 2\n2 3\n3 4\n4 5\n5 1',
        expected: 'Cloned graph structure matches original.',
      },
      {
        input: '3\n1 2\n2 3',
        expected: 'Cloned graph structure matches original.',
      },
      {
        input: '4\n1 2\n2 3\n3 4',
        expected: 'Cloned graph structure matches original.',
      },
      {
        input: '3\n1 2\n1 3',
        expected: 'Cloned graph structure matches original.',
      },
      {
        input: '6\n1 2\n2 3\n3 4\n4 5\n5 6\n6 1',
        expected: 'Cloned graph structure matches original.',
      },
      {
        input: '2\n1 1\n1 2',
        expected: 'Cloned graph structure matches original.',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re given a node in an undirected graph and need to make a deep copy of the graph. Can you recursively or iteratively clone the entire structure?',
    difficulty: 'medium',
    frequency: 85,
    tags: ['graph', 'dfs', 'hashmap', 'bfs', 'clone'],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use a hash map to map original nodes to their clones.',
      'DFS or BFS works well for visiting and cloning nodes recursively or iteratively.',
    ],
    optimalComplexity: {
      time: 'O(n + e)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "class Node {\n  constructor(val, neighbors = []) {\n    this.val = val;\n    this.neighbors = neighbors;\n  }\n}\n\nconst fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const nodes = {};\n  for (let i = 1; i <= n; i++) nodes[i] = new Node(i);\n  for (let i = 1; i < input.length; i++) {\n    const [u, v] = input[i].split(' ').map(Number);\n    nodes[u].neighbors.push(nodes[v]);\n    nodes[v].neighbors.push(nodes[u]);\n  }\n  const cloned = cloneGraph(nodes[1]);\n  console.log(\"Cloned graph structure matches original.\");\n}\nmain();",
      },
      {
        language: 'python',
        code: "class Node:\n    def __init__(self, val, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\nif __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    nodes = {i: Node(i) for i in range(1, n + 1)}\n    for line in input_lines[1:]:\n        u, v = map(int, line.split())\n        nodes[u].neighbors.append(nodes[v])\n        nodes[v].neighbors.append(nodes[u])\n    clone = clone_graph(nodes[1])\n    print(\"Cloned graph structure matches original.\")",
      },
      {
        language: 'c++',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nclass Node {\npublic:\n    int val;\n    vector<Node*> neighbors;\n    Node(int _val) { val = _val; }\n};\nNode* cloneGraph(Node* node);\nint main() {\n    int n; cin >> n;\n    unordered_map<int, Node*> nodes;\n    for (int i = 1; i <= n; ++i) nodes[i] = new Node(i);\n    for (int i = 0; i < n; ++i) {\n        int u, v; cin >> u >> v;\n        nodes[u]->neighbors.push_back(nodes[v]);\n        nodes[v]->neighbors.push_back(nodes[u]);\n    }\n    Node* cloned = cloneGraph(nodes[1]);\n    cout << "Cloned graph structure matches original." << endl;\n    return 0;\n}',
      },
      {
        language: 'java',
        code: 'import java.util.*;\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node(int val) {\n        this.val = val;\n        this.neighbors = new ArrayList<>();\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        Map<Integer, Node> map = new HashMap<>();\n        for (int i = 1; i <= n; i++) map.put(i, new Node(i));\n        for (int i = 0; i < n; i++) {\n            int u = sc.nextInt(), v = sc.nextInt();\n            map.get(u).neighbors.add(map.get(v));\n            map.get(v).neighbors.add(map.get(u));\n        }\n        Node clone = cloneGraph(map.get(1));\n        System.out.println("Cloned graph structure matches original.");\n    }\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function cloneGraph(node) {\n  // implement deep copy using DFS\n}',
      },
      {
        language: 'python',
        code: 'def clone_graph(node):\n    # implement deep copy using DFS\n    pass',
      },
      {
        language: 'java',
        code: 'Node cloneGraph(Node node) {\n    // implement deep copy using DFS or BFS\n    return null;\n}',
      },
      {
        language: 'c++',
        code: 'Node* cloneGraph(Node* node) {\n    // implement deep copy using DFS or BFS\n    return nullptr;\n}',
      },
    ],
  },
  {
    title: 'Topological Sort (Kahn’s Algorithm - BFS)',
    slug: 'topological-sort-kahns-algorithm-bfs',
    description:
      "Perform a topological sort of a directed graph using Kahn's algorithm (BFS-based approach).",
    problemStatement:
      'You are given a **directed graph** with `n` nodes labeled from `0` to `n - 1` and a list of directed `edges`. Your task is to return a **topological ordering** of the nodes using **Kahn’s Algorithm** (BFS).\n\nIf the graph is not a **DAG** (i.e., has a cycle), return an empty list.\n\n### Examples:\n\n<pre><code>Input:\nn = 4\nedges = [[0, 1], [0, 2], [1, 2], [2, 3]]\n\nOutput:\n[0, 1, 2, 3]\n</code></pre>\n\n<pre><code>Input:\nn = 3\nedges = [[0, 1], [1, 2], [2, 0]]\n\nOutput:\n[]\n</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 100</li>\n<li>0 ≤ edges.length ≤ n * (n - 1)</li>\n<li>0 ≤ u, v < n</li>\n</ul>\n\n**Pro Tip:** Maintain an in-degree array and a queue. Nodes with 0 in-degree can be visited and removed iteratively.',
    sampleTestCases: [
      {
        input: '4\n4\n0 1\n0 2\n1 2\n2 3',
        expected: '0 1 2 3',
      },
      {
        input: '3\n3\n0 1\n1 2\n2 0',
        expected: '',
      },
    ],
    testCases: [
      { input: '2\n1\n0 1', expected: '0 1' },
      { input: '2\n1\n1 0', expected: '1 0' },
      { input: '3\n2\n0 1\n1 2', expected: '0 1 2' },
      { input: '3\n3\n0 1\n1 2\n2 0', expected: '' },
      { input: '4\n2\n0 1\n2 3', expected: '0 1 2 3' },
      { input: '5\n4\n0 1\n1 2\n3 4\n2 3', expected: '0 1 2 3 4' },
      { input: '5\n5\n0 1\n1 2\n2 3\n3 4\n4 0', expected: '' },
      { input: '6\n5\n5 2\n5 0\n4 0\n4 1\n2 3', expected: '4 5 0 2 1 3' },
      { input: '1\n0\n', expected: '0' },
      { input: '3\n0\n', expected: '0 1 2' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're building a compiler and need to sort build dependencies. Implement a topological sort using Kahn’s algorithm.",
    difficulty: 'medium',
    frequency: 81,
    tags: ['graph', 'bfs', 'topological sort', 'dag'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Track in-degrees for each node.',
      'Use a queue to process all nodes with 0 in-degree.',
      'If the number of processed nodes is less than total nodes, a cycle exists.',
    ],
    optimalComplexity: {
      time: 'O(n + e)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const m = parseInt(input[1]);\n  const edges = [];\n  for (let i = 0; i < m; i++) {\n    edges.push(input[2 + i].split(' ').map(Number));\n  }\n  const res = topoSort(n, edges);\n  console.log(res.join(' '));\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    m = int(input_lines[1])\n    edges = [tuple(map(int, line.split())) for line in input_lines[2:2 + m]]\n    result = topo_sort(n, edges)\n    print(' '.join(map(str, result)))",
      },
      {
        language: 'c++',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int n, m; cin >> n >> m;\n    vector<vector<int>> adj(n);\n    vector<int> indeg(n, 0);\n    for (int i = 0; i < m; i++) {\n        int u, v; cin >> u >> v;\n        adj[u].push_back(v);\n        indeg[v]++;\n    }\n    queue<int> q;\n    for (int i = 0; i < n; i++) if (indeg[i] == 0) q.push(i);\n    vector<int> res;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        res.push_back(u);\n        for (int v : adj[u]) if (--indeg[v] == 0) q.push(v);\n    }\n    if (res.size() != n) cout << "";\n    else for (int v : res) cout << v << " ";\n    cout << endl;\n    return 0;\n}',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\n        int[] indeg = new int[n];\n        for (int i = 0; i < m; i++) {\n            int u = sc.nextInt(), v = sc.nextInt();\n            adj.get(u).add(v);\n            indeg[v]++;\n        }\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < n; i++) if (indeg[i] == 0) q.add(i);\n        List<Integer> res = new ArrayList<>();\n        while (!q.isEmpty()) {\n            int u = q.poll();\n            res.add(u);\n            for (int v : adj.get(u)) if (--indeg[v] == 0) q.add(v);\n        }\n        if (res.size() != n) System.out.println();\n        else System.out.println(res.stream().map(String::valueOf).collect(Collectors.joining(" ")));\n    }\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function topoSort(n, edges) {\n  // implement Kahn’s algorithm\n}',
      },
      {
        language: 'python',
        code: 'def topo_sort(n, edges):\n    # implement Kahn’s algorithm\n    pass',
      },
      {
        language: 'java',
        code: 'List<Integer> topoSort(int n, List<int[]> edges) {\n    // implement Kahn’s algorithm\n    return new ArrayList<>();\n}',
      },
      {
        language: 'c++',
        code: 'vector<int> topoSort(int n, vector<pair<int, int>> &edges) {\n    // implement Kahn’s algorithm\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Topological Sort (DFS-Based)',
    slug: 'topological-sort-dfs-based',
    description:
      'Perform a topological sort of a directed graph using DFS-based approach.',
    problemStatement:
      'You are given a **directed graph** with `n` nodes labeled from `0` to `n - 1` and a list of directed `edges`. Your task is to return a **topological ordering** of the nodes using **DFS-based** approach.\n\nIf the graph is not a **DAG** (i.e., has a cycle), return an empty list.\n\n### Examples:\n\n<pre><code>Input:\nn = 4\nedges = [[0, 1], [1, 2], [2, 3]]\n\nOutput:\n[0, 1, 2, 3]\n</code></pre>\n\n<pre><code>Input:\nn = 3\nedges = [[0, 1], [1, 2], [2, 0]]\n\nOutput:\n[]\n</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 100</li>\n<li>0 ≤ edges.length ≤ n * (n - 1)</li>\n<li>0 ≤ u, v < n</li>\n</ul>\n\n**Pro Tip:** Use a visited array with a recursion stack to detect cycles while performing DFS.',
    sampleTestCases: [
      {
        input: '4\n3\n0 1\n1 2\n2 3',
        expected: '0 1 2 3',
      },
      {
        input: '3\n3\n0 1\n1 2\n2 0',
        expected: '',
      },
    ],
    testCases: [
      { input: '2\n1\n0 1', expected: '0 1' },
      { input: '3\n2\n1 0\n2 1', expected: '2 1 0' },
      { input: '4\n4\n0 1\n1 2\n2 3\n3 0', expected: '' },
      { input: '4\n2\n0 1\n2 3', expected: '2 3 0 1' },
      { input: '5\n4\n0 1\n1 2\n2 3\n3 4', expected: '0 1 2 3 4' },
      { input: '3\n0\n', expected: '0 1 2' },
      { input: '1\n0\n', expected: '0' },
      { input: '4\n4\n0 1\n1 2\n2 0\n3 2', expected: '' },
      { input: '5\n3\n1 0\n2 0\n3 1', expected: '4 3 2 1 0' },
      { input: '6\n5\n5 2\n5 0\n4 0\n4 1\n2 3', expected: '5 2 3 4 1 0' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're developing a course schedule. Implement a DFS-based topological sort to find a valid order of course completion.",
    difficulty: 'medium',
    frequency: 78,
    tags: ['graph', 'dfs', 'topological sort', 'dag'],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use a visited array and a recursion stack to detect cycles.',
      'Use post-order DFS to build the topological sort.',
      'If a cycle is detected, return an empty result.',
    ],
    optimalComplexity: {
      time: 'O(n + e)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const m = parseInt(input[1]);\n  const edges = [];\n  for (let i = 0; i < m; i++) {\n    edges.push(input[2 + i].split(' ').map(Number));\n  }\n  const res = topoSort(n, edges);\n  console.log(res.join(' '));\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    m = int(input_lines[1])\n    edges = [tuple(map(int, line.split())) for line in input_lines[2:2 + m]]\n    result = topo_sort(n, edges)\n    print(' '.join(map(str, result)))",
      },
      {
        language: 'c++',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nbool dfs(int u, vector<vector<int>> &adj, vector<bool> &vis, vector<bool> &rec, vector<int> &res) {\n    vis[u] = rec[u] = true;\n    for (int v : adj[u]) {\n        if (rec[v]) return false;\n        if (!vis[v] && !dfs(v, adj, vis, rec, res)) return false;\n    }\n    rec[u] = false;\n    res.push_back(u);\n    return true;\n}\nint main() {\n    int n, m; cin >> n >> m;\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < m; i++) {\n        int u, v; cin >> u >> v;\n        adj[u].push_back(v);\n    }\n    vector<bool> vis(n, false), rec(n, false);\n    vector<int> res;\n    for (int i = 0; i < n; i++) if (!vis[i] && !dfs(i, adj, vis, rec, res)) {\n        cout << "" << endl;\n        return 0;\n    }\n    reverse(res.begin(), res.end());\n    for (int x : res) cout << x << " ";\n    cout << endl;\n    return 0;\n}',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    static boolean dfs(int u, List<List<Integer>> adj, boolean[] vis, boolean[] rec, List<Integer> res) {\n        vis[u] = rec[u] = true;\n        for (int v : adj.get(u)) {\n            if (rec[v]) return false;\n            if (!vis[v] && !dfs(v, adj, vis, rec, res)) return false;\n        }\n        rec[u] = false;\n        res.add(u);\n        return true;\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt();\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\n        for (int i = 0; i < m; i++) adj.get(sc.nextInt()).add(sc.nextInt());\n        boolean[] vis = new boolean[n], rec = new boolean[n];\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < n; i++) if (!vis[i] && !dfs(i, adj, vis, rec, res)) {\n            System.out.println();\n            return;\n        }\n        Collections.reverse(res);\n        for (int x : res) System.out.print(x + " ");\n    }\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function topoSort(n, edges) {\n  // implement DFS-based topological sort\n}',
      },
      {
        language: 'python',
        code: 'def topo_sort(n, edges):\n    # implement DFS-based topological sort\n    pass',
      },
      {
        language: 'java',
        code: 'List<Integer> topoSort(int n, List<int[]> edges) {\n    // implement DFS-based topological sort\n    return new ArrayList<>();\n}',
      },
      {
        language: 'c++',
        code: 'vector<int> topoSort(int n, vector<pair<int, int>> &edges) {\n    // implement DFS-based topological sort\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Detect Cycle in Directed Graph Using Topological Sort',
    slug: 'detect-cycle-directed-graph-topo-sort',
    description:
      'Determine if a directed graph contains a cycle by attempting a topological sort (Kahn’s Algorithm).',
    problemStatement:
      "You're given a **directed graph** with `n` nodes labeled from `0` to `n - 1` and a list of directed `edges`. Your goal is to **detect if the graph has a cycle**. Use **Kahn’s Algorithm** (i.e., a BFS-based topological approach) to decide.\n\nIf the graph contains a cycle, return `true`; otherwise, return `false`.\n\n### Examples:\n\n<pre><code>Input:\nn = 4\nedges = [[0, 1], [1, 2], [2, 3]]\n\nOutput:\nfalse\n</code></pre>\n\n<pre><code>Input:\nn = 3\nedges = [[0, 1], [1, 2], [2, 0]]\n\nOutput:\ntrue\n</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 100</li>\n<li>0 ≤ edges.length ≤ n × (n - 1)</li>\n<li>0 ≤ u, v < n</li>\n</ul>\n\n**Pro Tip:** Try to perform topological sorting. If you can't process all nodes, a cycle must exist.",
    sampleTestCases: [
      {
        input: '4\n3\n0 1\n1 2\n2 3',
        expected: 'false',
      },
      {
        input: '3\n3\n0 1\n1 2\n2 0',
        expected: 'true',
      },
    ],
    testCases: [
      { input: '2\n1\n0 1', expected: 'false' },
      { input: '3\n3\n0 2\n2 1\n1 0', expected: 'true' },
      { input: '4\n4\n0 1\n1 2\n2 3\n3 0', expected: 'true' },
      { input: '4\n2\n0 1\n2 3', expected: 'false' },
      { input: '5\n4\n0 1\n1 2\n1 3\n3 4', expected: 'false' },
      { input: '5\n5\n0 1\n1 2\n2 3\n3 4\n4 1', expected: 'true' },
      { input: '6\n6\n0 1\n1 2\n2 3\n3 4\n4 5\n5 3', expected: 'true' },
      { input: '1\n0\n', expected: 'false' },
      { input: '3\n0\n', expected: 'false' },
      { input: '3\n2\n0 1\n1 2', expected: 'false' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'In dependency resolution systems, detecting cycles helps avoid infinite loops. Implement cycle detection for directed graphs using topological sort.',
    difficulty: 'medium',
    frequency: 79,
    tags: ['graph', 'cycle detection', 'topological sort', 'kahn', 'bfs'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Compute in-degrees of all nodes.',
      'Use a queue to process nodes with zero in-degree.',
      "If you can't process all nodes, a cycle exists.",
    ],
    optimalComplexity: {
      time: 'O(n + e)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf‑8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const m = parseInt(input[1]);\n  const edges = [];\n  for (let i = 0; i < m; i++) edges.push(input[2 + i].split(' ').map(Number));\n  console.log(hasCycle(n, edges).toString());\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    input_lines = sys.stdin.read().strip().split('\\n')\n    n = int(input_lines[0])\n    m = int(input_lines[1])\n    edges = [tuple(map(int, line.split())) for line in input_lines[2:2 + m]]\n    print(str(has_cycle(n, edges)).lower())",
      },
      {
        language: 'c++',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int n, m; cin >> n >> m;\n    vector<vector<int>> adj(n);\n    vector<int> indeg(n, 0);\n    for (int i = 0; i < m; i++) {\n        int u, v; cin >> u >> v;\n        adj[u].push_back(v);\n        indeg[v]++;\n    }\n    queue<int> q;\n    for (int i = 0; i < n; i++) if (indeg[i] == 0) q.push(i);\n    int count = 0;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        count++;\n        for (int v : adj[u]) if (--indeg[v] == 0) q.push(v);\n    }\n    cout << (count != n ? "true" : "false");\n    return 0;\n}',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt();\n        List<List<Integer>> adj = new ArrayList<>();\n        int[] indeg = new int[n];\n        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\n        for (int i = 0; i < m; i++) {\n            int u = sc.nextInt(), v = sc.nextInt();\n            adj.get(u).add(v);\n            indeg[v]++;\n        }\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < n; i++) if (indeg[i] == 0) q.add(i);\n        int count = 0;\n        while (!q.isEmpty()) {\n            int u = q.poll();\n            count++;\n            for (int v : adj.get(u)) if (--indeg[v] == 0) q.add(v);\n        }\n        System.out.println(count != n);\n    }\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function hasCycle(n, edges) {\n  // implement using Kahn’s topological sort\n}',
      },
      {
        language: 'python',
        code: 'def has_cycle(n, edges):\n    # implement using topological sort\n    pass',
      },
      {
        language: 'java',
        code: 'boolean hasCycle(int n, List<int[]> edges) {\n    // implement using topological sort\n    return false;\n}',
      },
      {
        language: 'c++',
        code: 'bool hasCycle(int n, vector<pair<int,int>>& edges) {\n    // implement using topological sort\n    return false;\n}',
      },
    ],
  },
  {
    title: 'All Topological Sorts of a DAG',
    slug: 'all-topological-sorts-of-a-dag',
    description:
      'Generate all possible topological orderings of a Directed Acyclic Graph (DAG).',
    problemStatement:
      'You are given a **directed acyclic graph (DAG)** with `n` nodes labeled from `0` to `n - 1` and a list of directed `edges`. Your task is to **generate all possible topological sorts** (linear orderings) of the DAG. Return a list of lists, where each inner list is a valid topological ordering.\n\n### Example:\n\n<pre><code>Input:\nn = 6\nedges = [[5, 2], [5, 0], [4, 0], [4, 1], [2, 3], [3, 1]]\n\nPossible Outputs:\n[\n  [4, 5, 2, 3, 1, 0],\n  [5, 4, 2, 3, 1, 0],\n  [5, 4, 2, 0, 3, 1],\n  ...\n]\n</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 100</li>\n<li>0 ≤ edges.length ≤ n*(n-1)</li>\n<li>0 ≤ u, v < n; the graph is guaranteed to be acyclic.</li>\n</ul>\n\n**Pro Tip:** Use backtracking with an indegree array. At each step, pick any node with indegree 0, append it to the current ordering, reduce indegrees of neighbors, recurse, then backtrack (restore state). This explores all valid orders. :contentReference[oaicite:1]{index=1}',
    sampleTestCases: [
      {
        input: '6\n6\n5 2\n5 0\n4 0\n4 1\n2 3\n3 1',
        expected:
          'All valid topological orders (e.g., [4,5,2,3,1,0], [5,4,2,3,1,0], ...]',
      },
    ],
    testCases: [
      { input: '3\n2\n0 1\n1 2', expected: '[[0,1,2]]' },
      {
        input: '3\n0\n',
        expected: '[[0,1,2],[0,2,1],[1,0,2],[1,2,0],[2,0,1],[2,1,0]]',
      },
      { input: '4\n3\n0 1\n0 2\n1 3', expected: 'Multiple valid orders' },
      { input: '4\n4\n0 1\n0 2\n2 3\n1 3', expected: '[[0,1,2,3],[0,2,1,3]]' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re designing a build system that needs to explore all possible orders of building modules in a DAG of dependencies. Generate all valid topological orders.',
    difficulty: 'hard',
    frequency: 40,
    tags: ['graph', 'topological sort', 'backtracking', 'dag', 'counting'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Maintain an indegree array for each node.',
      'At each recursive step, consider all unvisited nodes with indegree 0.',
      'Use backtracking: after recursion, restore indegrees and visited flags.',
    ],
    optimalComplexity: {
      time: 'O(k * (n + e)) where k is number of topological orders',
      space: 'O(n + e + k * n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const m = parseInt(input[1]);\n  const edges = input.slice(2, 2 + m).map(line => line.split(' ').map(Number));\n  const all = allTopologicalSorts(n, edges);\n  all.forEach(order => console.log(order.join(' ')));\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0]); m = int(lines[1])\n    edges = [tuple(map(int, line.split())) for line in lines[2:2+m]]\n    result = all_topo_sorts(n, edges)\n    for order in result:\n        print(' '.join(map(str, order)))",
      },
      {
        language: 'c++',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nint main() {int n,m;cin>>n>>m;vector<vector<int>> adj(n);\nvector<int> indeg(n,0);\nfor(int i=0,u,v;i<m;i++){cin>>u>>v;adj[u].push_back(v);indeg[v]++;}\nvector<int> res,visited(n,0);\nfunction<void()> dfs=[&]{\n    bool flag=false;\n    for(int i=0;i<n;i++) if(!visited[i] && indeg[i]==0){\n        for(int nb: adj[i]) indeg[nb]--;\n        res.push_back(i); visited[i]=1;\n        dfs();\n        visited[i]=0; res.pop_back();\n        for(int nb: adj[i]) indeg[nb]++;\n        flag=true;\n    }\n    if(!flag){ for(int x: res) cout<<x<<" "; cout<<"\\n"; }\n};dfs();}\n',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt(), m = sc.nextInt();\n    List<List<Integer>> adj = new ArrayList<>();\n    for(int i=0;i<n;i++) adj.add(new ArrayList<>());\n    int[] indeg = new int[n];\n    for(int i=0;i<m;i++){int u=sc.nextInt(), v=sc.nextInt(); adj.get(u).add(v); indeg[v]++;}\n    List<Integer> res = new ArrayList<>(); boolean[] visited = new boolean[n];\n    generate(adj, indeg, visited, res);\n  }\n\n  static void generate(List<List<Integer>> adj, int[] indeg, boolean[] visited, List<Integer> res) {\n    boolean flag = false;\n    for(int i=0;i<indeg.length;i++) if(!visited[i] && indeg[i] == 0) {\n      visited[i] = true;\n      for(int nb: adj.get(i)) indeg[nb]--;\n      res.add(i);\n      generate(adj, indeg, visited, res);\n      visited[i] = false;\n      res.remove(res.size()-1);\n      for(int nb: adj.get(i)) indeg[nb]++;\n      flag = true;\n    }\n    if(!flag) {\n      System.out.println(res);\n    }\n  }\n}',
      },
      {
        language: 'c',
        code: '// For brevity, C version omitted; use recursive backtracking with arrays and indegree tracking.',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function allTopologicalSorts(n, edges) {\n  // implement backtracking using indegree + visited\n}',
      },
      {
        language: 'python',
        code: 'def all_topo_sorts(n, edges):\n    # implement backtracking to generate all topological orders\n    pass',
      },
      {
        language: 'java',
        code: 'List<List<Integer>> allTopoSorts(int n, List<int[]> edges) {\n    // implement backtracking\n    return new ArrayList<>();\n}',
      },
      {
        language: 'c++',
        code: 'vector<vector<int>> allTopoSorts(int n, vector<pair<int,int>>& edges) {\n    // implement backtracking\n    return {};\n}',
      },
    ],
  },
  {
    title: 'All Topological Sorts of a DAG',
    slug: 'all-topological-sorts-of-a-dag',
    description:
      'Generate all possible topological orderings of a Directed Acyclic Graph (DAG).',
    problemStatement:
      'You are given a **directed acyclic graph (DAG)** with `n` nodes labeled from `0` to `n - 1` and a list of directed `edges`. Your task is to **generate all possible topological sorts** (linear orderings) of the DAG. Return a list of lists, where each inner list is a valid topological ordering.\n\n### Example:\n\n<pre><code>Input:\nn = 6\nedges = [[5, 2], [5, 0], [4, 0], [4, 1], [2, 3], [3, 1]]\n\nPossible Outputs:\n[\n  [4, 5, 2, 3, 1, 0],\n  [5, 4, 2, 3, 1, 0],\n  [5, 4, 2, 0, 3, 1],\n  ...\n]\n</code></pre>\n\n<ul>\n<li>1 ≤ n ≤ 100</li>\n<li>0 ≤ edges.length ≤ n*(n-1)</li>\n<li>0 ≤ u, v < n; the graph is guaranteed to be acyclic.</li>\n</ul>\n\n**Pro Tip:** Use backtracking with an indegree array. At each step, pick any node with indegree 0, append it to the current ordering, reduce indegrees of neighbors, recurse, then backtrack (restore state). This explores all valid orders. :contentReference[oaicite:1]{index=1}',
    sampleTestCases: [
      {
        input: '6\n6\n5 2\n5 0\n4 0\n4 1\n2 3\n3 1',
        expected:
          'All valid topological orders (e.g., [4,5,2,3,1,0], [5,4,2,3,1,0], ...]',
      },
    ],
    testCases: [
      { input: '3\n2\n0 1\n1 2', expected: '[[0,1,2]]' },
      {
        input: '3\n0\n',
        expected: '[[0,1,2],[0,2,1],[1,0,2],[1,2,0],[2,0,1],[2,1,0]]',
      },
      { input: '4\n3\n0 1\n0 2\n1 3', expected: 'Multiple valid orders' },
      { input: '4\n4\n0 1\n0 2\n2 3\n1 3', expected: '[[0,1,2,3],[0,2,1,3]]' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re designing a build system that needs to explore all possible orders of building modules in a DAG of dependencies. Generate all valid topological orders.',
    difficulty: 'hard',
    frequency: 40,
    tags: ['graph', 'topological sort', 'backtracking', 'dag', 'counting'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Maintain an indegree array for each node.',
      'At each recursive step, consider all unvisited nodes with indegree 0.',
      'Use backtracking: after recursion, restore indegrees and visited flags.',
    ],
    optimalComplexity: {
      time: 'O(k * (n + e)) where k is number of topological orders',
      space: 'O(n + e + k * n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf8').trim().split('\\n');\n  const n = parseInt(input[0]);\n  const m = parseInt(input[1]);\n  const edges = input.slice(2, 2 + m).map(line => line.split(' ').map(Number));\n  const all = allTopologicalSorts(n, edges);\n  all.forEach(order => console.log(order.join(' ')));\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    n = int(lines[0]); m = int(lines[1])\n    edges = [tuple(map(int, line.split())) for line in lines[2:2+m]]\n    result = all_topo_sorts(n, edges)\n    for order in result:\n        print(' '.join(map(str, order)))",
      },
      {
        language: 'c++',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nint main() {int n,m;cin>>n>>m;vector<vector<int>> adj(n);\nvector<int> indeg(n,0);\nfor(int i=0,u,v;i<m;i++){cin>>u>>v;adj[u].push_back(v);indeg[v]++;}\nvector<int> res,visited(n,0);\nfunction<void()> dfs=[&]{\n    bool flag=false;\n    for(int i=0;i<n;i++) if(!visited[i] && indeg[i]==0){\n        for(int nb: adj[i]) indeg[nb]--;\n        res.push_back(i); visited[i]=1;\n        dfs();\n        visited[i]=0; res.pop_back();\n        for(int nb: adj[i]) indeg[nb]++;\n        flag=true;\n    }\n    if(!flag){ for(int x: res) cout<<x<<" "; cout<<"\\n"; }\n};dfs();}\n',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt(), m = sc.nextInt();\n    List<List<Integer>> adj = new ArrayList<>();\n    for(int i=0;i<n;i++) adj.add(new ArrayList<>());\n    int[] indeg = new int[n];\n    for(int i=0;i<m;i++){int u=sc.nextInt(), v=sc.nextInt(); adj.get(u).add(v); indeg[v]++;}\n    List<Integer> res = new ArrayList<>(); boolean[] visited = new boolean[n];\n    generate(adj, indeg, visited, res);\n  }\n\n  static void generate(List<List<Integer>> adj, int[] indeg, boolean[] visited, List<Integer> res) {\n    boolean flag = false;\n    for(int i=0;i<indeg.length;i++) if(!visited[i] && indeg[i] == 0) {\n      visited[i] = true;\n      for(int nb: adj.get(i)) indeg[nb]--;\n      res.add(i);\n      generate(adj, indeg, visited, res);\n      visited[i] = false;\n      res.remove(res.size()-1);\n      for(int nb: adj.get(i)) indeg[nb]++;\n      flag = true;\n    }\n    if(!flag) {\n      System.out.println(res);\n    }\n  }\n}',
      },
      {
        language: 'c',
        code: '// For brevity, C version omitted; use recursive backtracking with arrays and indegree tracking.',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function allTopologicalSorts(n, edges) {\n  // implement backtracking using indegree + visited\n}',
      },
      {
        language: 'python',
        code: 'def all_topo_sorts(n, edges):\n    # implement backtracking to generate all topological orders\n    pass',
      },
      {
        language: 'java',
        code: 'List<List<Integer>> allTopoSorts(int n, List<int[]> edges) {\n    // implement backtracking\n    return new ArrayList<>();\n}',
      },
      {
        language: 'c++',
        code: 'vector<vector<int>> allTopoSorts(int n, vector<pair<int,int>>& edges) {\n    // implement backtracking\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Course Schedule I',
    slug: 'course-schedule-i',
    description:
      'Determine if it is possible to finish all courses given prerequisite pairs using cycle detection in a directed graph.',
    problemStatement:
      "You're given `numCourses` labeled from `0` to `numCourses - 1`, and a list of prerequisites where `prerequisites[i] = [a, b]` means you must take course `b` before course `a`. Return `true` if you can finish all courses, or `false` if there's a cycle.\n\n### Example:\n\n<pre><code>Input:\nnumCourses = 2\nprerequisites = [[1, 0]]\n\nOutput:\ntrue\n</code></pre>\n\n<pre><code>Input:\nnumCourses = 2\nprerequisites = [[1, 0], [0, 1]]\n\nOutput:\nfalse\n</code></pre>\n\n<ul>\n<li>1 ≤ numCourses ≤ 2000</li>\n<li>0 ≤ prerequisites.length ≤ 5000</li>\n<li>prerequisites[i].length == 2</li>\n<li>0 ≤ a, b < numCourses</li>\n</ul>\n\n**Pro Tip:** Use DFS with a recursion stack or Kahn's Algorithm (BFS) for cycle detection in a directed graph.",
    sampleTestCases: [
      {
        input: '2\n1\n1 0',
        expected: 'true',
      },
      {
        input: '2\n2\n1 0\n0 1',
        expected: 'false',
      },
    ],
    testCases: [
      { input: '1\n0', expected: 'true' },
      { input: '2\n1\n0 1', expected: 'true' },
      { input: '3\n3\n0 1\n1 2\n2 0', expected: 'false' },
      { input: '4\n4\n0 1\n1 2\n2 3\n3 0', expected: 'false' },
      { input: '5\n4\n0 1\n1 2\n2 3\n3 4', expected: 'true' },
      { input: '3\n2\n1 0\n2 1', expected: 'true' },
      { input: '3\n3\n0 1\n1 2\n2 1', expected: 'false' },
      { input: '4\n3\n1 0\n2 1\n3 2', expected: 'true' },
      { input: '4\n4\n0 1\n1 2\n2 3\n3 1', expected: 'false' },
      { input: '6\n6\n1 0\n2 1\n3 2\n4 3\n5 4\n0 5', expected: 'false' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're scheduling university courses, and some courses depend on others. Can you complete all courses given these dependencies?",
    difficulty: 'medium',
    frequency: 90,
    tags: ['graph', 'cycle detection', 'dfs', 'topological sort'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use DFS to detect cycles via recursion stack.',
      "A cycle in prerequisites means courses can't be completed.",
    ],
    optimalComplexity: {
      time: 'O(n + e)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = fs.readFileSync(0, 'utf8').trim().split('\\n');\n  const numCourses = parseInt(input[0]);\n  const m = parseInt(input[1]);\n  const prerequisites = input.slice(2).map(line => line.split(' ').map(Number));\n  console.log(canFinish(numCourses, prerequisites));\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    numCourses = int(lines[0])\n    m = int(lines[1])\n    prerequisites = [tuple(map(int, l.split())) for l in lines[2:2+m]]\n    print(can_finish(numCourses, prerequisites))",
      },
      {
        language: 'c++',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nbool canFinish(int, vector<vector<int>>&);\nint main() {\n    int n, m; cin >> n >> m;\n    vector<vector<int>> prerequisites(m);\n    for (int i = 0; i < m; i++) {\n        int a, b; cin >> a >> b;\n        prerequisites[i] = {a, b};\n    }\n    cout << (canFinish(n, prerequisites) ? "true" : "false") << endl;\n    return 0;\n}',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int numCourses = sc.nextInt();\n    int m = sc.nextInt();\n    List<int[]> prerequisites = new ArrayList<>();\n    for(int i = 0; i < m; i++) prerequisites.add(new int[]{sc.nextInt(), sc.nextInt()});\n    System.out.println(canFinish(numCourses, prerequisites));\n  }\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function canFinish(numCourses, prerequisites) {\n  // Implement DFS cycle detection\n}',
      },
      {
        language: 'python',
        code: 'def can_finish(num_courses, prerequisites):\n    # Implement DFS cycle detection\n    pass',
      },
      {
        language: 'java',
        code: 'public static boolean canFinish(int numCourses, List<int[]> prerequisites) {\n    // Implement DFS or Kahn’s algorithm\n    return false;\n}',
      },
      {
        language: 'c++',
        code: 'bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n    // Implement DFS or Kahn’s algorithm\n    return false;\n}',
      },
    ],
  },
  {
    title: 'Alien Dictionary',
    slug: 'alien-dictionary',
    description:
      'Determine the order of characters in an alien language from a sorted lexicon.',
    problemStatement:
      'You are given a list of words sorted according to the unknown lexicographical order of an alien language. Determine and return a possible order of the characters in that language. If no valid order exists (due to contradictions or cycles), return an empty string.\n\n### Example:\n<pre><code>Input:\nwords = ["wrt","wrf","er","ett","rftt"]\nOutput:\n"wertf"\n</code></pre>\n\n### Constraints:\n<ul>\n<li>1 ≤ words.length ≤ 100</li>\n<li>1 ≤ words[i].length ≤ 100</li>\n<li>All characters are lowercase English letters.</li>\n</ul>\n**Note:** You may assume the input forms a DAG if valid; any prefix conflicts or cycles should return an empty string.',
    sampleTestCases: [
      {
        input: '["wrt","wrf","er","ett","rftt"]',
        expected: '"wertf"',
      },
      {
        input: '["z","x","z"]',
        expected: '""',
      },
    ],
    testCases: [
      {
        input: '["abc","ab"]',
        expected: '""',
      },
      {
        input: '["z","x"]',
        expected: '"zx" or "xz" (any order with both chars, consistent)',
      },
      {
        input: '["baa","abcd","abca","cab","cad"]',
        expected: '"bdac"',
      },
    ],
    topics: ['graph', 'topological sort', 'dfs', 'bfs'],
    interviewExcerpt:
      'You’ve discovered an alien dictionary sorted in their language. Derive the alphabet order based on that sorting using graph and topological sort.',
    difficulty: 'hard',
    frequency: 75,
    tags: ['graph', 'alien-dictionary', 'topological sort', 'dfs', 'bfs'],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Build graph of precedence between characters by comparing adjacent words.',
      'Watch for invalid prefix cases (e.g., word1 longer than word2 but word2 is prefix).',
      'Use DFS or Kahn’s algorithm for topological sort and cycle detection.',
    ],
    optimalComplexity: {
      time: 'O(C + N), where C is total characters, N is total edges/comparisons',
      space: 'O(C + N)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: 'GPT-Generated',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const words = JSON.parse(fs.readFileSync(0, 'utf8'));\n  console.log(alienOrder(words));\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys, json\n    words = json.loads(sys.stdin.read())\n    print(alien_order(words))",
      },
      {
        language: 'c++',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    vector<string> words;\n    string input; getline(cin, input);\n    // parse JSON-like input or assume words provided accordingly\n    // Then call alienOrder and print result\n    return 0;\n}',
      },
      {
        language: 'java',
        code: 'public class Main {\n  public static void main(String[] args) {\n    // Read JSON array of strings into List<String> words\n    // Call alienOrder(words)\n  }\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: "function alienOrder(words) {\n  // Build adjacency list + in-degree\n  // Perform Kahn's BFS or DFS-based topo sort\n}",
      },
      {
        language: 'python',
        code: 'def alien_order(words):\n    # Build graph and perform topological sort\n    pass',
      },
      {
        language: 'java',
        code: 'String alienOrder(List<String> words) {\n    // Build graph and return topological order or ""\n    return "";\n}',
      },
      {
        language: 'c++',
        code: 'string alienOrder(vector<string>& words) {\n    // Implement graph + topo sort\n    return "";\n}',
      },
    ],
  },
  {
    title: 'Minimum Time to Finish All Jobs Given Dependencies',
    slug: 'minimum-time-to-finish-all-jobs-dependencies',
    description:
      'Given job durations and prerequisite relationships, compute the minimum time (makespan) required to complete all jobs using parallel execution where possible.',
    problemStatement:
      'You are given:\n- `n` jobs labeled `0` to `n-1`, where `time[i]` is the duration of job `i`.\n- A list of prerequisite pairs `prerequisites`, where `[u, v]` means job `u` depends on job `v` (i.e., `v` must finish before `u` starts).\n- A number `k` representing how many jobs can run **in parallel** at any time (e.g., number of machines).\n\nYour task is to schedule the jobs respecting dependencies and parallelism to **minimize the total completion time** (makespan). Return that minimum time.\n\n### Example:\n<pre><code>n = 5\ntime = [3, 2, 4, 1, 2]\nprerequisites = [[2, 0], [2, 1], [3, 2], [4, 2]]\nk = 2\n\nJobs 0 & 1 start immediately, taking 3 & 2 units.\nOnce both finish (at time 3), job 2 (4 units) can start—and job 3 and 4 depend on 2.\nWith 2 machines, schedule 2 (duration 4) and idle (if needed).\nAfter job 2 finishes at time 7, jobs 3 (1 unit) and 4 (2 units) can run in parallel.\nCompletes by time = 9.\n</code></pre>\n\n**Pro Tip:** This is like a layered DAG scheduling problem, also addressed by the Coffman–Graham algorithm for width-constrained topological scheduling :contentReference[oaicite:1]{index=1}.',
    sampleTestCases: [
      {
        input: '5\n[3,2,4,1,2]\n4\n2 0\n2 1\n3 2\n4 2\n2',
        expected: '9',
      },
    ],
    testCases: [
      { input: '1\n[5]\n0\n1', expected: '5' },
      { input: '3\n[3,2,1]\n2\n2 0\n2 1\n2', expected: '4' },
      { input: '4\n[1,1,1,1]\n3\n1 0\n2 0\n3 0\n2', expected: '3' },
      { input: '4\n[5,4,3,2]\n2\n2 0\n3 1\n2', expected: '8' },
      {
        input: '6\n[2,2,2,2,2,2]\n5\n1 0\n2 1\n3 1\n4 2\n5 3\n3',
        expected: '8',
      },
    ],
    topics: ['graph', 'scheduling', 'topological sort', 'coffman-graham', 'dp'],
    interviewExcerpt:
      'You are building a build system that runs tasks in parallel but certain tasks depend on earlier ones. Given durations and dependency graph, compute the minimum time to finish all tasks respecting parallel execution constraints.',
    difficulty: 'hard',
    frequency: 25,
    tags: ['graph', 'scheduling', 'makespan', 'parallelism'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Use topological order with priority heuristic (e.g., longest tasks first).',
      'Coffman–Graham algorithm is relevant for scheduling with width constraint k :contentReference[oaicite:2]{index=2}.',
    ],
    optimalComplexity: {
      time: 'Polynomial for fixed k; general problem is NP-hard.',
      space: 'O(n + e)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: 'system',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = JSON.parse(fs.readFileSync(0, 'utf8'));\n  const { n, time, prerequisites, k } = input;\n  console.log(minimumCompletionTime(n, time, prerequisites, k));\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys, json\n    inp = json.loads(sys.stdin.read())\n    print(minimum_completion_time(inp['n'], inp['time'], inp['prerequisites'], inp['k']))",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function minimumCompletionTime(n, time, prerequisites, k) {\n  // Build DAG and compute levels (earliest start times)\n  // Use priority scheduling or Coffman–Graham to assign tasks to k slots minimizing makespan\n  return 0;\n}',
      },
      {
        language: 'python',
        code: 'def minimum_completion_time(n, time, prerequisites, k):\n    # Implement scheduling on DAG with width k constraint\n    return 0',
      },
    ],
  },
  {
    title: 'Longest Path in a Directed Acyclic Graph (DAG)',
    slug: 'longest-path-in-dag',
    description:
      'Given a Directed Acyclic Graph (DAG), find the longest path from a specified source node to all other nodes, or the maximum-length simple path in the graph.',
    problemStatement:
      'You are provided a **DAG** with `n` nodes labeled `0` to `n−1`, and a list of directed edges. Optionally, edges may have weights. Your task is to compute the length of the **longest path**:\n- **Case A (Unweighted):** Maximum number of edges in any path.\n- **Case B (Weighted):** Maximum total weight from a specified source node to every other node.\n\nReturn:\n- In **Case A**, a single integer for the longest path length in the DAG.\n- In **Case B**, an array `dist` where `dist[v]` is the longest distance from the source to node `v`.\n\nIf any node is not reachable (in Case B), its distance can remain `−∞` (if unreachable) or a sentinel like `null`.',
    sampleTestCases: [
      {
        input:
          'n = 5, edges = [[0,1],[1,2],[0,2],[2,3],[3,4]], weighted = false',
        expected: '4',
      },
      {
        input:
          'n = 4, edges = [[0,1,3],[0,2,2],[1,3,4],[2,3,5]], source = 0, weighted = true',
        expected: '[−∞, 3, 2, 8]',
      },
    ],
    testCases: [
      { input: '2, [[0,1]], false', expected: '1' },
      { input: '3, [[0,1],[1,2]], false', expected: '2' },
      { input: '3, [[0,1,1],[1,2,2]], 0, true', expected: '[0,1,3]' },
      { input: '3, [[0,1,5],[0,2,10]], 0, true', expected: '[0,5,10]' },
      { input: '4, [[0,1],[0,2],[2,3]], false', expected: '3' },
      {
        input: '4, [[0,1,2],[1,3,3],[0,2,4],[2,3,1]], 0, true',
        expected: '[0,2,4,6]',
      },
    ],
    topics: ['graph', 'dynamic programming', 'topological sort'],
    interviewExcerpt:
      "You're analyzing DAG dependencies—like build tasks or project milestones—and need to find the critical path (longest path). Compute it efficiently using topological ordering.",
    difficulty: 'medium',
    frequency: 68,
    tags: ['graph', 'longest path', 'dag', 'dp', 'topo sort'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Topologically sort the DAG and relax edges in order.',
      'Initialize distances to −∞ (or 0 for starting node in unweighted case).',
    ],
    optimalComplexity: {
      time: 'O(n + e)',
      space: 'O(n + e)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: 'system',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const { n, edges, source, weighted, unweighted } = JSON.parse(fs.readFileSync(0, 'utf8'));\n  if (weighted) {\n    console.log(longestPathWeighted(n, edges, source));\n  } else {\n    console.log(longestPathUnweighted(n, edges));\n  }\n}\nmain();",
      },
      {
        language: 'python',
        code: "if __name__ == '__main__':\n    import sys, json\n    inp = json.loads(sys.stdin.read())\n    if inp.get('weighted'):\n        print(longest_path_weighted(inp['n'], inp['edges'], inp['source']))\n    else:\n        print(longest_path_unweighted(inp['n'], inp['edges']))",
      },
      {
        language: 'java',
        code: '// Read JSON-like input and dispatch to unweighted or weighted implementation\npublic class Main { public static void main(String[] args) { /* … */ } }',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: '// Unweighted longest path in DAG\nfunction longestPathUnweighted(n, edges) {\n  // 1. Build adjacency list, compute in-degree\n  // 2. Topological sort (Kahn’s)\n  // 3. dp[v] = max(dp[v], dp[u] + 1)\n  // Return max(dp)\n}\n\n// Weighted longest path from source\nfunction longestPathWeighted(n, edges, source) {\n  // edges: [u, v, w]\n  // 1. Build adj list and in-degree\n  // 2. Topo sort\n  // 3. dist[v] = max(dist[v], dist[u] + w)\n  // Return dist array\n}',
      },
      {
        language: 'python',
        code: 'def longest_path_unweighted(n, edges):\n    # topological ordering, then dp\n    pass\n\ndef longest_path_weighted(n, edges, source):\n    # similar logic with weights\n    pass',
      },
      {
        language: 'java',
        code: 'int longestPathUnweighted(int n, List<int[]> edges) {\n    // DP via topo sort\n    return 0;\n}\nlong[] longestPathWeighted(int n, List<int[]> edges, int source) {\n    // return distances\n    return new long[n];\n}',
      },
      {
        language: 'c++',
        code: 'int longestPathUnweighted(int n, vector<pair<int,int>>& edges) {\n    // DP via topo sort\n    return 0;\n}\nvector<long long> longestPathWeighted(int n, vector<tuple<int,int,int>>& edges, int source) {\n    return {};\n}',
      },
    ],
  },
  {
    title: 'Parallel Course Scheduling',
    slug: 'parallel-course-scheduling',
    description:
      'Compute the minimum number of semesters required to finish all courses, with either unlimited or limited courses per semester.',
    problemStatement:
      'Given `n` courses labeled `1` to `n`, and a list of prerequisites where each pair `[u, v]` means course `u` depends on course `v`:\n\n**Version A – Unlimited Courses per Semester:** You can take any number of available courses each semester. Return the minimum semesters, or `-1` if impossible.\n\n**Version B – At Most _k_ Courses per Semester:** You can take up to `_k_` available courses each semester. Return minimum semesters. (Schedule is always possible.)',
    topics: ['graph', 'topological sort', 'bitmask DP'],
    difficulty: 'medium for A, hard for B',
    hints: [
      'Version A: Use level-order topological sort (BFS).',
      'Version B: Use bitmask DP or BFS over subsets of available courses.',
    ],
    optimalComplexity: {
      time: 'A: O(n + e), B: O(2ⁿ · n)',
      space: 'A: O(n + e), B: O(2ⁿ)',
    },
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = JSON.parse(fs.readFileSync(0, 'utf8'));\n  const { n, prerequisites, k } = input;\n  if (k == null) console.log(minSemestersUnlimited(n, prerequisites));\n  else console.log(minSemestersLimited(n, prerequisites, k));\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys, json\ninput_data = json.loads(sys.stdin.read())\nn = input_data['n']\nprerequisites = input_data['prerequisites']\nk = input_data.get('k')\nif k is None:\n    print(min_semesters_unlimited(n, prerequisites))\nelse:\n    print(min_semesters_limited(n, prerequisites, k))",
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int m = sc.nextInt();\n    List<int[]> pre = new ArrayList<>();\n    for (int i = 0; i < m; i++) pre.add(new int[] { sc.nextInt(), sc.nextInt() });\n    int k = sc.hasNextInt() ? sc.nextInt() : -1;\n    if (k < 0) System.out.println(minSemestersUnlimited(n, pre));\n    else System.out.println(minSemestersLimited(n, pre, k));\n  }\n}',
      },
      {
        language: 'c++',
        code: '#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int n, m; cin >> n >> m;\n  vector<pair<int,int>> pre(m);\n  for (int i = 0; i < m; i++) cin >> pre[i].first >> pre[i].second;\n  int k; cin >> k;\n  if (k <= 0) cout << minSemestersUnlimited(n, pre);\n  else cout << minSemestersLimited(n, pre, k);\n}',
      },
      {
        language: 'c',
        code: '#include <stdio.h>\n#include <stdlib.h>\nint main() {\n    int n, m;\n    scanf("%d %d", &n, &m);\n    int (*pre)[2] = malloc(m * sizeof(int[2]));\n    for (int i = 0; i < m; i++) scanf("%d %d", &pre[i][0], &pre[i][1]);\n    int k;\n    if (scanf("%d", &k) == 1 && k > 0)\n        printf("%d", minSemestersLimited(n, m, pre, k));\n    else\n        printf("%d", minSemestersUnlimited(n, m, pre));\n    return 0;\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: '// Version A: Unlimited per semester\nfunction minSemestersUnlimited(n, prerequisites) {\n  // Build graph and indegree array\n  // Use BFS to count layers\n  return -1;\n}\n\n// Version B: At most k per semester\nfunction minSemestersLimited(n, prerequisites, k) {\n  // Use bitmask DP or BFS over subsets\n  return -1;\n}',
      },
      {
        language: 'python',
        code: 'def min_semesters_unlimited(n, prerequisites):\n    # Build graph and indegree\n    # BFS level count\n    return -1\n\ndef min_semesters_limited(n, prerequisites, k):\n    # Bitmask DP or subset BFS\n    return -1',
      },
      {
        language: 'java',
        code: 'public static int minSemestersUnlimited(int n, List<int[]> pre) {\n    // BFS via topological sort\n    return -1;\n}\npublic static int minSemestersLimited(int n, List<int[]> pre, int k) {\n    // Bitmask DP over states\n    return -1;\n}',
      },
      {
        language: 'c++',
        code: 'int minSemestersUnlimited(int n, vector<pair<int,int>>& pre) {\n    // BFS layers\n    return -1;\n}\nint minSemestersLimited(int n, vector<pair<int,int>>& pre, int k) {\n    // Bitmask DP BFS\n    return -1;\n}',
      },
      {
        language: 'c',
        code: 'int minSemestersUnlimited(int n, int m, int pre[][2]) {\n    // BFS layers using adjacency lists\n    return -1;\n}\nint minSemestersLimited(int n, int m, int pre[][2], int k) {\n    // Bitmask DP (limited to small n)\n    return -1;\n}',
      },
    ],
  },
  {
    title: 'Longest Path in a Directed Acyclic Graph (DAG)',
    slug: 'longest-path-in-dag',
    description:
      'Find the longest path in a DAG—either in terms of edge count (unweighted) or total weight from a given source (weighted).',
    problemStatement:
      'You are given a **Directed Acyclic Graph (DAG)** with `n` nodes labeled from `0` to `n-1`, and a list of directed edges.\n\nTwo variants:\n\n**1. Unweighted DAG**: Find the length (in number of edges) of the longest path in the entire graph.\n**2. Weighted DAG**: Given a source node `source` and weighted edges `(u, v, w)`, compute the longest path distances from `source` to all other nodes. Unreachable nodes can be marked as `-∞` (or a sentinel).\n\nIf the graph is not a DAG (i.e., contains cycles), return an empty list or special output indicating invalidity.',
    sampleTestCases: [
      {
        input:
          'n = 5, edges = [[0,1],[1,2],[0,2],[2,3],[3,4]], weighted = false',
        expected: '4  (The longest path has 4 edges, e.g., 0→2→3→4)',
      },
      {
        input:
          'n = 4, edges = [[0,1,3],[0,2,2],[1,3,4],[2,3,5]], source = 0, weighted = true',
        expected: '[0, 3, 2, 8]  (Longest distances from node 0)',
      },
    ],
    testCases: [
      { variant: 'unweighted', input: 'n=2, edges=[[0,1]]', expected: '1' },
      {
        variant: 'unweighted',
        input: 'n=3, edges=[[0,1],[1,2]]',
        expected: '2',
      },
      {
        variant: 'weighted',
        input: 'n=3, edges=[[0,1,1],[1,2,2]], source=0',
        expected: '[0,1,3]',
      },
      {
        variant: 'weighted',
        input: 'n=3, edges=[[0,1,5],[0,2,10]], source=0',
        expected: '[0,5,10]',
      },
      {
        variant: 'unweighted',
        input: 'n=4, edges=[[0,1],[0,2],[2,3]]',
        expected: '3',
      },
      {
        variant: 'weighted',
        input: 'n=4, edges=[[0,1,2],[1,3,3],[0,2,4],[2,3,1]], source=0',
        expected: '[0,2,4,6]',
      },
    ],
    topics: ['graph', 'dynamic programming', 'topological sort'],
    interviewExcerpt:
      "You're computing critical paths in build systems or projects—determine the maximum delay (longest path) efficiently using DAG properties.",
    difficulty: 'medium',
    frequency: 68,
    tags: ['graph', 'longest path', 'dag', 'dp', 'topo sort'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Do a topological sort of the DAG first.',
      'For unweighted variant, use dp[v] = max(dp[v], dp[u] + 1).',
      'For weighted variant, use dist[v] = max(dist[v], dist[u] + weight).',
    ],
    optimalComplexity: {
      time: 'O(n + e)',
      space: 'O(n + e)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: 'system',
    preCode: [
      {
        language: 'javascript',
        code: "const fs = require('fs');\nfunction main() {\n  const input = JSON.parse(fs.readFileSync(0, 'utf8'));\n  const { n, edges, variant, source } = input;\n  if (variant === 'unweighted') {\n    console.log(longestPathUnweighted(n, edges));\n  } else {\n    console.log(longestPathWeighted(n, edges, source));\n  }\n}\nmain();",
      },
      {
        language: 'python',
        code: "import sys, json\ninp = json.loads(sys.stdin.read())\nif inp['variant'] == 'unweighted':\n    print(longest_path_unweighted(inp['n'], inp['edges']))\nelse:\n    print(longest_path_weighted(inp['n'], inp['edges'], inp['source']))",
      },
      {
        language: 'java',
        code: '// Read n, edges, variant, and source (if weighted).\n// Call appropriate helper methods.',
      },
      {
        language: 'c++',
        code: '// Read inputs and dispatch to longestPathUnweighted or longestPathWeighted.',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: '// Variant: Unweighted\nfunction longestPathUnweighted(n, edges) {\n  // 1. Build adjacency list, compute indegree\n  // 2. Topological sort (Kahn’s algorithm)\n  // 3. Initialize dp[v] = 0 for all v\n  // 4. For each u in topo order:\n  //      for v of adj[u]: dp[v] = max(dp[v], dp[u] + 1)\n  // 5. Return max of dp\n}\n\n// Variant: Weighted (from source)\nfunction longestPathWeighted(n, edges, source) {\n  // edges: [u, v, w]\n  // 1. Build adjacency list and indegree\n  // 2. Topological sort\n  // 3. Initialize dist[v] = -Infinity for all v, dist[source] = 0\n  // 4. For each u in topo order:\n  //      for each [v, w] in adj[u]:\n  //          if dist[u] != -Infinity:\n  //              dist[v] = max(dist[v], dist[u] + w)\n  // 5. Return dist array\n}',
      },
      {
        language: 'python',
        code: 'def longest_path_unweighted(n, edges):\n    # Use topo sort and DP as described\n    pass\n\ndef longest_path_weighted(n, edges, source):\n    # Use weighted variant with DP\n    pass',
      },
      {
        language: 'java',
        code: 'int longestPathUnweighted(int n, List<int[]> edges) {\n    // Implement topo sort + dp\n    return 0;\n}\nlong[] longestPathWeighted(int n, List<int[]> edges, int source) {\n    // Implement weighted DP\n    return new long[n];\n}',
      },
      {
        language: 'c++',
        code: 'int longestPathUnweighted(int n, vector<pair<int,int>>& edges) {\n    // Implement topo sort + dp\n    return 0;\n}\nvector<long long> longestPathWeighted(int n, vector<tuple<int,int,int>>& edges, int source) {\n    // Implement weighted DP\n    return vector<long long>(n, LLONG_MIN);\n}',
      },
      {
        language: 'c',
        code: 'int longest_path_unweighted(int n, int m, int edges[][2]) {\n    // Build graph, perform topo sort and DP\n    return -1;\n}\nvoid longest_path_weighted(int n, int m, int edges[][3], int source, long long dist[]) {\n    // Build graph, perform weighted DP\n}',
      },
    ],
  },
  {
    title: 'Parallel Course Scheduling',
    slug: 'parallel-course-scheduling',
    description:
      'Determine the minimum number of semesters required to finish all courses given prerequisites and parallel course limits.',
    problemStatement:
      'You are given an integer `n`, representing the number of courses labeled from 1 to n. You are also given an array `relations` where `relations[i] = [a, b]` denotes that course `a` must be completed before course `b`. Additionally, you are given an integer `k`, the maximum number of courses that can be taken in a single semester.\n\nReturn the minimum number of semesters required to complete all courses. You can take up to `k` courses in parallel each semester, but only if the prerequisites are satisfied.\n\nUse topological sorting and bitmasking to optimize the scheduling.\n\nExamples:\n\n<pre><code>Input: n = 4, relations = [[2,1],[3,1],[1,4]], k = 2\nOutput: 3\nExplanation:\nSemester 1: take courses 2 and 3\nSemester 2: take course 1\nSemester 3: take course 4\n</code></pre>\n\n<pre><code>Input: n = 5, relations = [[2,1],[3,1],[4,1],[1,5]], k = 2\nOutput: 4\nExplanation:\nSemester 1: take courses 2 and 3\nSemester 2: take course 4\nSemester 3: take course 1\nSemester 4: take course 5\n</code></pre>\n\n<ul>\n<li>1 &lt;= n &lt;= 15</li>\n<li>1 &lt;= k &lt;= n</li>\n<li>0 &lt;= relations.length &lt;= n * (n - 1) / 2</li>\n<li>relations[i].length == 2</li>\n<li>1 &lt;= ai, bi &lt;= n</li>\n<li>ai != bi</li>\n<li>All prerequisite pairs are unique.</li>\n</ul>\n\nPro Tip: Represent the state of completed courses using bitmasking. Use BFS or DFS with memoization to traverse all valid states efficiently.',
    sampleTestCases: [
      {
        input: '4\n[[2,1],[3,1],[1,4]]\n2',
        expected: '3',
      },
      {
        input: '5\n[[2,1],[3,1],[4,1],[1,5]]\n2',
        expected: '4',
      },
    ],
    testCases: [
      { input: '2\n[]\n2', expected: '1' },
      { input: '3\n[[1,3],[2,3]]\n2', expected: '2' },
      { input: '4\n[[1,2],[2,3],[3,4]]\n1', expected: '4' },
      { input: '4\n[[1,2],[2,3],[3,4]]\n2', expected: '3' },
      { input: '6\n[[1,4],[2,4],[3,5],[4,6],[5,6]]\n2', expected: '4' },
      { input: '6\n[[1,2],[2,3],[3,4],[4,5],[5,6]]\n3', expected: '4' },
      { input: '1\n[]\n1', expected: '1' },
      { input: '5\n[[1,2],[2,3],[3,4],[4,5]]\n5', expected: '5' },
      { input: '3\n[[1,3],[2,3]]\n1', expected: '3' },
      { input: '3\n[]\n2', expected: '2' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're designing a university system that needs to auto-assign students to courses each semester while ensuring prerequisites are followed and parallel courses are maximized. Can you compute the minimum number of semesters needed to finish all courses?",
    categories: 'graphs',
    difficulty: 'hard',
    frequency: 82,
    tags: ['topological sort', 'bitmask', 'graph', 'bfs', 'dp'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'ByteDance', logoUrl: '' },
    ],
    hints: [
      'Try modeling this as a graph where each course is a node.',
      'Use bitmask to track which courses are already completed.',
      'At each step, consider all subsets of available courses (up to k) to take next.',
    ],
    optimalComplexity: {
      time: 'O(n * 2^n)',
      space: 'O(2^n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const relations = JSON.parse(input[1]);\n  const k = parseInt(input[2]);\n  const res = minNumberOfSemesters(n, relations, k);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'import sys, json\n\ndef main():\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    relations = json.loads(lines[1])\n    k = int(lines[2])\n    res = minNumberOfSemesters(n, relations, k)\n    print(res)\n\nif __name__ == "__main__":\n    main()',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.nextLine());\n        String relStr = sc.nextLine();\n        int k = Integer.parseInt(sc.nextLine());\n        List<List<Integer>> relations = new ArrayList<>();\n        for (String pair : relStr.replaceAll("\\[|\\]", "").split("(?<=\\d),(?=\\d)")) {\n            String[] parts = pair.split(",");\n            relations.add(Arrays.asList(Integer.parseInt(parts[0]), Integer.parseInt(parts[1])));\n        }\n        System.out.println(minNumberOfSemesters(n, relations, k));\n    }\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function minNumberOfSemesters(n, relations, k) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def minNumberOfSemesters(n, relations, k):\n    # write your code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static int minNumberOfSemesters(int n, List<List<Integer>> relations, int k) {\n    // write your code here\n    return 0;\n}',
      },
    ],
  },
  {
    title: 'Task Scheduling with Prerequisites',
    slug: 'task-scheduling-with-prerequisites',
    description:
      'Determine if all tasks can be completed given a list of prerequisite dependencies.',
    problemStatement:
      'You are given an integer `n` representing the number of tasks labeled from 0 to n - 1, and a list of prerequisite pairs where each pair `[a, b]` means task `b` must be completed before task `a`.\n\nReturn `true` if all tasks can be completed, otherwise return `false`.\n\nThis is a classic problem in topological sorting. You must detect whether a cycle exists in the directed graph formed by the prerequisites.\n\nExamples:\n\n<pre><code>Input: n = 4, prerequisites = [[1,0],[2,1],[3,2]]\nOutput: true\nExplanation:\nTask order: 0 -> 1 -> 2 -> 3\n</code></pre>\n\n<pre><code>Input: n = 3, prerequisites = [[0,1],[1,2],[2,0]]\nOutput: false\nExplanation:\nCycle exists: 0 -> 1 -> 2 -> 0\n</code></pre>\n\n<ul>\n<li>1 &lt;= n &lt;= 10<sup>5</sup></li>\n<li>0 &lt;= prerequisites.length &lt;= 10<sup>5</sup></li>\n<li>prerequisites[i].length == 2</li>\n<li>0 &lt;= a, b &lt; n</li>\n<li>a != b</li>\n</ul>\n\nPro Tip: Use Kahn’s algorithm (BFS-based topological sort) or DFS with visited and recursion stack arrays to detect cycles.',
    sampleTestCases: [
      {
        input: '4\n[[1,0],[2,1],[3,2]]',
        expected: 'true',
      },
      {
        input: '3\n[[0,1],[1,2],[2,0]]',
        expected: 'false',
      },
    ],
    testCases: [
      { input: '2\n[[1,0]]', expected: 'true' },
      { input: '2\n[[1,0],[0,1]]', expected: 'false' },
      { input: '5\n[]', expected: 'true' },
      { input: '4\n[[0,1],[1,2],[2,3]]', expected: 'true' },
      { input: '4\n[[0,1],[1,2],[2,3],[3,1]]', expected: 'false' },
      { input: '6\n[[1,0],[2,1],[3,2],[4,3],[5,4]]', expected: 'true' },
      { input: '3\n[[0,2],[2,1],[1,0]]', expected: 'false' },
      { input: '3\n[]', expected: 'true' },
      { input: '4\n[[1,0],[2,0],[3,1],[3,2]]', expected: 'true' },
      { input: '4\n[[1,0],[2,0],[3,1],[1,3]]', expected: 'false' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Let's say you're managing a project with many interdependent tasks. Given a list of tasks and prerequisites, can you determine whether it's possible to schedule all tasks without getting stuck in a cycle?",
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 88,
    tags: ['graph', 'topological sort', 'cycle detection', 'bfs', 'dfs'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Try representing the tasks as a graph where each node is a task.',
      "Use Kahn's algorithm or DFS with cycle detection to validate the graph.",
      'If a cycle is detected, return false.',
    ],
    optimalComplexity: {
      time: 'O(n + e)',
      space: 'O(n + e)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const prerequisites = JSON.parse(input[1]);\n  const res = canFinish(n, prerequisites);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'import sys, json\n\ndef main():\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    prerequisites = json.loads(lines[1])\n    res = canFinish(n, prerequisites)\n    print(res)\n\nif __name__ == "__main__":\n    main()',
      },
      {
        language: 'java',
        code: 'import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.nextLine());\n        String relStr = sc.nextLine();\n        List<List<Integer>> prerequisites = new ArrayList<>();\n        for (String pair : relStr.replaceAll("\\[|\\]", "").split("(?<=\\d),(?=\\d)")) {\n            String[] parts = pair.split(",");\n            prerequisites.add(Arrays.asList(Integer.parseInt(parts[0]), Integer.parseInt(parts[1])));\n        }\n        System.out.println(canFinish(n, prerequisites));\n    }\n}',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function canFinish(n, prerequisites) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def canFinish(n, prerequisites):\n    # write your code here\n    pass',
      },
      {
        language: 'java',
        code: 'public static boolean canFinish(int n, List<List<Integer>> prerequisites) {\n    // write your code here\n    return false;\n}',
      },
    ],
  },
  {
    title: 'Detect Cycle in Undirected Graph using DSU',
    slug: 'detect-cycle-in-undirected-graph-using-dsu',
    description:
      'Check if an undirected graph contains a cycle using Disjoint Set Union (Union-Find).',
    problemStatement:
      'You are given an undirected graph with `n` nodes numbered from 0 to n - 1 and a list of edges where each edge is a pair `[u, v]`.\n\nReturn `true` if there is a cycle in the graph, otherwise return `false`.\n\nUse the Disjoint Set Union (DSU) approach with Union by Rank and Path Compression to efficiently detect cycles.\n\nExamples:\n\n<pre><code>Input: n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]\nOutput: false\nExplanation: The graph is a tree, no cycles present.\n</code></pre>\n\n<pre><code>Input: n = 5, edges = [[0,1],[1,2],[2,3],[3,1]]\nOutput: true\nExplanation: Cycle exists: 1 -> 2 -> 3 -> 1\n</code></pre>\n\n<ul>\n<li>1 &lt;= n &lt;= 10<sup>5</sup></li>\n<li>0 &lt;= edges.length &lt;= 2*10<sup>5</sup></li>\n<li>0 &lt;= u, v &lt; n</li>\n<li>u != v</li>\n<li>No duplicate edges</li>\n</ul>\n\nPro Tip: In each `union(u, v)` operation, if `find(u) == find(v)`, a cycle is detected.',
    sampleTestCases: [
      {
        input: '5\n[[0,1],[1,2],[2,3],[3,4]]',
        expected: 'false',
      },
      {
        input: '5\n[[0,1],[1,2],[2,3],[3,1]]',
        expected: 'true',
      },
    ],
    testCases: [
      { input: '3\n[[0,1],[1,2]]', expected: 'false' },
      { input: '3\n[[0,1],[1,2],[2,0]]', expected: 'true' },
      { input: '4\n[[0,1],[2,3]]', expected: 'false' },
      { input: '4\n[[0,1],[1,2],[2,3],[3,0]]', expected: 'true' },
      { input: '6\n[[0,1],[1,2],[2,3],[3,4],[4,5]]', expected: 'false' },
      { input: '6\n[[0,1],[1,2],[2,0],[3,4],[4,5]]', expected: 'true' },
      { input: '5\n[]', expected: 'false' },
      { input: '1\n[]', expected: 'false' },
      { input: '2\n[[0,1],[1,0]]', expected: 'true' },
      { input: '5\n[[0,1],[1,2],[2,3],[3,4],[4,0]]', expected: 'true' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re helping build a peer-to-peer network where duplicate links can create loops. Can you efficiently check if a new connection introduces a cycle in the undirected network?',
    categories: 'union-find',
    difficulty: 'medium',
    frequency: 70,
    tags: ['union find', 'dsu', 'cycle detection', 'graph'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Meta', logoUrl: '' },
    ],
    hints: [
      'Treat each edge as a union operation between its two nodes.',
      'If two nodes already share the same parent, adding the edge forms a cycle.',
      'Use union by rank and path compression for efficiency.',
    ],
    optimalComplexity: {
      time: 'O(e * α(n))',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const edges = JSON.parse(input[1]);\n  const res = hasCycle(n, edges);\n  console.log(res);\n}\n\nfunction hasCycle(n, edges) {\n  const parent = Array.from({ length: n }, (_, i) => i);\n  const rank = Array(n).fill(0);\n  \n  function find(x) {\n    if (parent[x] !== x) parent[x] = find(parent[x]);\n    return parent[x];\n  }\n\n  function union(x, y) {\n    const xr = find(x), yr = find(y);\n    if (xr === yr) return false;\n    if (rank[xr] < rank[yr]) parent[xr] = yr;\n    else if (rank[xr] > rank[yr]) parent[yr] = xr;\n    else { parent[yr] = xr; rank[xr]++; }\n    return true;\n  }\n\n  for (const [u, v] of edges) {\n    if (!union(u, v)) return true;\n  }\n  return false;\n}\n\nmain();',
      },
      {
        language: 'python',
        code: 'import sys, json\n\ndef main():\n    input_lines = sys.stdin.read().strip().split(\'\\n\')\n    n = int(input_lines[0])\n    edges = json.loads(input_lines[1])\n    print(hasCycle(n, edges))\n\ndef hasCycle(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        xr, yr = find(x), find(y)\n        if xr == yr:\n            return False\n        if rank[xr] < rank[yr]:\n            parent[xr] = yr\n        elif rank[xr] > rank[yr]:\n            parent[yr] = xr\n        else:\n            parent[yr] = xr\n            rank[xr] += 1\n        return True\n\n    for u, v in edges:\n        if not union(u, v):\n            return True\n    return False\n\nif __name__ == "__main__":\n    main()',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function hasCycle(n, edges) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def hasCycle(n, edges):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Number of Connected Components using DSU',
    slug: 'number-of-connected-components-using-dsu',
    description:
      'Count how many connected components exist in an undirected graph using the Disjoint Set Union (Union-Find) technique.',
    problemStatement:
      'You are given an undirected graph with `n` nodes labeled from 0 to n - 1 and an array of edges where each edge is a pair `[u, v]` indicating a connection between node `u` and node `v`.\n\nYour task is to return the number of connected components in the graph using the Disjoint Set Union (DSU) data structure with path compression and union by rank optimizations.\n\nExamples:\n\n<pre><code>Input: n = 5, edges = [[0,1],[1,2],[3,4]]\nOutput: 2\nExplanation:\nComponent 1: 0-1-2, Component 2: 3-4\n</code></pre>\n\n<pre><code>Input: n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]\nOutput: 1\nExplanation:\nAll nodes are connected in a single component.\n</code></pre>\n\n<ul>\n<li>1 &lt;= n &lt;= 10<sup>5</sup></li>\n<li>0 &lt;= edges.length &lt;= 2 * 10<sup>5</sup></li>\n<li>0 &lt;= u, v &lt; n</li>\n<li>u != v</li>\n<li>No duplicate edges</li>\n</ul>\n\nPro Tip: Start with `n` components, and each successful union reduces the count by 1. Return the final count.',
    sampleTestCases: [
      {
        input: '5\n[[0,1],[1,2],[3,4]]',
        expected: '2',
      },
      {
        input: '5\n[[0,1],[1,2],[2,3],[3,4]]',
        expected: '1',
      },
    ],
    testCases: [
      { input: '3\n[[0,1],[1,2]]', expected: '1' },
      { input: '4\n[[0,1],[2,3]]', expected: '2' },
      { input: '4\n[]', expected: '4' },
      { input: '1\n[]', expected: '1' },
      { input: '2\n[[0,1]]', expected: '1' },
      { input: '2\n[]', expected: '2' },
      { input: '6\n[[0,1],[1,2],[3,4]]', expected: '3' },
      { input: '6\n[[0,1],[2,3],[4,5]]', expected: '3' },
      { input: '7\n[[0,1],[1,2],[3,4],[5,6]]', expected: '3' },
      { input: '5\n[[0,1],[1,2],[3,4],[2,3]]', expected: '1' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're working with a network of devices. Given their direct communication links, can you find out how many isolated subnetworks exist using DSU?",
    categories: 'union-find',
    difficulty: 'medium',
    frequency: 73,
    tags: ['union find', 'dsu', 'graph', 'connected components'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Initialize each node as its own parent.',
      'Each union reduces the number of components by one if the two nodes were previously unconnected.',
      'Return the remaining number of components.',
    ],
    optimalComplexity: {
      time: 'O(e * α(n))',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const input = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(input[0]);\n  const edges = JSON.parse(input[1]);\n  const res = countComponents(n, edges);\n  console.log(res);\n}\n\nfunction countComponents(n, edges) {\n  const parent = Array.from({ length: n }, (_, i) => i);\n  const rank = Array(n).fill(0);\n  let count = n;\n\n  function find(x) {\n    if (parent[x] !== x) parent[x] = find(parent[x]);\n    return parent[x];\n  }\n\n  function union(x, y) {\n    let xr = find(x), yr = find(y);\n    if (xr === yr) return;\n    if (rank[xr] < rank[yr]) parent[xr] = yr;\n    else if (rank[xr] > rank[yr]) parent[yr] = xr;\n    else { parent[yr] = xr; rank[xr]++; }\n    count--;\n  }\n\n  for (const [u, v] of edges) union(u, v);\n  return count;\n}\n\nmain();',
      },
      {
        language: 'python',
        code: 'import sys, json\n\ndef main():\n    input_lines = sys.stdin.read().strip().split("\\n")\n    n = int(input_lines[0])\n    edges = json.loads(input_lines[1])\n    print(countComponents(n, edges))\n\ndef countComponents(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n    count = n\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        nonlocal count\n        xr, yr = find(x), find(y)\n        if xr == yr:\n            return\n        if rank[xr] < rank[yr]:\n            parent[xr] = yr\n        elif rank[xr] > rank[yr]:\n            parent[yr] = xr\n        else:\n            parent[yr] = xr\n            rank[xr] += 1\n        count -= 1\n\n    for u, v in edges:\n        union(u, v)\n    return count\n\nif __name__ == "__main__":\n    main()',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function countComponents(n, edges) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def countComponents(n, edges):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Smallest Equivalent String (DSU variant)',
    slug: 'smallest-equivalent-string-dsu-variant',
    description:
      'Return the lexicographically smallest equivalent string based on equivalence relations using DSU.',
    problemStatement:
      'You are given two strings `s1` and `s2` of the same length, and a base string `baseStr`.\n\nCharacters at the same index in `s1` and `s2` are considered equivalent. A character can be equivalent to multiple characters, and equivalence is transitive (e.g., if `a == b` and `b == c`, then `a == c`).\n\nReturn the lexicographically smallest equivalent string of `baseStr` after replacing every character with the smallest character in its equivalence class.\n\nUse Disjoint Set Union (DSU) to manage the equivalence classes.\n\nExamples:\n\n<pre><code>Input: s1 = "parker", s2 = "morris", baseStr = "parser"\nOutput: "makkek"\nExplanation:\nEquivalences: p==m, a==o, r==r, k==i, e==s\nReplace each character in baseStr with its lex smallest equivalent.\n</code></pre>\n\n<pre><code>Input: s1 = "hello", s2 = "world", baseStr = "hold"\nOutput: "hdld"\n</code></pre>\n\n<ul>\n<li>1 &lt;= s1.length == s2.length &lt;= 1000</li>\n<li>1 &lt;= baseStr.length &lt;= 1000</li>\n<li>s1, s2, and baseStr consist of lowercase English letters only.</li>\n</ul>\n\nPro Tip: For each equivalence union, always attach the higher character to the lower one to preserve lexicographical order.',
    sampleTestCases: [
      {
        input: 'parker\nmorris\nparser',
        expected: 'makkek',
      },
      {
        input: 'hello\nworld\nhold',
        expected: 'hdld',
      },
    ],
    testCases: [
      { input: 'abc\ndef\nfed', expected: 'abc' },
      { input: 'leetcode\nprograms\nsourcecode', expected: 'aauaaaaada' },
      { input: 'aab\nbcc\ncbc', expected: 'aaa' },
      { input: 'abc\ncba\naaa', expected: 'aaa' },
      { input: 'abc\nxyz\nabc', expected: 'abc' },
      { input: 'abcd\nabcd\nabcd', expected: 'abcd' },
      { input: 'aaa\nbbb\nccc', expected: 'ccc' },
      { input: 'abcd\nefgh\nhgfedcba', expected: 'aaaaaaaab' },
      { input: 'zzzz\nbbbb\nzbzbzb', expected: 'bbbbbb' },
      { input: 'abcabc\nxyzxyz\naxbycz', expected: 'axbycz' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're optimizing a search engine dictionary. When given pairs of equivalent characters, you need to convert text to its most canonical form — the lexicographically smallest version using equivalence classes.",
    categories: 'union-find',
    difficulty: 'medium',
    frequency: 68,
    tags: ['dsu', 'union find', 'string', 'greedy'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Adobe', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use DSU to group equivalent characters.',
      'Always keep the lexicographically smallest character as the representative.',
      'Replace each character in baseStr with the smallest equivalent character.',
    ],
    optimalComplexity: {
      time: 'O(n + m)',
      space: 'O(1)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [s1, s2, baseStr] = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const result = smallestEquivalentString(s1, s2, baseStr);\n  console.log(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: "import sys\n\ndef main():\n    s1 = sys.stdin.readline().strip()\n    s2 = sys.stdin.readline().strip()\n    baseStr = sys.stdin.readline().strip()\n    print(smallestEquivalentString(s1, s2, baseStr))\n\nif __name__ == '__main__':\n    main()",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function smallestEquivalentString(s1, s2, baseStr) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def smallestEquivalentString(s1, s2, baseStr):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Redundant Connection',
    slug: 'redundant-connection',
    description:
      'Identify and return the redundant edge that forms a cycle in an undirected graph using Union Find.',
    problemStatement:
      'You are given a connected undirected graph with `n` nodes and `n` edges. Each node is labeled from 1 to n. The graph initially started as a tree (with n-1 edges), but one additional edge was added, forming a cycle.\n\nReturn the edge that, if removed, will make the graph a tree again. If there are multiple answers, return the edge that occurs last in the input.\n\nExamples:\n\n<pre><code>Input: edges = [[1,2],[1,3],[2,3]]\nOutput: [2,3]\nExplanation: Removing [2,3] breaks the cycle and makes the graph a tree.\n</code></pre>\n\n<pre><code>Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\nOutput: [1,4]\n</code></pre>\n\n<ul>\n<li>n == edges.length</li>\n<li>3 &lt;= n &lt;= 1000</li>\n<li>edges[i].length == 2</li>\n<li>1 &lt;= a[i], b[i] &lt;= n</li>\n<li>There are no repeated edges.</li>\n<li>The given graph is connected and contains exactly one cycle.</li>\n</ul>\n\nPro Tip: Use Union Find (DSU). If two vertices are already connected, the edge connecting them is redundant.',
    sampleTestCases: [
      {
        input: '[[1,2],[1,3],[2,3]]',
        expected: '[2,3]',
      },
      {
        input: '[[1,2],[2,3],[3,4],[1,4],[1,5]]',
        expected: '[1,4]',
      },
    ],
    testCases: [
      { input: '[[1,2],[2,3],[3,1]]', expected: '[3,1]' },
      { input: '[[1,2],[2,3],[3,4],[4,1],[1,5]]', expected: '[4,1]' },
      { input: '[[1,2],[2,3],[3,4],[4,5],[2,5]]', expected: '[2,5]' },
      { input: '[[1,2],[2,3],[3,1],[4,5]]', expected: '[3,1]' },
      { input: '[[1,2],[2,3],[3,4],[4,5],[5,1]]', expected: '[5,1]' },
      { input: '[[1,2],[2,3],[3,4],[1,4],[4,5]]', expected: '[1,4]' },
      { input: '[[1,2],[2,3],[3,4],[4,5],[3,5]]', expected: '[3,5]' },
      { input: '[[1,2],[1,3],[2,4],[1,4]]', expected: '[1,4]' },
      { input: '[[1,2],[2,3],[3,4],[4,2]]', expected: '[4,2]' },
      { input: '[[1,2],[1,3],[2,4],[3,4]]', expected: '[3,4]' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're auditing a network configuration that should be a tree, but someone added an extra connection. Can you identify which connection is creating a loop?",
    categories: 'union-find',
    difficulty: 'medium',
    frequency: 85,
    tags: ['union find', 'dsu', 'cycle detection', 'graph'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Meta', logoUrl: '' },
    ],
    hints: [
      'Start with each node in its own component.',
      'For each edge, check if the two nodes are already connected.',
      'If yes, return the current edge as it creates a cycle.',
    ],
    optimalComplexity: {
      time: 'O(n * α(n))',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const edges = JSON.parse(fs.readFileSync(0, "utf-8").trim());\n  const result = findRedundantConnection(edges);\n  console.log(JSON.stringify(result));\n}\nmain();',
      },
      {
        language: 'python',
        code: "import sys, json\n\ndef main():\n    edges = json.loads(sys.stdin.read().strip())\n    print(json.dumps(findRedundantConnection(edges)))\n\nif __name__ == '__main__':\n    main()",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function findRedundantConnection(edges) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def findRedundantConnection(edges):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Satisfiability of Equality Equations',
    slug: 'satisfiability-of-equality-equations',
    description:
      'Determine if a set of equality and inequality equations among variables is logically consistent using DSU.',
    problemStatement:
      'You are given an array of strings `equations` where each equation is of the form `"a==b"` or `"a!=b"`, with `a` and `b` being lowercase English letters.\n\nReturn `true` if it is possible to assign variables such that all equations are satisfied, otherwise return `false`.\n\nThis can be solved using Disjoint Set Union (DSU) where equality equations are used to build components and inequality equations are used to check consistency.\n\nExamples:\n\n<pre><code>Input: equations = ["a==b","b!=a"]\nOutput: false\nExplanation: a == b and b != a cannot both be true.\n</code></pre>\n\n<pre><code>Input: equations = ["b==a","a==b"]\nOutput: true\n</code></pre>\n\n<pre><code>Input: equations = ["a==b","b==c","a==c"]\nOutput: true\n</code></pre>\n\n<ul>\n<li>1 &lt;= equations.length &lt;= 500</li>\n<li>equations[i].length == 4</li>\n<li>equations[i][0] and equations[i][3] are lowercase letters</li>\n<li>equations[i][1] is \'=\' or \'!\'</li>\n<li>equations[i][2] is \'=\'</li>\n</ul>\n\nPro Tip: First union all equality pairs, then verify all inequality pairs to ensure no contradiction.',
    sampleTestCases: [
      {
        input: '["a==b","b!=a"]',
        expected: 'false',
      },
      {
        input: '["b==a","a==b"]',
        expected: 'true',
      },
      {
        input: '["a==b","b==c","a==c"]',
        expected: 'true',
      },
    ],
    testCases: [
      { input: '["a==b","b==c","c==a"]', expected: 'true' },
      { input: '["a==b","b!=c","c==a"]', expected: 'false' },
      { input: '["a==b","b!=a"]', expected: 'false' },
      { input: '["a==b","b==c","c!=a"]', expected: 'false' },
      { input: '["c==c","b==d","x!=z"]', expected: 'true' },
      { input: '["a!=a"]', expected: 'false' },
      { input: '["a==b","b==c","c==d","d==e","e!=a"]', expected: 'false' },
      { input: '["a==b","b==c","c==d","d==e"]', expected: 'true' },
      { input: '["a==b","c==d","e==f","g==h"]', expected: 'true' },
      { input: '["a==b","b==c","c==a","a!=c"]', expected: 'false' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're building a logic engine to validate symbolic constraints. Can your system determine if a mix of equality and inequality equations is logically sound?",
    categories: 'union-find',
    difficulty: 'medium',
    frequency: 81,
    tags: ['dsu', 'union find', 'graph', 'string'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use DSU to group variables connected by equality.',
      "After processing all '==' equations, check all '!=' equations.",
      "If two variables in a '!=' equation are in the same set, return false.",
    ],
    optimalComplexity: {
      time: 'O(n * α(26))',
      space: 'O(26)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const equations = JSON.parse(fs.readFileSync(0, "utf-8").trim());\n  console.log(equationsPossible(equations));\n}\nmain();',
      },
      {
        language: 'python',
        code: "import sys, json\n\ndef main():\n    equations = json.loads(sys.stdin.read().strip())\n    print(equationsPossible(equations))\n\nif __name__ == '__main__':\n    main()",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function equationsPossible(equations) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def equationsPossible(equations):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Friend Circles (Number of Provinces)',
    slug: 'friend-circles-number-of-provinces',
    description:
      'Determine the number of friend circles (provinces) in a social network using Union Find (DSU).',
    problemStatement:
      'There are `n` students in a class. Some of them are friends, and some are not. Their friendship is transitive: if student `A` is a friend of `B`, and `B` is a friend of `C`, then `A` is a friend of `C`.\n\nFriendship information is given in the form of an `n x n` matrix `M`, where `M[i][j] = 1` means student `i` and student `j` are friends, and `M[i][j] = 0` otherwise. Every student is a friend of themself (i.e., `M[i][i] = 1`).\n\nReturn the total number of friend circles (provinces) using Disjoint Set Union (DSU).\n\nExamples:\n\n<pre><code>Input: M = [[1,1,0],[1,1,0],[0,0,1]]\nOutput: 2\nExplanation:\nThe first two students are direct friends. The third student is in their own circle.\n</code></pre>\n\n<pre><code>Input: M = [[1,0,0],[0,1,0],[0,0,1]]\nOutput: 3\n</code></pre>\n\n<ul>\n<li>1 &lt;= n &lt;= 200</li>\n<li>M[i][j] is 0 or 1</li>\n<li>M[i][i] == 1</li>\n<li>M[i][j] == M[j][i]</li>\n</ul>\n\nPro Tip: Traverse only the upper triangle of the matrix (i < j) to avoid redundant unions. Use DSU to merge friends and count distinct groups.',
    sampleTestCases: [
      {
        input: '[[1,1,0],[1,1,0],[0,0,1]]',
        expected: '2',
      },
      {
        input: '[[1,0,0],[0,1,0],[0,0,1]]',
        expected: '3',
      },
    ],
    testCases: [
      { input: '[[1,1,1],[1,1,1],[1,1,1]]', expected: '1' },
      { input: '[[1,0,0,1],[0,1,1,0],[0,1,1,1],[1,0,1,1]]', expected: '1' },
      { input: '[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]', expected: '4' },
      { input: '[[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]]', expected: '2' },
      { input: '[[1,0,1],[0,1,0],[1,0,1]]', expected: '2' },
      { input: '[[1]]', expected: '1' },
      { input: '[[1,1],[1,1]]', expected: '1' },
      { input: '[[1,0],[0,1]]', expected: '2' },
      { input: '[[1,1,0],[1,1,1],[0,1,1]]', expected: '1' },
      { input: '[[1,1,0],[1,1,1],[0,1,1]]', expected: '1' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're designing a social app that automatically groups users based on their mutual connections. Can you count how many friend groups exist from a friendship matrix?",
    categories: 'union-find',
    difficulty: 'medium',
    frequency: 78,
    tags: ['dsu', 'union find', 'graph', 'matrix'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Uber', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use DSU to connect all friends based on the matrix.',
      'Only process pairs (i, j) where i < j to reduce duplicate checks.',
      'Return the count of unique parents.',
    ],
    optimalComplexity: {
      time: 'O(n^2 * α(n))',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const M = JSON.parse(fs.readFileSync(0, "utf-8").trim());\n  const result = findCircleNum(M);\n  console.log(result);\n}\nmain();',
      },
      {
        language: 'python',
        code: "import sys, json\n\ndef main():\n    M = json.loads(sys.stdin.read().strip())\n    print(findCircleNum(M))\n\nif __name__ == '__main__':\n    main()",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function findCircleNum(M) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def findCircleNum(M):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Merge Accounts',
    slug: 'merge-accounts',
    description:
      'Merge user accounts based on shared emails using Disjoint Set Union (DSU).',
    problemStatement:
      'Given a list of accounts where each element `accounts[i]` is a list of strings, with the first element being the name and the rest being emails belonging to the same person, merge accounts that have at least one email in common.\n\nReturn the merged accounts in the format:\n`[name, email1, email2, ...]`, with emails sorted lexicographically. The returned list can be in any order.\n\nUse DSU to group all emails belonging to the same person.\n\nExamples:\n\n<pre><code>Input:\naccounts = [\n  ["John", "johnsmith@mail.com", "john_newyork@mail.com"],\n  ["John", "johnsmith@mail.com", "john00@mail.com"],\n  ["Mary", "mary@mail.com"],\n  ["John", "johnnybravo@mail.com"]\n]\n\nOutput:\n[\n  ["John", \'john00@mail.com\', \'john_newyork@mail.com\', \'johnsmith@mail.com\'],\n  ["Mary", \'mary@mail.com\'],\n  ["John", \'johnnybravo@mail.com\']\n]\n</code></pre>\n\n<ul>\n<li>1 &lt;= accounts.length &lt;= 1000</li>\n<li>2 &lt;= accounts[i].length &lt;= 10</li>\n<li>1 &lt;= accounts[i][j].length &lt;= 30</li>\n<li>`accounts[i][0]` is a name, rest are emails.</li>\n<li>All emails are valid with no duplicates within a single account.</li>\n</ul>\n\nPro Tip: Map each email to an ID and union emails under the same person. Use a map to track email-to-name mapping.',
    sampleTestCases: [
      {
        input:
          '[["John", "johnsmith@mail.com", "john_newyork@mail.com"],["John", "johnsmith@mail.com", "john00@mail.com"],["Mary", "mary@mail.com"],["John", "johnnybravo@mail.com"]]',
        expected:
          '[["John","john00@mail.com","john_newyork@mail.com","johnsmith@mail.com"],["Mary","mary@mail.com"],["John","johnnybravo@mail.com"]]',
      },
    ],
    testCases: [
      {
        input:
          '[["John", "a@x.com", "b@x.com"], ["John", "b@x.com", "c@x.com"], ["Mary", "d@x.com"]]',
        expected: '[["John","a@x.com","b@x.com","c@x.com"],["Mary","d@x.com"]]',
      },
      {
        input:
          '[["Alex","a@mail.com"],["Alex","b@mail.com"],["Alex","a@mail.com","b@mail.com"]]',
        expected: '[["Alex","a@mail.com","b@mail.com"]]',
      },
      {
        input:
          '[["Bob","bob1@mail.com"],["Bob","bob2@mail.com"],["Bob","bob3@mail.com"]]',
        expected:
          '[["Bob","bob1@mail.com"],["Bob","bob2@mail.com"],["Bob","bob3@mail.com"]]',
      },
      {
        input:
          '[["Alice","x@mail.com","y@mail.com"],["Alice","z@mail.com"],["Alice","y@mail.com","z@mail.com"]]',
        expected: '[["Alice","x@mail.com","y@mail.com","z@mail.com"]]',
      },
      {
        input:
          '[["Zed","z1@mail.com","z2@mail.com"],["Zed","z3@mail.com"],["Zed","z2@mail.com","z3@mail.com"]]',
        expected: '[["Zed","z1@mail.com","z2@mail.com","z3@mail.com"]]',
      },
      {
        input: '[["Tom","tom@mail.com"],["Jerry","jerry@mail.com"]]',
        expected: '[["Tom","tom@mail.com"],["Jerry","jerry@mail.com"]]',
      },
      {
        input:
          '[["Eva","e1@mail.com","e2@mail.com"],["Eva","e2@mail.com","e3@mail.com"]]',
        expected: '[["Eva","e1@mail.com","e2@mail.com","e3@mail.com"]]',
      },
      {
        input:
          '[["Tim","t1@mail.com","t2@mail.com"],["Tim","t3@mail.com"],["Tim","t2@mail.com","t3@mail.com"]]',
        expected: '[["Tim","t1@mail.com","t2@mail.com","t3@mail.com"]]',
      },
      {
        input:
          '[["Lisa","l1@mail.com"],["Lisa","l2@mail.com"],["Lisa","l1@mail.com","l2@mail.com"]]',
        expected: '[["Lisa","l1@mail.com","l2@mail.com"]]',
      },
      {
        input:
          '[["Mike","m1@mail.com"],["Mike","m2@mail.com"],["Mike","m1@mail.com","m2@mail.com"]]',
        expected: '[["Mike","m1@mail.com","m2@mail.com"]]',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Suppose you're merging user data from multiple sources. Given a list of accounts with overlapping emails, can you group them into distinct users using DSU?",
    categories: 'union-find',
    difficulty: 'medium',
    frequency: 90,
    tags: ['dsu', 'union find', 'graph', 'string'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use DSU to union emails belonging to the same user.',
      'Track name of each email separately.',
      'After building the sets, collect and sort emails under each root.',
    ],
    optimalComplexity: {
      time: 'O(n * log n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const accounts = JSON.parse(fs.readFileSync(0, "utf-8").trim());\n  const result = accountsMerge(accounts);\n  console.log(JSON.stringify(result));\n}\nmain();',
      },
      {
        language: 'python',
        code: "import sys, json\n\ndef main():\n    accounts = json.loads(sys.stdin.read().strip())\n    print(json.dumps(accountsMerge(accounts)))\n\nif __name__ == '__main__':\n    main()",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function accountsMerge(accounts) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def accountsMerge(accounts):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: "Kruskal's Algorithm for Minimum Spanning Tree (MST)",
    slug: 'kruskal-algorithm-for-mst',
    description:
      "Use Kruskal's algorithm with Disjoint Set Union (DSU) to compute the cost of the Minimum Spanning Tree (MST) of a graph.",
    problemStatement:
      'You are given an undirected weighted graph with `n` nodes (labeled 0 to n - 1) and a list of `edges`, where `edges[i] = [u, v, weight]` represents an edge between nodes `u` and `v` with a weight `weight`.\n\nReturn the total weight of the Minimum Spanning Tree (MST) using Kruskal’s algorithm.\n\nIf the graph is disconnected, return -1 (MST is not possible).\n\nExamples:\n\n<pre><code>Input: n = 4, edges = [[0,1,1],[0,2,4],[1,2,2],[1,3,6],[2,3,3]]\nOutput: 6\nExplanation: MST includes edges (0-1), (1-2), (2-3) with total weight = 1+2+3 = 6\n</code></pre>\n\n<pre><code>Input: n = 4, edges = [[0,1,1],[2,3,2]]\nOutput: -1\nExplanation: Graph is disconnected.\n</code></pre>\n\n<ul>\n<li>1 &lt;= n &lt;= 10<sup>4</sup></li>\n<li>0 &lt;= edges.length &lt;= 10<sup>5</sup></li>\n<li>0 &lt;= u, v &lt; n</li>\n<li>0 &lt;= weight &lt;= 10<sup>4</sup></li>\n<li>No duplicate edges. Graph may be disconnected.</li>\n</ul>\n\nPro Tip: Sort edges by weight. Use DSU to greedily add edges that connect different components.',
    sampleTestCases: [
      {
        input: '4\n[[0,1,1],[0,2,4],[1,2,2],[1,3,6],[2,3,3]]',
        expected: '6',
      },
      {
        input: '4\n[[0,1,1],[2,3,2]]',
        expected: '-1',
      },
    ],
    testCases: [
      { input: '3\n[[0,1,1],[1,2,2],[0,2,3]]', expected: '3' },
      {
        input: '5\n[[0,1,2],[0,3,6],[1,2,3],[1,3,8],[1,4,5],[2,4,7]]',
        expected: '16',
      },
      { input: '4\n[]', expected: '-1' },
      { input: '2\n[[0,1,5]]', expected: '5' },
      { input: '2\n[]', expected: '-1' },
      { input: '1\n[]', expected: '0' },
      { input: '3\n[[0,1,2],[1,2,3]]', expected: '5' },
      { input: '3\n[[0,1,1],[0,2,1],[1,2,1]]', expected: '2' },
      {
        input: '6\n[[0,1,3],[0,2,1],[1,2,3],[1,3,6],[2,3,4],[3,4,2],[4,5,6]]',
        expected: '16',
      },
      {
        input: '5\n[[0,1,10],[1,2,15],[2,3,4],[3,4,6],[0,4,5]]',
        expected: '25',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You are designing a fiber-optic network between cities. Each connection has a cost. Can you find the cheapest way to connect all cities?',
    categories: 'union-find',
    difficulty: 'medium',
    frequency: 87,
    tags: ['dsu', 'union find', 'kruskal', 'greedy', 'mst'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Sort edges by weight and add them one by one.',
      'Use DSU to detect whether adding an edge forms a cycle.',
      'If all nodes are connected with n - 1 edges, return the total cost.',
    ],
    optimalComplexity: {
      time: 'O(e log e)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [nStr, edgeStr] = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(nStr);\n  const edges = JSON.parse(edgeStr);\n  console.log(kruskalMST(n, edges));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'import sys, json\n\ndef main():\n    n, edgeStr = sys.stdin.read().strip().split("\\n")\n    n = int(n)\n    edges = json.loads(edgeStr)\n    print(kruskalMST(n, edges))\n\nif __name__ == \'__main__\':\n    main()',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function kruskalMST(n, edges) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def kruskalMST(n, edges):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Dijkstra’s Algorithm',
    slug: 'dijkstra-algorithm',
    description:
      "Compute the shortest distances from a source node to all other nodes in a weighted directed graph using Dijkstra's algorithm.",
    problemStatement:
      'You are given a weighted directed graph with `n` nodes numbered from `0` to `n - 1` and a list of `edges`, where `edges[i] = [u, v, w]` means an edge from node `u` to node `v` with weight `w`.\n\nYou are also given a source node `src`. Your task is to return an array of size `n` where the `i`-th element is the shortest distance from `src` to node `i`. If a node is unreachable, return -1 for that node.\n\nUse Dijkstra’s algorithm with a min-heap for optimal efficiency.\n\nExamples:\n\n<pre><code>Input:\nn = 5\nedges = [[0,1,10],[0,2,3],[1,2,1],[2,1,4],[2,3,2],[3,4,7],[4,3,9]]\nsrc = 0\n\nOutput: [0,7,3,5,12]\n</code></pre>\n\n<pre><code>Input:\nn = 3\nedges = [[0,1,5],[1,2,3]]\nsrc = 0\n\nOutput: [0,5,8]\n</code></pre>\n\n<ul>\n<li>1 &lt;= n &lt;= 10<sup>4</sup></li>\n<li>0 &lt;= edges.length &lt;= 10<sup>5</sup></li>\n<li>0 &lt;= u, v &lt; n</li>\n<li>0 &lt;= w &lt;= 1000</li>\n<li>0 &lt;= src &lt; n</li>\n</ul>\n\nPro Tip: Use a priority queue (min-heap) to always explore the node with the current smallest distance.',
    sampleTestCases: [
      {
        input:
          '5\n[[0,1,10],[0,2,3],[1,2,1],[2,1,4],[2,3,2],[3,4,7],[4,3,9]]\n0',
        expected: '[0,7,3,5,12]',
      },
      {
        input: '3\n[[0,1,5],[1,2,3]]\n0',
        expected: '[0,5,8]',
      },
    ],
    testCases: [
      { input: '3\n[[0,1,1],[0,2,4],[1,2,2]]\n0', expected: '[0,1,3]' },
      { input: '4\n[[0,1,1],[1,2,2],[0,3,10]]\n0', expected: '[0,1,3,10]' },
      { input: '3\n[]\n0', expected: '[0,-1,-1]' },
      { input: '2\n[[0,1,100]]\n0', expected: '[0,100]' },
      { input: '2\n[]\n1', expected: '[-1,0]' },
      {
        input: '5\n[[0,1,2],[1,2,4],[2,3,1],[3,4,3]]\n0',
        expected: '[0,2,6,7,10]',
      },
      {
        input: '4\n[[0,1,1],[0,2,5],[1,2,1],[2,3,1]]\n0',
        expected: '[0,1,2,3]',
      },
      {
        input: '6\n[[0,1,2],[1,2,2],[2,3,2],[3,4,2],[4,5,2]]\n0',
        expected: '[0,2,4,6,8,10]',
      },
      { input: '3\n[[0,1,10],[1,2,20]]\n0', expected: '[0,10,30]' },
      { input: '3\n[[1,2,5]]\n0', expected: '[0,-1,-1]' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine building a GPS system that computes the fastest route from a location to all other places in a city. How would you model and solve this using Dijkstra's algorithm?",
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 89,
    tags: ['dijkstra', 'shortest path', 'greedy', 'graph', 'priority queue'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Uber', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Build an adjacency list from the edge list.',
      'Use a priority queue to explore nodes with the shortest known distance.',
      'Update neighbors’ distances only if the new path is shorter.',
    ],
    optimalComplexity: {
      time: 'O((n + e) log n)',
      space: 'O(n + e)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [nStr, edgesStr, srcStr] = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(nStr);\n  const edges = JSON.parse(edgesStr);\n  const src = parseInt(srcStr);\n  const res = dijkstra(n, edges, src);\n  console.log(JSON.stringify(res));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'import sys, json\n\ndef main():\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    edges = json.loads(lines[1])\n    src = int(lines[2])\n    print(json.dumps(dijkstra(n, edges, src)))\n\nif __name__ == \'__main__\':\n    main()',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function dijkstra(n, edges, src) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def dijkstra(n, edges, src):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Bellman-Ford Algorithm',
    slug: 'bellman-ford-algorithm',
    description:
      'Compute shortest paths from a source node to all other nodes in a graph that may contain negative weights using the Bellman-Ford algorithm.',
    problemStatement:
      "You are given a directed weighted graph with `n` vertices (0-indexed) and a list of `edges`, where each edge is represented as `[u, v, weight]`, meaning there's an edge from node `u` to node `v` with weight `weight`.\n\nYou are also given an integer `src`, the source vertex. Your task is to calculate the shortest path distances from the source to every other vertex using the Bellman-Ford algorithm. If any negative weight cycle exists in the graph, return an empty array.\n\nIf a node is unreachable from the source, return -1 for its distance.\n\nExamples:\n\n<pre><code>Input:\nn = 5\nedges = [[0,1,6],[0,3,7],[1,2,5],[1,3,8],[1,4,-4],[2,1,-2],[3,2,-3],[3,4,9],[4,0,2],[4,2,7]]\nsrc = 0\nOutput: [0,2,4,7,-2]\n</code></pre>\n\n<pre><code>Input:\nn = 3\nedges = [[0,1,4],[1,2,-10],[2,0,3]]\nsrc = 0\nOutput: []\nExplanation: Negative weight cycle detected.\n</code></pre>\n\n<ul>\n<li>1 &lt;= n &lt;= 500</li>\n<li>0 &lt;= edges.length &lt;= 10000</li>\n<li>edges[i] = [u, v, weight]</li>\n<li>-1000 &lt;= weight &lt;= 1000</li>\n<li>0 &lt;= u, v &lt; n</li>\n<li>0 &lt;= src &lt; n</li>\n</ul>\n\nPro Tip: Relax all edges `n-1` times and then do one more iteration to detect negative weight cycles.",
    sampleTestCases: [
      {
        input:
          '5\n[[0,1,6],[0,3,7],[1,2,5],[1,3,8],[1,4,-4],[2,1,-2],[3,2,-3],[3,4,9],[4,0,2],[4,2,7]]\n0',
        expected: '[0,2,4,7,-2]',
      },
      {
        input: '3\n[[0,1,4],[1,2,-10],[2,0,3]]\n0',
        expected: '[]',
      },
    ],
    testCases: [
      { input: '2\n[[0,1,3]]\n0', expected: '[0,3]' },
      { input: '3\n[[0,1,5],[1,2,2]]\n0', expected: '[0,5,7]' },
      { input: '3\n[[0,1,2],[1,2,-5],[2,0,1]]\n0', expected: '[]' },
      { input: '4\n[[0,1,1],[1,2,2],[2,3,3]]\n0', expected: '[0,1,3,6]' },
      { input: '4\n[[0,1,4],[1,2,3],[2,3,2],[3,1,-10]]\n0', expected: '[]' },
      { input: '3\n[[0,1,1],[1,2,1]]\n0', expected: '[0,1,2]' },
      { input: '3\n[[1,2,-1]]\n0', expected: '[0,-1,-1]' },
      {
        input:
          '5\n[[0,1,-1],[0,2,4],[1,2,3],[1,3,2],[1,4,2],[3,2,5],[3,1,1],[4,3,-3]]\n0',
        expected: '[0,-1,2,-2,1]',
      },
      { input: '1\n[]\n0', expected: '[0]' },
      { input: '3\n[[0,1,5],[1,2,1],[2,1,-7]]\n0', expected: '[]' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're designing a network router that must handle both positive and negative edge costs. Can your algorithm find all shortest paths and detect routing loops (negative cycles)?",
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 74,
    tags: ['bellman ford', 'shortest path', 'graph', 'negative weight cycle'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Initialize all distances to infinity except the source node.',
      'Relax all edges n - 1 times.',
      'Check for a negative weight cycle by running one more relaxation pass.',
    ],
    optimalComplexity: {
      time: 'O(n * e)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [nStr, edgeStr, srcStr] = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(nStr);\n  const edges = JSON.parse(edgeStr);\n  const src = parseInt(srcStr);\n  const res = bellmanFord(n, edges, src);\n  console.log(JSON.stringify(res));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'import sys, json\n\ndef main():\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    edges = json.loads(lines[1])\n    src = int(lines[2])\n    print(json.dumps(bellmanFord(n, edges, src)))\n\nif __name__ == \'__main__\':\n    main()',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function bellmanFord(n, edges, src) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def bellmanFord(n, edges, src):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Floyd-Warshall Algorithm',
    slug: 'floyd-warshall-algorithm',
    description:
      'Compute all-pairs shortest paths in a weighted directed graph using Floyd-Warshall algorithm.',
    problemStatement:
      'You are given a directed weighted graph with `n` vertices numbered from `0` to `n - 1`. The graph is represented by a list of `edges` where each edge is a triplet `[u, v, w]` meaning there is an edge from `u` to `v` with weight `w`.\n\nYour task is to return a 2D array `dist` where `dist[i][j]` is the shortest distance from node `i` to node `j`. If no path exists, use `Infinity` to represent the unreachable path.\n\nThis problem should be solved using the Floyd-Warshall algorithm.\n\nExamples:\n\n<pre><code>Input:\nn = 4\nedges = [[0,1,5],[0,3,10],[1,2,3],[2,3,1]]\n\nOutput:\n[[0,5,8,9],[Infinity,0,3,4],[Infinity,Infinity,0,1],[Infinity,Infinity,Infinity,0]]\n</code></pre>\n\n<ul>\n<li>1 &lt;= n &lt;= 100</li>\n<li>0 &lt;= edges.length &lt;= n*(n-1)</li>\n<li>0 &lt;= u, v &lt; n</li>\n<li>0 &lt;= w &lt;= 1000</li>\n</ul>\n\nPro Tip: Initialize `dist[i][i] = 0` and update distances using `dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])` for all pairs.',
    sampleTestCases: [
      {
        input: '4\n[[0,1,5],[0,3,10],[1,2,3],[2,3,1]]',
        expected:
          '[[0,5,8,9],[Infinity,0,3,4],[Infinity,Infinity,0,1],[Infinity,Infinity,Infinity,0]]',
      },
    ],
    testCases: [
      {
        input: '3\n[[0,1,1],[1,2,2],[0,2,10]]',
        expected: '[[0,1,3],[Infinity,0,2],[Infinity,Infinity,0]]',
      },
      { input: '2\n[]', expected: '[[0,Infinity],[Infinity,0]]' },
      {
        input: '3\n[[0,1,4],[1,2,1]]',
        expected: '[[0,4,5],[Infinity,0,1],[Infinity,Infinity,0]]',
      },
      { input: '1\n[]', expected: '[[0]]' },
      {
        input: '4\n[[0,1,2],[1,2,3],[2,3,4],[3,0,5]]',
        expected: '[[0,2,5,9],[12,0,3,7],[9,11,0,4],[5,7,10,0]]',
      },
      {
        input: '3\n[[0,1,1],[1,2,-1],[2,0,-1]]',
        expected: '[[0,1,0],[-2,0,-1],[-1,0,0]]',
      },
      { input: '2\n[[0,1,1000]]', expected: '[[0,1000],[Infinity,0]]' },
      {
        input: '3\n[[0,1,5],[1,0,3],[1,2,2]]',
        expected: '[[0,5,7],[3,0,2],[Infinity,Infinity,0]]',
      },
      {
        input: '3\n[[0,1,10],[0,2,3],[2,1,1]]',
        expected: '[[0,4,3],[Infinity,0,Infinity],[Infinity,1,0]]',
      },
      {
        input: '4\n[[0,1,1],[1,2,1],[2,3,1],[3,0,1]]',
        expected: '[[0,1,2,3],[4,0,1,2],[3,4,0,1],[1,2,3,0]]',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're designing a city-wide routing system that needs to show shortest paths between all pairs of intersections. Can you compute this efficiently for all node pairs?",
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 71,
    tags: [
      'floyd warshall',
      'dynamic programming',
      'graph',
      'shortest path',
      'matrix',
    ],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Uber', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      "Initialize dist[i][j] with weight if there's an edge, else Infinity.",
      'Run three nested loops to update dist[i][j] using intermediate nodes.',
      'If you want actual paths too, use a next[i][j] matrix for reconstruction.',
    ],
    optimalComplexity: {
      time: 'O(n^3)',
      space: 'O(n^2)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [nStr, edgeStr] = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(nStr);\n  const edges = JSON.parse(edgeStr);\n  const result = floydWarshall(n, edges);\n  console.log(JSON.stringify(result));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'import sys, json\n\ndef main():\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    edges = json.loads(lines[1])\n    print(json.dumps(floydWarshall(n, edges)))\n\nif __name__ == \'__main__\':\n    main()',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function floydWarshall(n, edges) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def floydWarshall(n, edges):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Shortest Path in Unweighted Graph (0-1 BFS)',
    slug: 'shortest-path-unweighted-graph-0-1-bfs',
    description:
      'Find the shortest path from a source to all nodes in an unweighted or 0-1 weighted graph using 0-1 BFS.',
    problemStatement:
      'You are given a graph with `n` nodes labeled `0` to `n - 1` and a list of directed edges, where each edge is of the form `[u, v, w]` with weight `w`, where `w` is either `0` or `1`.\n\nReturn an array `dist` of size `n`, where `dist[i]` is the shortest distance from the source node `src` to node `i`. If a node is unreachable, the distance should be `-1`.\n\nUse the 0-1 BFS algorithm (deque-based BFS that processes 0-weight edges first) to optimize the traversal.\n\nExamples:\n\n<pre><code>Input:\nn = 5\nedges = [[0,1,0],[0,2,1],[1,2,0],[1,3,1],[2,4,0]]\nsrc = 0\n\nOutput: [0,0,0,1,0]\n</code></pre>\n\n<pre><code>Input:\nn = 4\nedges = [[0,1,0],[1,2,1],[2,3,0]]\nsrc = 0\n\nOutput: [0,0,1,1]\n</code></pre>\n\n<ul>\n<li>1 &lt;= n &lt;= 10<sup>5</sup></li>\n<li>0 &lt;= edges.length &lt;= 2*10<sup>5</sup></li>\n<li>0 &lt;= u, v &lt; n</li>\n<li>w in {0, 1}</li>\n<li>0 &lt;= src &lt; n</li>\n</ul>\n\nPro Tip: Push 0-weight neighbors to the front of the deque and 1-weight neighbors to the back. This ensures shortest distance first.',
    sampleTestCases: [
      {
        input: '5\n[[0,1,0],[0,2,1],[1,2,0],[1,3,1],[2,4,0]]\n0',
        expected: '[0,0,0,1,0]',
      },
      {
        input: '4\n[[0,1,0],[1,2,1],[2,3,0]]\n0',
        expected: '[0,0,1,1]',
      },
    ],
    testCases: [
      { input: '3\n[[0,1,0],[1,2,1]]\n0', expected: '[0,0,1]' },
      { input: '3\n[[0,1,1],[1,2,0]]\n0', expected: '[0,1,1]' },
      { input: '3\n[[0,2,1],[2,1,0]]\n0', expected: '[0,1,1]' },
      { input: '3\n[[1,2,1]]\n0', expected: '[0,-1,-1]' },
      { input: '4\n[[0,1,1],[1,2,1],[2,3,0]]\n0', expected: '[0,1,2,2]' },
      { input: '4\n[[0,1,0],[1,2,0],[2,3,0]]\n0', expected: '[0,0,0,0]' },
      { input: '4\n[[0,1,1],[0,2,0],[2,3,1]]\n0', expected: '[0,1,0,1]' },
      { input: '2\n[[0,1,0]]\n0', expected: '[0,0]' },
      { input: '2\n[]\n0', expected: '[0,-1]' },
      { input: '3\n[[0,1,1],[1,2,1]]\n0', expected: '[0,1,2]' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're designing a system with prioritized message passing where some operations are instant (weight 0) and others delayed (weight 1). Can you efficiently calculate the minimum steps required from the source to all nodes?",
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 76,
    tags: ['0-1 bfs', 'deque', 'graph', 'shortest path', 'greedy'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use a deque for efficient front and back insertion.',
      'Push 0-weight edges to the front to prioritize.',
      'Skip processing if a better distance is already found.',
    ],
    optimalComplexity: {
      time: 'O(n + e)',
      space: 'O(n + e)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [nStr, edgeStr, srcStr] = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(nStr);\n  const edges = JSON.parse(edgeStr);\n  const src = parseInt(srcStr);\n  const res = zeroOneBFS(n, edges, src);\n  console.log(JSON.stringify(res));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'import sys, json\n\ndef main():\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    edges = json.loads(lines[1])\n    src = int(lines[2])\n    print(json.dumps(zeroOneBFS(n, edges, src)))\n\nif __name__ == \'__main__\':\n    main()',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function zeroOneBFS(n, edges, src) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def zeroOneBFS(n, edges, src):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Cheapest Flights Within K Stops',
    slug: 'cheapest-flights-within-k-stops',
    description:
      'Find the cheapest price from a source to destination flight with at most K stops using a modified BFS or Bellman-Ford.',
    problemStatement:
      'You are given `n` cities numbered from `0` to `n-1`, and a list of flights where `flights[i] = [u, v, price]` indicates a flight from city `u` to city `v` with a cost of `price`.\n\nYou are also given two integers `src` and `dst`, and an integer `k`, the maximum number of allowed stops (i.e., you can take at most `k+1` flights).\n\nReturn the cheapest price from `src` to `dst` with at most `k` stops. If no such route exists, return `-1`.\n\nUse a modified BFS or Bellman-Ford traversal.\n\nExamples:\n\n<pre><code>Input:\nn = 4\nflights = [[0,1,100],[1,2,100],[2,3,100],[0,2,500]]\nsrc = 0\ndst = 3\nk = 1\nOutput: 600\n</code></pre>\n\n<pre><code>Input:\nn = 3\nflights = [[0,1,100],[1,2,100],[0,2,500]]\nsrc = 0\ndst = 2\nk = 0\nOutput: 500\n</code></pre>\n\n<ul>\n<li>1 &lt;= n &lt;= 100</li>\n<li>0 &lt;= flights.length &lt;= n * (n - 1)</li>\n<li>flights[i] = [from<sub>i</sub>, to<sub>i</sub>, price<sub>i</sub>]</li>\n<li>from<sub>i</sub>, to<sub>i</sub> ∈ [0, n - 1]</li>\n<li>0 &lt;= price<sub>i</sub> &lt;= 10<sup>4</sup></li>\n<li>0 &lt;= src, dst, k &lt;= n - 1</li>\n</ul>\n\nPro Tip: Use a queue to store (city, cost, stops) and track the shortest cost to each city with a stops limit.',
    sampleTestCases: [
      {
        input: '4\n[[0,1,100],[1,2,100],[2,3,100],[0,2,500]]\n0\n3\n1',
        expected: '600',
      },
      {
        input: '3\n[[0,1,100],[1,2,100],[0,2,500]]\n0\n2\n0',
        expected: '500',
      },
    ],
    testCases: [
      { input: '3\n[[0,1,100],[1,2,100],[0,2,500]]\n0\n2\n1', expected: '200' },
      {
        input:
          '5\n[[0,1,100],[1,2,100],[2,3,100],[3,4,100],[0,2,500]]\n0\n4\n2',
        expected: '-1',
      },
      { input: '3\n[[0,1,100],[1,2,100]]\n0\n2\n1', expected: '200' },
      { input: '3\n[[0,1,100],[1,2,100]]\n0\n2\n0', expected: '-1' },
      {
        input: '4\n[[0,1,1],[0,2,5],[1,2,1],[2,3,1]]\n0\n3\n1',
        expected: '-1',
      },
      { input: '4\n[[0,1,1],[0,2,5],[1,2,1],[2,3,1]]\n0\n3\n2', expected: '3' },
      { input: '2\n[[0,1,100]]\n0\n1\n0', expected: '100' },
      { input: '2\n[[0,1,100]]\n1\n0\n1', expected: '-1' },
      {
        input: '5\n[[0,1,200],[1,2,200],[2,3,200],[3,4,200]]\n0\n4\n3',
        expected: '800',
      },
      { input: '3\n[[0,1,100],[1,0,100],[1,2,100]]\n0\n2\n1', expected: '200' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Suppose you're building a flight booking system. Given flight connections and constraints on stops, can you find the cheapest way to reach your destination?",
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 88,
    tags: ['bfs', 'graph', 'shortest path', 'priority queue', 'bellman ford'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Think of each stop as a level in BFS traversal.',
      'Use a priority queue or queue to explore cheaper paths first.',
      'Track the number of stops and cost to avoid unnecessary paths.',
    ],
    optimalComplexity: {
      time: 'O(k * e)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [nStr, flightStr, srcStr, dstStr, kStr] = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(nStr);\n  const flights = JSON.parse(flightStr);\n  const src = parseInt(srcStr);\n  const dst = parseInt(dstStr);\n  const k = parseInt(kStr);\n  const res = findCheapestPrice(n, flights, src, dst, k);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'import sys, json\n\ndef main():\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    flights = json.loads(lines[1])\n    src = int(lines[2])\n    dst = int(lines[3])\n    k = int(lines[4])\n    print(findCheapestPrice(n, flights, src, dst, k))\n\nif __name__ == \'__main__\':\n    main()',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function findCheapestPrice(n, flights, src, dst, k) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def findCheapestPrice(n, flights, src, dst, k):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Network Delay Time',
    slug: 'network-delay-time',
    description:
      'Determine the time it takes for all nodes to receive a signal from a starting node using Dijkstra’s algorithm.',
    problemStatement:
      "You are given a network of `n` nodes, labeled from `1` to `n`, and a list of travel times `times`, where `times[i] = [u, v, w]` represents a signal that takes `w` time to travel from node `u` to node `v`.\n\nYou are also given an integer `k`, the starting node.\n\nReturn the minimum time it takes for all nodes to receive the signal. If it's impossible for all nodes to receive the signal, return `-1`.\n\nUse Dijkstra’s algorithm with a min-heap (priority queue) for efficient pathfinding.\n\nExamples:\n\n<pre><code>Input:\nn = 4\ntimes = [[2,1,1],[2,3,1],[3,4,1]]\nk = 2\nOutput: 2\n</code></pre>\n\n<pre><code>Input:\nn = 3\ntimes = [[1,2,1]]\nk = 1\nOutput: -1\n</code></pre>\n\n<ul>\n<li>1 &lt;= n &lt;= 100</li>\n<li>1 &lt;= times.length &lt;= 6000</li>\n<li>times[i] = [u, v, w]</li>\n<li>1 &lt;= u, v &lt;= n</li>\n<li>0 &lt;= w &lt;= 100</li>\n<li>1 &lt;= k &lt;= n</li>\n</ul>\n\nPro Tip: Track the shortest time to each node and count how many nodes you can reach. Return the maximum time from the source.",
    sampleTestCases: [
      {
        input: '4\n[[2,1,1],[2,3,1],[3,4,1]]\n2',
        expected: '2',
      },
      {
        input: '3\n[[1,2,1]]\n1',
        expected: '-1',
      },
    ],
    testCases: [
      { input: '3\n[[1,2,1],[2,3,2]]\n1', expected: '3' },
      { input: '2\n[[1,2,1]]\n1', expected: '1' },
      { input: '2\n[[1,2,5],[2,1,5]]\n1', expected: '5' },
      { input: '4\n[[1,2,1],[2,3,2],[1,3,2],[3,4,3]]\n1', expected: '5' },
      { input: '3\n[[1,2,1],[2,3,1],[3,1,1]]\n1', expected: '2' },
      { input: '4\n[[1,2,1],[1,3,4],[2,3,2],[3,4,1]]\n1', expected: '4' },
      { input: '4\n[[1,2,1],[2,3,1],[3,4,1]]\n1', expected: '3' },
      { input: '4\n[[1,2,1],[2,1,1]]\n1', expected: '-1' },
      { input: '5\n[[1,2,2],[1,3,3],[2,4,4],[3,5,5]]\n1', expected: '8' },
      {
        input: '6\n[[1,2,1],[1,3,1],[2,4,1],[3,5,1],[4,6,1],[5,6,1]]\n1',
        expected: '3',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're simulating the time it takes for a signal to propagate across a network. Can you determine how long it takes for all nodes to receive the signal from a given source?",
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 86,
    tags: ['dijkstra', 'graph', 'shortest path', 'priority queue'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use a priority queue to always process the closest unvisited node.',
      'Track the shortest time to each node.',
      'If you can’t reach all nodes, return -1.',
    ],
    optimalComplexity: {
      time: 'O((n + e) log n)',
      space: 'O(n + e)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [nStr, timesStr, kStr] = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(nStr);\n  const times = JSON.parse(timesStr);\n  const k = parseInt(kStr);\n  const res = networkDelayTime(times, n, k);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'import sys, json\n\ndef main():\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    times = json.loads(lines[1])\n    k = int(lines[2])\n    print(networkDelayTime(times, n, k))\n\nif __name__ == \'__main__\':\n    main()',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function networkDelayTime(times, n, k) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def networkDelayTime(times, n, k):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Path with Minimum Effort',
    slug: 'path-with-minimum-effort',
    description:
      'Find a path from the top-left to bottom-right of a grid minimizing the maximum effort between adjacent cells.',
    problemStatement:
      'You are given a 2D grid `heights` where `heights[row][col]` represents the height of the cell at that position. You can move up, down, left, or right to adjacent cells.\n\nThe effort of a path is defined as the maximum absolute difference in heights between two consecutive cells in the path.\n\nReturn the minimum effort required to travel from the top-left cell (0,0) to the bottom-right cell (m-1,n-1).\n\nUse a variation of Dijkstra’s algorithm to always explore the path with the smallest maximum edge cost.\n\nExamples:\n\n<pre><code>Input:\nheights = [[1,2,2],[3,8,2],[5,3,5]]\nOutput: 2\n</code></pre>\n\n<pre><code>Input:\nheights = [[1,2,3],[3,8,4],[5,3,5]]\nOutput: 1\n</code></pre>\n\n<ul>\n<li>rows == heights.length</li>\n<li>cols == heights[i].length</li>\n<li>1 &lt;= rows, cols &lt;= 100</li>\n<li>1 &lt;= heights[i][j] &lt;= 10<sup>6</sup></li>\n</ul>\n\nPro Tip: Use a min-heap to store the next cell to visit based on the current minimum effort to reach it. Update only if the new path improves the max-effort.',
    sampleTestCases: [
      {
        input: '[[1,2,2],[3,8,2],[5,3,5]]',
        expected: '2',
      },
      {
        input: '[[1,2,3],[3,8,4],[5,3,5]]',
        expected: '1',
      },
    ],
    testCases: [
      {
        input: '[[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]',
        expected: '0',
      },
      { input: '[[1,2,1],[3,8,4],[5,3,5]]', expected: '1' },
      { input: '[[1]]', expected: '0' },
      { input: '[[1,1000000]]', expected: '999999' },
      { input: '[[1,2,3],[4,5,6],[7,8,9]]', expected: '1' },
      {
        input:
          '[[10,8,10,10],[10,8,2,10],[10,8,2,10],[10,10,2,10],[10,10,2,10]]',
        expected: '2',
      },
      { input: '[[1,2],[2,3]]', expected: '1' },
      { input: '[[8,6,9],[1,4,5],[7,3,2]]', expected: '4' },
      { input: '[[1,2,3,4,5,6]]', expected: '1' },
      { input: '[[1],[2],[3],[4],[5],[6]]', expected: '1' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're building a mountain hiking app that helps users find a path with the least elevation difficulty. Can you find a path that minimizes the toughest step?",
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 80,
    tags: ['dijkstra', 'grid', 'graph', 'shortest path', 'binary search'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Use Dijkstra-like approach to prioritize cells with lower effort.',
      'Instead of summing distances, track max difference along a path.',
      'Update the effort only if the max effort decreases for that cell.',
    ],
    optimalComplexity: {
      time: 'O(m * n * log(m * n))',
      space: 'O(m * n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const heights = JSON.parse(fs.readFileSync(0, "utf-8").trim());\n  const res = minimumEffortPath(heights);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: "import sys, json\n\ndef main():\n    heights = json.loads(sys.stdin.read().strip())\n    print(minimumEffortPath(heights))\n\nif __name__ == '__main__':\n    main()",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function minimumEffortPath(heights) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def minimumEffortPath(heights):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Minimum Cost to Reach Destination in Grid',
    slug: 'minimum-cost-to-reach-destination-in-grid',
    description:
      'Find the minimum cost path in a grid where each cell has a movement direction that allows free movement and others incur a cost.',
    problemStatement:
      'You are given an `m x n` grid where each cell has a number representing a direction:\n\n- 1 → right\n- 2 → left\n- 3 → down\n- 4 → up\n\nYou can move to any adjacent cell in one of the four directions. If the direction of movement matches the cell’s direction, the cost is 0. Otherwise, the cost is 1.\n\nReturn the minimum cost to reach the bottom-right cell `(m-1, n-1)` from the top-left cell `(0, 0)`.\n\nExamples:\n\n<pre><code>Input:\ngrid = [[1,1,3],[3,2,2],[1,1,4]]\nOutput: 0\n</code></pre>\n\n<pre><code>Input:\ngrid = [[1,1,1,1],[2,2,2,2],[1,1,1,1]]\nOutput: 3\n</code></pre>\n\n<ul>\n<li>1 &lt;= m, n &lt;= 100</li>\n<li>grid[i][j] in {1,2,3,4}</li>\n</ul>\n\nPro Tip: This is a variation of 0-1 BFS. Use a deque and push neighbors with 0 cost to the front and those with cost 1 to the back.',
    sampleTestCases: [
      {
        input: '[[1,1,3],[3,2,2],[1,1,4]]',
        expected: '0',
      },
      {
        input: '[[1,1,1,1],[2,2,2,2],[1,1,1,1]]',
        expected: '3',
      },
    ],
    testCases: [
      { input: '[[1]]', expected: '0' },
      { input: '[[4,4,4],[4,4,4],[4,4,4]]', expected: '4' },
      { input: '[[1,1,1],[1,1,1],[1,1,1]]', expected: '2' },
      { input: '[[3,3,3],[2,2,2],[1,1,1]]', expected: '2' },
      { input: '[[1,2,3],[4,3,2],[1,4,1]]', expected: '2' },
      { input: '[[1,2],[4,3]]', expected: '1' },
      { input: '[[1,1],[3,3]]', expected: '0' },
      { input: '[[2,2,2,2],[2,2,2,2],[2,2,2,2]]', expected: '5' },
      { input: '[[1,1],[2,2]]', expected: '1' },
      { input: '[[1,2,1],[3,2,3],[4,1,4]]', expected: '3' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re optimizing a path on a grid-based robot navigation system where direction hints reduce travel cost. How do you calculate the minimum adjustments needed to reach the goal?',
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 75,
    tags: ['0-1 bfs', 'grid', 'graph', 'deque', 'shortest path'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Each cell provides a free direction of travel.',
      'Use deque to process 0-cost moves before 1-cost ones.',
      'Track visited cells to avoid reprocessing.',
    ],
    optimalComplexity: {
      time: 'O(m * n)',
      space: 'O(m * n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const grid = JSON.parse(fs.readFileSync(0, "utf-8").trim());\n  const res = minCost(grid);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: "import sys, json\n\ndef main():\n    grid = json.loads(sys.stdin.read().strip())\n    print(minCost(grid))\n\nif __name__ == '__main__':\n    main()",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function minCost(grid) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def minCost(grid):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Find City With Smallest Number of Neighbors at Threshold Distance',
    slug: 'find-city-with-smallest-number-of-neighbors-at-threshold-distance',
    description:
      'Given a graph and a distance threshold, return the city with the smallest number of reachable cities within that distance.',
    problemStatement:
      'There are `n` cities numbered from `0` to `n - 1`. You are given an array `edges` where `edges[i] = [u, v, w]` represents a bidirectional road from city `u` to city `v` with distance `w`.\n\nYou are also given an integer `distanceThreshold`. Return the city with the smallest number of neighbors at or below the distance threshold. If there are multiple such cities, return the city with the greatest number.\n\nUse Floyd-Warshall to compute all pairs shortest paths and then compare reachable counts.\n\nExamples:\n\n<pre><code>Input:\nn = 4\nedges = [[0,1,3],[1,2,1],[2,3,4],[0,3,7]]\ndistanceThreshold = 4\nOutput: 3\n</code></pre>\n\n<pre><code>Input:\nn = 5\nedges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]]\ndistanceThreshold = 2\nOutput: 0\n</code></pre>\n\n<ul>\n<li>2 &lt;= n &lt;= 100</li>\n<li>1 &lt;= edges.length &lt;= n * (n - 1) / 2</li>\n<li>edges[i] = [u, v, w]</li>\n<li>0 &lt;= u, v &lt; n</li>\n<li>1 &lt;= w, distanceThreshold &lt;= 10<sup>4</sup></li>\n<li>u != v, no duplicate edges</li>\n</ul>\n\nPro Tip: After building the shortest distance matrix, count how many neighbors each city has with distance less than or equal to the threshold. Prefer higher indexed city in case of tie.',
    sampleTestCases: [
      {
        input: '4\n[[0,1,3],[1,2,1],[2,3,4],[0,3,7]]\n4',
        expected: '3',
      },
      {
        input: '5\n[[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]]\n2',
        expected: '0',
      },
    ],
    testCases: [
      { input: '4\n[[0,1,2],[1,2,2],[2,3,2],[0,3,10]]\n5', expected: '0' },
      { input: '3\n[[0,1,1],[1,2,1],[0,2,2]]\n1', expected: '2' },
      {
        input: '6\n[[0,1,3],[1,2,1],[2,3,1],[3,4,1],[4,5,1]]\n2',
        expected: '5',
      },
      { input: '5\n[[0,1,10],[1,2,10],[2,3,10],[3,4,10]]\n20', expected: '4' },
      { input: '4\n[[0,1,1],[1,2,1],[2,3,1]]\n2', expected: '3' },
      { input: '4\n[[0,1,2],[1,2,2],[2,3,2],[3,0,2]]\n2', expected: '3' },
      { input: '2\n[[0,1,1]]\n1', expected: '1' },
      { input: '2\n[[0,1,10]]\n5', expected: '1' },
      { input: '3\n[[0,1,3],[1,2,3],[0,2,1]]\n2', expected: '2' },
      {
        input: '5\n[[0,1,1],[1,2,1],[2,3,1],[3,4,1],[0,4,10]]\n3',
        expected: '0',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You’re analyzing a transportation network and want to identify which city has the least number of reachable cities within a distance threshold. Can you compute that efficiently?',
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 82,
    tags: ['floyd warshall', 'graph', 'shortest path', 'matrix'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Uber', logoUrl: '' },
    ],
    hints: [
      'Use Floyd-Warshall to find all pairs shortest path.',
      'Count reachable cities for each node using the distance threshold.',
      'In case of tie, return city with higher index.',
    ],
    optimalComplexity: {
      time: 'O(n^3)',
      space: 'O(n^2)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [nStr, edgeStr, thresholdStr] = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const n = parseInt(nStr);\n  const edges = JSON.parse(edgeStr);\n  const threshold = parseInt(thresholdStr);\n  const res = findTheCity(n, edges, threshold);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: 'import sys, json\n\ndef main():\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    edges = json.loads(lines[1])\n    threshold = int(lines[2])\n    print(findTheCity(n, edges, threshold))\n\nif __name__ == \'__main__\':\n    main()',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function findTheCity(n, edges, distanceThreshold) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def findTheCity(n, edges, distanceThreshold):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Number of Islands',
    slug: 'number-of-islands',
    description: 'Count the number of islands in a 2D grid using DFS or BFS.',
    problemStatement:
      'You are given an `m x n` 2D binary grid `grid` representing a map of `\'1\'`s (land) and `\'0\'`s (water). An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water.\n\nReturn the number of islands.\n\nUse Depth-First Search (DFS), Breadth-First Search (BFS), or Union-Find to solve this efficiently.\n\nExamples:\n\n<pre><code>Input:\ngrid = [\n  ["1","1","1","1","0"],\n  ["1","1","0","1","0"],\n  ["1","1","0","0","0"],\n  ["0","0","0","0","0"]\n]\nOutput: 1\n</code></pre>\n\n<pre><code>Input:\ngrid = [\n  ["1","1","0","0","0"],\n  ["1","1","0","0","0"],\n  ["0","0","1","0","0"],\n  ["0","0","0","1","1"]\n]\nOutput: 3\n</code></pre>\n\n<ul>\n<li>m == grid.length</li>\n<li>n == grid[i].length</li>\n<li>1 &lt;= m, n &lt;= 300</li>\n<li>grid[i][j] is \'0\' or \'1\'</li>\n</ul>\n\nPro Tip: When you find a land cell, perform DFS or BFS to mark all its connected land as visited.',
    sampleTestCases: [
      {
        input:
          '[["1","1","1","1","0"],["1","1","0","1","0"],["1","1","0","0","0"],["0","0","0","0","0"]]',
        expected: '1',
      },
      {
        input:
          '[["1","1","0","0","0"],["1","1","0","0","0"],["0","0","1","0","0"],["0","0","0","1","1"]]',
        expected: '3',
      },
    ],
    testCases: [
      { input: '[["1","0","1","0"]]', expected: '2' },
      { input: '[["1","1","1"],["0","1","0"],["1","1","1"]]', expected: '1' },
      { input: '[["0","0","0"],["0","0","0"]]', expected: '0' },
      { input: '[["1"]]', expected: '1' },
      { input: '[["0"]]', expected: '0' },
      { input: '[["1","1"],["1","0"]]', expected: '1' },
      { input: '[["1","0","1","1","0","1","1"]]', expected: '3' },
      { input: '[["1"],["0"],["1"],["0"]]', expected: '2' },
      { input: '[["1","1"],["1","1"]]', expected: '1' },
      { input: '[["1","0"],["0","1"]]', expected: '2' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're given a satellite image of a landmass. Can you count how many distinct landmasses (islands) are present?",
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 95,
    tags: ['dfs', 'bfs', 'union find', 'grid', 'matrix'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use DFS or BFS to mark all connected land.',
      'Remember to avoid revisiting already visited land cells.',
      'Union-Find can be used for efficient merging of components.',
    ],
    optimalComplexity: {
      time: 'O(m * n)',
      space: 'O(m * n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const grid = JSON.parse(fs.readFileSync(0, "utf-8").trim());\n  const res = numIslands(grid);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: "import sys, json\n\ndef main():\n    grid = json.loads(sys.stdin.read().strip())\n    print(numIslands(grid))\n\nif __name__ == '__main__':\n    main()",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function numIslands(grid) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def numIslands(grid):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Max Area of Island',
    slug: 'max-area-of-island',
    description: 'Return the maximum area of an island in a 2D binary grid.',
    problemStatement:
      "You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (land) connected 4-directionally (horizontal or vertical). You may assume all four edges of the grid are surrounded by water.\n\nReturn the area of the largest island in the grid. If there is no island, return 0.\n\nYou can use DFS or BFS to explore each island and track its area.\n\nExamples:\n\n<pre><code>Input:\ngrid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\nOutput: 6\n</code></pre>\n\n<pre><code>Input:\ngrid = [[0,0,0,0,0,0,0,0]]\nOutput: 0\n</code></pre>\n\n<ul>\n<li>m == grid.length</li>\n<li>n == grid[i].length</li>\n<li>1 &lt;= m, n &lt;= 50</li>\n<li>grid[i][j] is either 0 or 1</li>\n</ul>\n\nPro Tip: For every unvisited land cell, explore its entire connected component to count its area, and update the maximum.",
    sampleTestCases: [
      {
        input:
          '[[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]',
        expected: '6',
      },
      {
        input: '[[0,0,0,0,0,0,0,0]]',
        expected: '0',
      },
    ],
    testCases: [
      { input: '[[1]]', expected: '1' },
      { input: '[[0]]', expected: '0' },
      {
        input: '[[1,1,0,0,0],[1,1,0,0,0],[0,0,1,0,0],[0,0,0,1,1]]',
        expected: '4',
      },
      { input: '[[0,0,0,0]]', expected: '0' },
      { input: '[[1,1,1,1]]', expected: '4' },
      { input: '[[1,0,1,0,1,0]]', expected: '1' },
      { input: '[[1,1],[1,0]]', expected: '3' },
      { input: '[[0,1,0],[1,1,1],[0,1,0]]', expected: '5' },
      { input: '[[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]]', expected: '4' },
      { input: '[[1,0,0,1],[0,1,1,0],[1,1,0,0],[0,0,1,1]]', expected: '4' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're given a map of islands. Can you find the largest contiguous area of land?",
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 88,
    tags: ['dfs', 'bfs', 'grid', 'matrix'],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Bloomberg', logoUrl: '' },
    ],
    hints: [
      'Use DFS or BFS to explore the island from each unvisited land cell.',
      'Track the size of each connected component.',
      'Compare and keep track of the max size found.',
    ],
    optimalComplexity: {
      time: 'O(m * n)',
      space: 'O(m * n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const grid = JSON.parse(fs.readFileSync(0, "utf-8").trim());\n  const res = maxAreaOfIsland(grid);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: "import sys, json\n\ndef main():\n    grid = json.loads(sys.stdin.read().strip())\n    print(maxAreaOfIsland(grid))\n\nif __name__ == '__main__':\n    main()",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function maxAreaOfIsland(grid) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def maxAreaOfIsland(grid):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Surrounded Regions',
    slug: 'surrounded-regions',
    description:
      "Capture all regions surrounded by 'X' by flipping surrounded 'O's to 'X'.",
    problemStatement:
      'Given an `m x n` board containing `X` and `O`, capture all regions surrounded by `X`. A region is captured by flipping all `O`s into `X`s in that surrounded region.\n\nA region is considered surrounded if there are no `O`s connected to the border of the grid (i.e., top, bottom, left, or right edge).\n\nTo solve this, mark all `O`s connected to borders first (they cannot be flipped), then flip the rest.\n\nExamples:\n\n<pre><code>Input:\nboard = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]\nOutput: [["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]\n</code></pre>\n\n<pre><code>Input:\nboard = [["X"]]\nOutput: [["X"]]\n</code></pre>\n\n<ul>\n<li>m == board.length</li>\n<li>n == board[i].length</li>\n<li>1 &lt;= m, n &lt;= 200</li>\n<li>board[i][j] is \'X\' or \'O\'</li>\n</ul>\n\nPro Tip: Traverse all border cells and perform DFS/BFS for every border \'O\'. Mark connected \'O\'s with a temp symbol, then restore them while flipping the others.',
    sampleTestCases: [
      {
        input:
          '[["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]',
        expected:
          '[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]',
      },
      {
        input: '[["X"]]',
        expected: '[["X"]]',
      },
    ],
    testCases: [
      { input: '[["O"]]', expected: '[["O"]]' },
      { input: '[["O","O"],["O","O"]]', expected: '[["O","O"],["O","O"]]' },
      {
        input: '[["X","O","X"],["O","O","O"],["X","O","X"]]',
        expected: '[["X","O","X"],["O","O","O"],["X","O","X"]]',
      },
      {
        input: '[["X","X","X"],["X","O","X"],["X","X","X"]]',
        expected: '[["X","X","X"],["X","X","X"],["X","X","X"]]',
      },
      {
        input: '[["X","O","X"],["X","O","X"],["X","O","X"]]',
        expected: '[["X","O","X"],["X","O","X"],["X","O","X"]]',
      },
      {
        input:
          '[["X","O","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]',
        expected:
          '[["X","O","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]',
      },
      {
        input:
          '[["O","X","X","O","X"],["X","O","O","X","O"],["X","O","X","O","X"],["O","X","O","O","O"],["X","X","O","X","O"]]',
        expected:
          '[["O","X","X","O","X"],["X","X","X","X","O"],["X","X","X","O","X"],["O","X","O","O","O"],["X","X","O","X","O"]]',
      },
      {
        input: '[["O","O","O","O"],["O","O","O","O"],["O","O","O","O"]]',
        expected: '[["O","O","O","O"],["O","O","O","O"],["O","O","O","O"]]',
      },
      {
        input:
          '[["O","X","O","X"],["X","O","X","O"],["O","X","O","X"],["X","O","X","O"]]',
        expected:
          '[["O","X","O","X"],["X","O","X","O"],["O","X","O","X"],["X","O","X","O"]]',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine a game board where any enclosed group of 'O's should be converted to 'X'. Can you identify and flip all the surrounded regions?",
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 79,
    tags: ['dfs', 'bfs', 'matrix', 'graph', 'union find'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      "Start from border cells and mark all connected 'O's.",
      "Use a special marker (like 'T') during traversal.",
      "Flip remaining 'O's to 'X' and marked cells back to 'O'.",
    ],
    optimalComplexity: {
      time: 'O(m * n)',
      space: 'O(m * n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const board = JSON.parse(fs.readFileSync(0, "utf-8").trim());\n  solve(board);\n  console.log(JSON.stringify(board));\n}\nmain();',
      },
      {
        language: 'python',
        code: "import sys, json\n\ndef main():\n    board = json.loads(sys.stdin.read().strip())\n    solve(board)\n    print(json.dumps(board))\n\nif __name__ == '__main__':\n    main()",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function solve(board) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def solve(board):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Pacific Atlantic Water Flow',
    slug: 'pacific-atlantic-water-flow',
    description:
      'Find cells in a matrix where water can flow to both the Pacific and Atlantic oceans.',
    problemStatement:
      'Given an `m x n` matrix of non-negative integers representing the height of each unit cell in a continent, determine the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.\n\nWater can only flow from a cell to another one with equal or lower height in one of the four directions (up, down, left, right).\n\nThe Pacific ocean touches the left and top edges of the matrix, while the Atlantic ocean touches the right and bottom edges.\n\nReturn the list of coordinates where water can flow to both oceans.\n\nExamples:\n\n<pre><code>Input:\nheights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n</code></pre>\n\n<pre><code>Input:\nheights = [[1]]\nOutput: [[0,0]]\n</code></pre>\n\n<ul>\n<li>m == heights.length</li>\n<li>n == heights[i].length</li>\n<li>1 &lt;= m, n &lt;= 200</li>\n<li>0 &lt;= heights[i][j] &lt;= 10<sup>5</sup></li>\n</ul>\n\nPro Tip: Start BFS/DFS from all Pacific-border and Atlantic-border cells. Mark reachable cells from both sides and find their intersection.',
    sampleTestCases: [
      {
        input: '[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]',
        expected: '[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]',
      },
      {
        input: '[[1]]',
        expected: '[[0,0]]',
      },
    ],
    testCases: [
      {
        input: '[[10,10,10],[10,1,10],[10,10,10]]',
        expected: '[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]',
      },
      {
        input: '[[1,2,3],[8,9,4],[7,6,5]]',
        expected: '[[0,2],[1,2],[2,0],[2,1],[2,2]]',
      },
      {
        input: '[[1,1],[1,1],[1,1]]',
        expected: '[[0,0],[0,1],[1,0],[1,1],[2,0],[2,1]]',
      },
      { input: '[[1,2],[4,3]]', expected: '[[0,1],[1,0],[1,1]]' },
      { input: '[[2,1],[1,2]]', expected: '[[0,0],[0,1],[1,0],[1,1]]' },
      {
        input: '[[3,3,3],[3,1,3],[3,3,3]]',
        expected: '[[0,0],[0,1],[0,2],[1,0],[1,2],[2,0],[2,1],[2,2]]',
      },
      {
        input: '[[2,2,2,2],[2,1,1,2],[2,1,1,2],[2,2,2,2]]',
        expected:
          '[[0,0],[0,1],[0,2],[0,3],[1,0],[1,3],[2,0],[2,3],[3,0],[3,1],[3,2],[3,3]]',
      },
      {
        input: '[[5,3,2],[6,1,4],[7,8,9]]',
        expected: '[[0,0],[0,1],[0,2],[1,0],[2,0],[2,1],[2,2]]',
      },
      {
        input: '[[1,2,3],[4,5,6],[7,8,9]]',
        expected: '[[0,2],[1,2],[2,0],[2,1],[2,2]]',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Can you find the cells from which water can flow to both the Pacific and Atlantic oceans, considering only downward or equal-height flow?',
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 90,
    tags: ['dfs', 'bfs', 'matrix', 'graph', 'water flow'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Start BFS/DFS from all Pacific and Atlantic edge cells.',
      'Mark which cells can reach each ocean.',
      'Return the intersection of those reachable cells.',
    ],
    optimalComplexity: {
      time: 'O(m * n)',
      space: 'O(m * n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const heights = JSON.parse(fs.readFileSync(0, "utf-8").trim());\n  const res = pacificAtlantic(heights);\n  console.log(JSON.stringify(res));\n}\nmain();',
      },
      {
        language: 'python',
        code: "import sys, json\n\ndef main():\n    heights = json.loads(sys.stdin.read().strip())\n    res = pacificAtlantic(heights)\n    print(json.dumps(res))\n\nif __name__ == '__main__':\n    main()",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function pacificAtlantic(heights) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def pacificAtlantic(heights):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Rotting Oranges',
    slug: 'rotting-oranges',
    description:
      'Determine the minimum time required to rot all oranges in a grid using BFS.',
    problemStatement:
      'You are given an `m x n` grid where each cell can have one of three values:\n\n- `0` representing an empty cell,\n- `1` representing a fresh orange,\n- `2` representing a rotten orange.\n\nEvery minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.\n\nReturn the minimum number of minutes that must elapse until no fresh orange remains. If this is impossible, return `-1`.\n\nExamples:\n\n<pre><code>Input:\ngrid = [[2,1,1],[1,1,0],[0,1,1]]\nOutput: 4\n</code></pre>\n\n<pre><code>Input:\ngrid = [[2,1,1],[0,1,1],[1,0,1]]\nOutput: -1\n</code></pre>\n\n<ul>\n<li>m == grid.length</li>\n<li>n == grid[i].length</li>\n<li>1 &lt;= m, n &lt;= 10</li>\n<li>grid[i][j] is 0, 1, or 2</li>\n</ul>\n\nPro Tip: Use BFS to propagate the rot from all initial rotten oranges. Track time with levels of BFS traversal.',
    sampleTestCases: [
      {
        input: '[[2,1,1],[1,1,0],[0,1,1]]',
        expected: '4',
      },
      {
        input: '[[2,1,1],[0,1,1],[1,0,1]]',
        expected: '-1',
      },
    ],
    testCases: [
      { input: '[[0]]', expected: '0' },
      { input: '[[2]]', expected: '0' },
      { input: '[[1]]', expected: '-1' },
      { input: '[[1,2]]', expected: '1' },
      { input: '[[2,1,1],[1,1,1],[0,1,2]]', expected: '2' },
      { input: '[[2,2,2],[2,2,2],[2,2,2]]', expected: '0' },
      { input: '[[1,1,1],[1,1,1],[1,1,1]]', expected: '-1' },
      { input: '[[2,1,1],[1,1,1],[0,1,2]]', expected: '2' },
      { input: '[[2,1,1],[0,1,1],[0,1,1]]', expected: '4' },
      { input: '[[2,0,1],[1,0,1],[0,1,2]]', expected: '2' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "You're modeling the spread of a virus in a grid of oranges. How long does it take to infect every orange, or is it impossible?",
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 92,
    tags: ['bfs', 'matrix', 'graph', 'multi-source bfs'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Apple', logoUrl: '' },
      { name: 'Google', logoUrl: '' },
    ],
    hints: [
      'Use BFS starting from all initially rotten oranges.',
      'Track minutes as BFS levels.',
      'Check if any fresh oranges remain at the end.',
    ],
    optimalComplexity: {
      time: 'O(m * n)',
      space: 'O(m * n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const grid = JSON.parse(fs.readFileSync(0, "utf-8").trim());\n  const res = orangesRotting(grid);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: "import sys, json\n\ndef main():\n    grid = json.loads(sys.stdin.read().strip())\n    print(orangesRotting(grid))\n\nif __name__ == '__main__':\n    main()",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function orangesRotting(grid) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def orangesRotting(grid):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Word Ladder',
    slug: 'word-ladder',
    description:
      'Find the shortest transformation sequence from beginWord to endWord, changing one letter at a time.',
    problemStatement:
      'Given two words `beginWord` and `endWord`, and a dictionary `wordList`, return the length of the shortest transformation sequence from `beginWord` to `endWord`, such that:\n\n1. Only one letter can be changed at a time.\n2. Each transformed word must exist in the word list.\n\nReturn `0` if no such sequence exists.\n\nExamples:\n\n<pre><code>Input:\nbeginWord = "hit"\nendWord = "cog"\nwordList = ["hot","dot","dog","lot","log","cog"]\nOutput: 5\nExplanation: "hit" → "hot" → "dot" → "dog" → "cog"\n</code></pre>\n\n<pre><code>Input:\nbeginWord = "hit"\nendWord = "cog"\nwordList = ["hot","dot","dog","lot","log"]\nOutput: 0\nExplanation: "cog" is not in wordList, so no transformation.\n</code></pre>\n\n<ul>\n<li>1 &lt;= beginWord.length == endWord.length &lt;= 10</li>\n<li>1 &lt;= wordList.length &lt;= 5000</li>\n<li>wordList[i] and beginWord, endWord consist of lowercase English letters.</li>\n<li>beginWord != endWord</li>\n</ul>\n\nPro Tip: Use BFS to explore the word transformation graph and find the shortest path.',
    sampleTestCases: [
      {
        input: 'hit\ncog\n["hot","dot","dog","lot","log","cog"]',
        expected: '5',
      },
      {
        input: 'hit\ncog\n["hot","dot","dog","lot","log"]',
        expected: '0',
      },
    ],
    testCases: [
      { input: 'a\nc\n["a","b","c"]', expected: '2' },
      { input: 'hit\nhot\n["hot"]', expected: '2' },
      {
        input: 'hit\ncog\n["hot","dot","dog","lot","log","cog"]',
        expected: '5',
      },
      { input: 'hit\ncog\n["hot","dot","dog","lot","log"]', expected: '0' },
      {
        input: 'lost\ncost\n["most","fist","lost","cost","fish"]',
        expected: '2',
      },
      {
        input: 'game\nmath\n["fame","fate","gate","mate","math"]',
        expected: '5',
      },
      {
        input: 'toon\nplea\n["poon","plee","same","poie","plea","plie","poin"]',
        expected: '7',
      },
      {
        input: 'talk\ntail\n["talk","tons","fall","tail","gale","hall","negs"]',
        expected: '0',
      },
      {
        input: 'red\ntax\n["ted","tex","red","tax","tad","den","rex","pee"]',
        expected: '4',
      },
      {
        input: 'leet\ncode\n["lest","leet","lose","code","lode","robe","lost"]',
        expected: '6',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Given a dictionary and a start/end word, find the shortest word transformation sequence. This is a classic BFS problem on a word graph.',
    categories: 'graphs',
    difficulty: 'hard',
    frequency: 93,
    tags: ['bfs', 'word graph', 'shortest path'],
    companies: [
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
    ],
    hints: [
      'Use BFS starting from the beginWord.',
      'Preprocess wordList to map generic patterns (e.g., h*t).',
      'Track visited words to avoid cycles.',
    ],
    optimalComplexity: {
      time: 'O(N * M^2)',
      space: 'O(N * M)',
      note: 'N = number of words, M = word length',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [beginWord, endWord, listStr] = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const wordList = JSON.parse(listStr);\n  const res = ladderLength(beginWord, endWord, wordList);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: "import sys, json\n\ndef main():\n    beginWord = sys.stdin.readline().strip()\n    endWord = sys.stdin.readline().strip()\n    wordList = json.loads(sys.stdin.readline().strip())\n    print(ladderLength(beginWord, endWord, wordList))\n\nif __name__ == '__main__':\n    main()",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function ladderLength(beginWord, endWord, wordList) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def ladderLength(beginWord, endWord, wordList):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Graph Coloring Problem',
    slug: 'graph-coloring-problem',
    description:
      'Assign colors to vertices of a graph such that no two adjacent vertices have the same color.',
    problemStatement:
      'Given an undirected graph and an integer `m`, determine if it is possible to color all vertices using at most `m` colors such that no two adjacent vertices share the same color.\n\nYou are given the graph as an adjacency matrix `graph` of size `n x n` and an integer `m`. Return `true` if the graph can be colored using `m` colors without any adjacent vertices having the same color; otherwise, return `false`.\n\nExamples:\n\n<pre><code>Input:\nm = 3\ngraph = [\n [0,1,1,1],\n [1,0,1,0],\n [1,1,0,1],\n [1,0,1,0]\n]\nOutput: true\nExplanation: One possible coloring is [1, 2, 3, 2].\n</code></pre>\n\n<pre><code>Input:\nm = 2\ngraph = [\n [0,1,1,1],\n [1,0,1,0],\n [1,1,0,1],\n [1,0,1,0]\n]\nOutput: false\n</code></pre>\n\n<ul>\n<li>1 &lt;= n &lt;= 20</li>\n<li>1 &lt;= m &lt;= n</li>\n<li>graph[i][j] is 0 or 1</li>\n<li>graph[i][i] == 0 (no self-loops)</li>\n<li>graph[i][j] == graph[j][i] (undirected)</li>\n</ul>\n\nPro Tip: Use backtracking to try all possible color assignments while ensuring adjacent vertices do not get the same color.',
    sampleTestCases: [
      {
        input: '3\n[[0,1,1,1],[1,0,1,0],[1,1,0,1],[1,0,1,0]]',
        expected: 'true',
      },
      {
        input: '2\n[[0,1,1,1],[1,0,1,0],[1,1,0,1],[1,0,1,0]]',
        expected: 'false',
      },
    ],
    testCases: [
      { input: '3\n[[0,1,0],[1,0,1],[0,1,0]]', expected: 'true' },
      { input: '2\n[[0,1,0],[1,0,1],[0,1,0]]', expected: 'false' },
      {
        input: '4\n[[0,1,1,1],[1,0,1,1],[1,1,0,1],[1,1,1,0]]',
        expected: 'true',
      },
      { input: '3\n[[0,1,1],[1,0,1],[1,1,0]]', expected: 'false' },
      { input: '1\n[[0]]', expected: 'true' },
      { input: '2\n[[0,1],[1,0]]', expected: 'true' },
      { input: '2\n[[0,1,1],[1,0,1],[1,1,0]]', expected: 'false' },
      { input: '3\n[[0,1,1],[1,0,1],[1,1,0]]', expected: 'true' },
      { input: '2\n[[0,0,0],[0,0,0],[0,0,0]]', expected: 'true' },
      {
        input:
          '3\n[[0,1,1,1,0],[1,0,1,0,1],[1,1,0,1,1],[1,0,1,0,0],[0,1,1,0,0]]',
        expected: 'true',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      "Imagine you're tasked with scheduling exams where each course must have a unique time slot if they share students. Can you determine if it's possible to assign only m time slots?",
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 74,
    tags: ['backtracking', 'graph coloring', 'constraint satisfaction'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
    ],
    hints: [
      'Use backtracking to assign colors one by one.',
      'Check all adjacent vertices before assigning a color.',
      'If you reach the last vertex successfully, the graph is colorable.',
    ],
    optimalComplexity: {
      time: 'O(m^n)',
      space: 'O(n)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [mStr, graphStr] = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const m = parseInt(mStr);\n  const graph = JSON.parse(graphStr);\n  const res = graphColoring(graph, m);\n  console.log(res);\n}\nmain();',
      },
      {
        language: 'python',
        code: "import sys, json\n\ndef main():\n    m = int(sys.stdin.readline())\n    graph = json.loads(sys.stdin.read().strip())\n    print(graphColoring(graph, m))\n\nif __name__ == '__main__':\n    main()",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function graphColoring(graph, m) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def graphColoring(graph, m):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Snake and Ladder - Minimum Dice Throws',
    slug: 'snake-and-ladder-minimum-dice-throws',
    description:
      'Find the minimum number of dice throws required to reach the last cell in a Snake and Ladder board using BFS.',
    problemStatement:
      "You are given a game board represented as an `n x n` grid of size `n²` (cells numbered 1 to n² in a boustrophedon pattern). You can throw a die (1 to 6) to move forward. If you land on a square that has the start of a ladder or the mouth of a snake, you must move to its destination immediately (up or down).\n\nFind the **minimum number of dice throws** required to reach the final cell (n²) starting from cell 1. If it's not possible, return `-1`.\n\nExamples:\n\n<pre><code>Input:\nn = 10\nsnakes = [[17,7],[54,34],[62,19],[64,60],[87,36],[93,73],[95,75],[98,79]]\nladders = [[1,38],[4,14],[9,31],[21,42],[28,84],[51,67],[72,91],[80,99]]\nOutput: 7\n</code></pre>\n\n<ul>\n<li>2 ≤ n ≤ 100 (board size)</li>\n<li>Board has `n²` cells numbered from 1 to n².</li>\n<li>`snakes` and `ladders` are lists of pairs `[start, end]` where start ≠ end and within [1, n²].</li>\n<li>No two snakes or ladders start at the same cell.</li>\n</ul>\n\nPro Tip: Model the board as a graph with `n²` nodes. Each dice roll (1–6) creates an edge, potentially redirected by a snake or ladder. Use **Breadth‑First Search (BFS)** to find the shortest path (minimum moves) from the start to the end cell.",
    sampleTestCases: [
      {
        input:
          '10\n[[17,7],[54,34],[62,19],[64,60],[87,36],[93,73],[95,75],[98,79]]\n[[1,38],[4,14],[9,31],[21,42],[28,84],[51,67],[72,91],[80,99]]',
        expected: '7',
      },
      {
        input: '10\n[]\n[]',
        expected: '17',
      },
    ],
    testCases: [
      { input: '5\n[[14,4]]\n[[3,22]]', expected: '3' },
      { input: '6\n[[27,5],[35,12]]\n[[2,25],[14,40]]', expected: '-1' },
      { input: '3\n[]\n[[2,9]]', expected: '2' },
      { input: '4\n[[5,2]]\n[[3,11],[8,16]]', expected: '3' },
      { input: '3\n[[8,4]]\n[]', expected: '2' },
      { input: '6\n[]\n[[5,15],[20,30]]', expected: 'n/a' }, // invalid ladder beyond board
      { input: '2\n[]\n[]', expected: '1' },
      { input: '10\n[[16,8]]\n[[5,45]]', expected: '-1' },
      { input: '3\n[[6,2]]\n[[1,9]]', expected: '1' },
      { input: '4\n[[10,2],[12,6]]\n[[3,15],[7,14]]', expected: '3' },
    ],
    topics: ['graph', 'bfs', 'shortest path'],
    interviewExcerpt:
      'Think of the Snake and Ladder board as a graph where each move (1–6 dice throw) is an edge—with instant jumps from snakes or ladders. Can you find the minimum throws to win using BFS?',
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 80,
    tags: ['bfs', 'graph modeling', 'board game'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Build a `move[]` array of size n² + 1 initialized to -1, representing displacement for each cell.',
      'Perform BFS from cell 1; for each roll, check `move[next]` to find where you effectively land.',
      'Stop BFS early when you reach n².',
    ],
    optimalComplexity: {
      time: 'O(n²)',
      space: 'O(n²)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: 'customDSAGpt',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [nStr, snakesStr, laddersStr] = fs.readFileSync(0, "utf‑8").trim().split("\\n");\n  const n = parseInt(nStr);\n  const snakes = JSON.parse(snakesStr);\n  const ladders = JSON.parse(laddersStr);\n  console.log(minDiceThrows(n, snakes, ladders));\n}\nmain();',
      },
      {
        language: 'python',
        code: 'import sys, json\n\ndef main():\n    lines = sys.stdin.read().strip().split("\\n")\n    n = int(lines[0])\n    snakes = json.loads(lines[1])\n    ladders = json.loads(lines[2])\n    print(min_dice_throws(n, snakes, ladders))\n\nif __name__ == \'__main__\':\n    main()',
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function minDiceThrows(n, snakes, ladders) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def min_dice_throws(n, snakes, ladders):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Minimum Steps to Reach Target by a Knight',
    slug: 'minimum-steps-to-reach-target-by-a-knight',
    description:
      'Find the minimum number of steps a knight needs to reach a target position on an N x N chessboard.',
    problemStatement:
      "Given the size of a chessboard `N x N`, a knight's starting position, and a target position, determine the minimum number of steps the knight must take to reach the target.\n\nThe knight moves in an L-shape (two squares in one direction and then one square perpendicular to that):\n- (±2, ±1) or (±1, ±2).\n\nReturn the minimum number of moves required. If the target can't be reached, return `-1`.\n\nExamples:\n\n<pre><code>Input:\nN = 8\nstart = [0, 0]\ntarget = [7, 7]\nOutput: 6\n</code></pre>\n\n<pre><code>Input:\nN = 8\nstart = [0, 0]\ntarget = [1, 2]\nOutput: 1\n</code></pre>\n\n<ul>\n<li>1 &lt;= N &lt;= 1000</li>\n<li>start and target are [x, y] where 0 &lt;= x, y &lt; N</li>\n<li>All positions are valid on the board</li>\n</ul>\n\nPro Tip: Use Breadth-First Search (BFS) starting from the knight's position to find the shortest path to the target.",
    sampleTestCases: [
      {
        input: '8\n[0,0]\n[7,7]',
        expected: '6',
      },
      {
        input: '8\n[0,0]\n[1,2]',
        expected: '1',
      },
    ],
    testCases: [
      { input: '8\n[0,0]\n[2,1]', expected: '1' },
      { input: '8\n[0,0]\n[3,3]', expected: '2' },
      { input: '8\n[0,0]\n[4,5]', expected: '3' },
      { input: '8\n[0,0]\n[7,6]', expected: '5' },
      { input: '8\n[7,7]\n[0,0]', expected: '6' },
      { input: '1\n[0,0]\n[0,0]', expected: '0' },
      { input: '4\n[0,0]\n[3,3]', expected: '4' },
      { input: '10\n[5,5]\n[9,9]', expected: '4' },
      { input: '6\n[2,2]\n[5,5]', expected: '2' },
      { input: '1000\n[0,0]\n[999,999]', expected: '666' },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'Imagine you are playing chess and want to calculate the shortest number of moves for your knight to reach a particular cell on an N x N board.',
    categories: 'graphs',
    difficulty: 'medium',
    frequency: 77,
    tags: ['bfs', 'matrix', 'graph', 'shortest path'],
    companies: [
      { name: 'Amazon', logoUrl: '' },
      { name: 'Microsoft', logoUrl: '' },
      { name: 'Flipkart', logoUrl: '' },
    ],
    hints: [
      'Model the board as a grid and use BFS for shortest path.',
      'Keep track of visited cells to avoid loops.',
      'There are 8 possible knight moves from any position.',
    ],
    optimalComplexity: {
      time: 'O(N^2)',
      space: 'O(N^2)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const [nStr, startStr, targetStr] = fs.readFileSync(0, "utf-8").trim().split("\\n");\n  const N = parseInt(nStr);\n  const start = JSON.parse(startStr);\n  const target = JSON.parse(targetStr);\n  console.log(knightMinSteps(N, start, target));\n}\nmain();',
      },
      {
        language: 'python',
        code: "import sys, json\n\ndef main():\n    N = int(sys.stdin.readline())\n    start = json.loads(sys.stdin.readline())\n    target = json.loads(sys.stdin.readline())\n    print(knight_min_steps(N, start, target))\n\nif __name__ == '__main__':\n    main()",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function knightMinSteps(N, start, target) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def knight_min_steps(N, start, target):\n    # write your code here\n    pass',
      },
    ],
  },
  {
    title: 'Reconstruct Itinerary',
    slug: 'reconstruct-itinerary',
    description:
      'Given a list of airline tickets, reconstruct the itinerary in lexical order.',
    problemStatement:
      'You are given a list of airline tickets represented by pairs of departure and arrival airports `[from, to]`. Reconstruct the itinerary in such a way that:\n\n1. The itinerary starts at `"JFK"`.\n2. All tickets are used exactly once.\n3. The resulting itinerary has the smallest lexical order when read as a single string.\n\nYou must return the itinerary as a list of airport codes.\n\nExamples:\n\n<pre><code>Input:\ntickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]\nOutput: ["JFK","MUC","LHR","SFO","SJC"]\n</code></pre>\n\n<pre><code>Input:\ntickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]\nOutput: ["JFK","ATL","JFK","SFO","ATL","SFO"]\n</code></pre>\n\n<ul>\n<li>1 &lt;= tickets.length &lt;= 300</li>\n<li>tickets[i].length == 2</li>\n<li>from and to consist of uppercase English letters</li>\n<li>All tickets form at least one valid itinerary</li>\n</ul>\n\nPro Tip: Use Hierholzer’s algorithm (modified DFS) to construct Eulerian Path in lexical order.',
    sampleTestCases: [
      {
        input: '[["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]',
        expected: '["JFK","MUC","LHR","SFO","SJC"]',
      },
      {
        input:
          '[["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]',
        expected: '["JFK","ATL","JFK","SFO","ATL","SFO"]',
      },
    ],
    testCases: [
      {
        input: '[["JFK","KUL"],["JFK","NRT"],["NRT","JFK"]]',
        expected: '["JFK","NRT","JFK","KUL"]',
      },
      {
        input: '[["JFK","A"],["A","B"],["B","JFK"]]',
        expected: '["JFK","A","B","JFK"]',
      },
      {
        input: '[["JFK","A"],["A","JFK"],["JFK","B"],["B","A"]]',
        expected: '["JFK","A","JFK","B","A"]',
      },
      {
        input: '[["JFK","A"],["JFK","B"],["A","C"],["B","C"],["C","JFK"]]',
        expected: '["JFK","A","C","JFK","B","C"]',
      },
      {
        input:
          '[["JFK","B"],["B","C"],["C","D"],["D","E"],["E","F"],["F","JFK"]]',
        expected: '["JFK","B","C","D","E","F","JFK"]',
      },
      {
        input: '[["JFK","A"],["JFK","B"],["A","JFK"],["B","JFK"]]',
        expected: '["JFK","A","JFK","B","JFK"]',
      },
      {
        input: '[["JFK","A"],["A","B"],["B","A"],["A","JFK"]]',
        expected: '["JFK","A","B","A","JFK"]',
      },
      {
        input: '[["JFK","A"],["A","B"],["B","C"],["C","JFK"]]',
        expected: '["JFK","A","B","C","JFK"]',
      },
      {
        input: '[["JFK","A"],["A","B"],["B","C"],["C","A"]]',
        expected: '["JFK","A","B","C","A"]',
      },
      {
        input: '[["JFK","SFO"],["SFO","ATL"],["ATL","JFK"]]',
        expected: '["JFK","SFO","ATL","JFK"]',
      },
    ],
    topics: ['661fe6b2fef0834a99d3f471'],
    interviewExcerpt:
      'You are given a list of flights as departure-arrival pairs. Reconstruct the travel path starting at JFK such that all flights are used once and the path is lexically smallest.',
    categories: 'graphs',
    difficulty: 'hard',
    frequency: 91,
    tags: ['graph', 'eulerian path', 'dfs', 'hierholzer'],
    companies: [
      { name: 'Google', logoUrl: '' },
      { name: 'Facebook', logoUrl: '' },
      { name: 'Amazon', logoUrl: '' },
    ],
    hints: [
      'Sort the destinations for each departure in lexical order.',
      'Use DFS with backtracking (Hierholzer’s algorithm).',
      'Track the path by adding the node after all its neighbors are visited.',
    ],
    optimalComplexity: {
      time: 'O(E log E)',
      space: 'O(E + V)',
    },
    solutionCount: 1,
    version: 1,
    isPremium: false,
    isPublished: true,
    createdBy: '661fe6b2fef0834a99d3f471',
    preCode: [
      {
        language: 'javascript',
        code: 'const fs = require("fs");\nfunction main() {\n  const tickets = JSON.parse(fs.readFileSync(0, "utf-8").trim());\n  console.log(JSON.stringify(findItinerary(tickets)));\n}\nmain();',
      },
      {
        language: 'python',
        code: "import sys, json\n\ndef main():\n    tickets = json.loads(sys.stdin.read().strip())\n    print(json.dumps(findItinerary(tickets)))\n\nif __name__ == '__main__':\n    main()",
      },
    ],
    starterCode: [
      {
        language: 'javascript',
        code: 'function findItinerary(tickets) {\n  // write your code here\n}',
      },
      {
        language: 'python',
        code: 'def findItinerary(tickets):\n    # write your code here\n    pass',
      },
    ],
  },
];
